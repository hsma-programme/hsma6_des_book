[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - the little book of DES",
    "section": "",
    "text": "Licencing, Attribution and Acknowledgements",
    "crumbs": [
      "Licencing, Attribution and Acknowledgements"
    ]
  },
  {
    "objectID": "index.html#licencing",
    "href": "index.html#licencing",
    "title": "HSMA - the little book of DES",
    "section": "Licencing",
    "text": "Licencing\n\nCode Snippets\nAll code in this book is provided under the MIT Licence.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nText\nThe accompanying text in this book is licenced under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.",
    "crumbs": [
      "Licencing, Attribution and Acknowledgements"
    ]
  },
  {
    "objectID": "index.html#attribution-and-acknowledgements",
    "href": "index.html#attribution-and-acknowledgements",
    "title": "HSMA - the little book of DES",
    "section": "Attribution and Acknowledgements",
    "text": "Attribution and Acknowledgements\nThe content in this book is a combined effort, bringing together the knowledge of the Peninsula Collaborative for Operational Research and Design (PenCHORD) on the topic.\nThe content in part 1 and a large amount of part 2 is from a series of sessions given on discrete event simulation as part of the HSMA programme. These lectures and accompanying code examples were written by Dr Daniel Chalk  and made available under the CC BY-NC-SA 4.0 licence. The chapters often replicate the wording of these lectures nearly exactly, with minor tweaks and additions for readability and to better suit the format of a book made by Sammi Rosser .\nThe content in parts 3 and 4 is more of a mixture of content from the HSMA lectures along with brand new content written for this book mostly by Sammi Rosser , with a few pages also by Amy Heather . The book also draws on a range of work done by other members of the PenCHORD team, including: Tom Monks , Mike Allen , and Anna Laws .\nAll work that has been adapted is licenced under the MIT Licence. To comply with the terms of this licence, the MIT licence is provided below.\n\n\n\n\n\n\nMIT Licence of adapted code\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nAdaptation into book format has been done throughout by Sammi Rosser .\nHSMA 6: Lecture 1 - Slides - Github\nHSMA 6: Lecture 2 - Slides - Github\nHSMA 6: Lecture 3- Slides - Github",
    "crumbs": [
      "Licencing, Attribution and Acknowledgements"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html",
    "href": "intro_to_des_concepts.html",
    "title": "1  Introduction to DES Concepts",
    "section": "",
    "text": "1.1 Why use DES?\nDiscrete Event Simulation (DES) is a simulation modelling approach that allows us to model queuing problems. Queuing problems are those in which “things” (usually people, but not always) are waiting for a service or services.\nIn a Discrete Event Simulation, entities flow through (and queue for) discrete sequential processes that use resources. The queues may be physical (people physically waiting) or more abstract (people on a waiting list, waiting for an appointment etc).\nIn healthcare, DES models can be used to model:\nAnd more!\nDES models are extremely useful for asking what if? questions about process / pathway changes.\nDiscrete event simulation allows you to:\nThis can allow you to optimize a system, leading to better balance and better flow, which can in turn lead to:",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#why-use-des",
    "href": "intro_to_des_concepts.html#why-use-des",
    "title": "1  Introduction to DES Concepts",
    "section": "",
    "text": "Test changes in a risk-free, low-cost way.\nExplore the impact of changes in demand.\nSee whether a system can cope on bad days as well as good days.\nPredict how long it will take to clear an existing backlog.\n\n\n\nA safer environment.\nLess stress for staff.\nImproved patient experience.\nMeeting targets.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#an-example",
    "href": "intro_to_des_concepts.html#an-example",
    "title": "1  Introduction to DES Concepts",
    "section": "1.2 An example",
    "text": "1.2 An example\nImagine being able to create a model of an emergency department.\nIn this model, you can change all sorts of things:\n\nHow many doctors, nurses and receptionists there are at each step.\nHow long it takes for people to be seen.\nHow many people go into the trauma pathway versus the non-trauma pathway.\n\nThen sprinkle in a dose of randomness - because in real life, you’re not going to have each appointment taking the exact same amount of time, or people arriving exactly every five minutes - and then you can start to explore just how well a system will perform, what changes might have the most impact, and what configuration is likely to perform best. Then you can run it 1000 times with slightly different random days to see how well it performs on both good days and bad.\nYou can polish it all off by visualising the individual entities moving through the system so people with little understanding of discrete event simulation can get a sense of what’s going on, and you can give them access to all of the controls - the number of nurses and doctors, the average consultation length, and more - so that they can explore the impact of these changes themselves.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#runs-and-trials",
    "href": "intro_to_des_concepts.html#runs-and-trials",
    "title": "1  Introduction to DES Concepts",
    "section": "1.3 Runs and trials",
    "text": "1.3 Runs and trials\nA stochastic model is one that incorporates randomness and variability in its processes, meaning that different runs of the model can yield different outcomes. In a stochastic model, it is important that we do not just run a model once if we’re looking to draw insights from our results. This is because every run of the simulation will have different random samples for inter-arrival times, activity durations, and other key variables, leading to variation in the results. Running the model multiple times allows us to capture a range of possible scenarios and make more reliable conclusions.\nWhat if you had a run with unusually long activity times sampled (a run of “bad luck”)? Or unusually long inter-arrival times (a run of “good luck”)?\nWe need to run a stochastic simulation many times and take summary statistics over the results from each run to get more representative results from the model.\nA single run of a model for a simulated period of time is known as a run. A batch of multiple runs with the same parameter values is known as a trial.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#key-des-terminology",
    "href": "intro_to_des_concepts.html#key-des-terminology",
    "title": "1  Introduction to DES Concepts",
    "section": "1.4 Key DES terminology",
    "text": "1.4 Key DES terminology\n\nEntities are the things that are flowing through the sequential processes in the model (eg patients, test results, callers on a phone)\nGenerators are the way in which entities enter the model and come into being (eg arriving at ED by ambulance, self-presenting, referral from GP).\nInter-Arrival Times specify the time between entities being generated in the generators (ie the time between arrivals into the modelled system).\nActivities (sometimes referred to as Servers) are the bits of process that the entities are queuing up for (eg triaged, seen at reception, speak to doctor etc).\nActivity Time represents the amount of time it takes for an activity to happen to an entity - this is normally stochastic (random) and drawn from a distribution for each entity (eg time spent with nurse, time to be treated etc).\nResources are the “stuff” and / or “staff” required for an activity to happen to an entity (eg nurse to triage, bed for patient, consultation room for GP to see patient etc, X-Ray machine and Radiographer to be free for X-Ray etc). Important - resources may be shared between activities (eg the same nurse may be required to run multiple activities in our model, or even things we haven’t explicitly modelled).\nQueues hold entities that are waiting for an activity. Entities wait in a queue until the activity has both the capacity and all required resources.\nSinks are how entities leave the model (the bit of system we’re modelling).\n\n\n1.4.1 Entities\nEach entity may have certain “attributes” that it “carries with them” to help determine its journey through the modelled system. For example:\n\nWhether it goes down path A or B.\nHow long it spends in an activity.\nIts priority in a queue for an activity.\n\nThere may also be more than one type of entity in a model at the same time. For example, patients in a clinic, their test results, and phone calls into the clinic are all entities that we may want to capture when modelling the clinic.\n\n\n\n1.4.2 Generators and inter-arrival\nA generator creates new entities to bring into the system. The rate at which new entities are generated is determined by an inter-arrival time.\nThe inter-arrival time determines the time between one entity being generated, and the next one being generated.\nInter-arrival times may be fixed, but are typically sampled (drawn) stochastically (randomly) from a distribution to capture variability (even if the variability is small).\nAn Exponential Distribution is often used to sample inter-arrival times. More than one distribution may be used for the same generator (e.g. for different times of the day, day of week etc). You may also (often) have more than one generator in a system.\n\n\n\n1.4.3 Queues\nEach activity in a Discrete Event Simulation has an associated queue. The queue holds entities whilst they wait for the activity to become available for them.\nEach queue has a queuing policy. This determines the order in which entities are released from the queue into the activity. The two most common queuing policies are:\n\nFirst In First Out (FIFO) : entities are seen in the order they arrive. This is the default.\nPriority-based : entities are seen according to some priority attribute. Ties often resolved using FIFO.\n\n\n\n\n1.4.4 Activities and activity times\nEach activity in a DES describes a process – this may be a simple atomic task, or a set of tasks bundled together. For an activity to take place, it needs:\n\nAn entity (drawn from the queue).\nThe required type and number of resource to be available.\n\nOnce the above conditions have been met, the activity begins. The entity, and the resource(s) are then locked in place for an amount of time – the Activity Time. The resource(s) cannot be used elsewhere until the activity time has passed.\nActivity times may be fixed, but are typically sampled stochastically from a distribution.\n\n\n\n\n\n\n\nTip\n\n\n\nThe common distribution for process times is the Log Normal distributions. However, Exponential Distributions can be a good starting point, as it’s easy to change the “mean” when playing around with things. You can then change to something like a Log Normal once you (and the stakeholders) are happy\n\n\n\n\n1.4.5 Resources\nResources are needed to undertake activities. An activity may require just a single resource, more than one resource of the same type, or multiple resources of different types.\n\n\n\n\n\n\nTip\n\n\n\nAn activity may not require a resource at all, but think carefully to ensure that it really is either “resourceless” or there is no constraint on the resource (and so doesn’t need to be modelled).\nResources can include: - “Staff” (e.g. doctors, nurses, officers etc). - “Stuff” (beds, test equipment, detention cell etc).\n\n\nResources can (and often are) shared across a system, so may be required for more than one activity. Therefore, a resource drain in one part of the system can affect another.\nAll required resources are needed for an activity to take place.\nIn some activities, having optional additional resource may speed up the activity (though rarely linearly).\n\n\n\n1.4.6 Sinks\nSinks are how entities leave the system, or part of the system, being modelled. Sinks might include:\n\nAn entity physically leaving a system (e.g. discharge from hospital).\nAn entity no longer existing (e.g. death, use of sample, end of telephone call).\nAn entity no longer needing to access activities that we’re interested in (e.g. they leave the bit of the system that we’re modelling).\n\nThe most important thing to remember about a sink is that it doesn’t necessarily represent an entity leaving the system entirely.\nFor example, the scope of your model may only cover the triage aspect of an Emergency Department. Therefore, a valid sink might be placed after their triage - they’ve left the scope of our model\n\n\n\n1.4.7 Branching paths\nReal world systems (and the models of those systems) are rarely linear. Often, different things will happen to different entities. In a Discrete Event Simulation, this means different entities flowing to different activities, or different sinks.\nWe might differentiate based on:\n\nAn attribute of the patient (e.g. patients with a higher priority value flow through a different set of activities).\nProbability (e.g. we know that approx 60% of these patients end up being admitted, so we’ll randomly select for them to be admitted 60% of the time).\nTime (e.g. after a certain time of day, entities flow through a different set of activities).\n\n\n\n\n1.4.8 Outputs\nAs with any type of model, it’s important to think about what outputs you need your DES model to generate to answer your modelling questions. As a DES model is used to model queuing and resourcing problems, typical DES model outputs include average, min, max, xth percentile of:\n\nTime entities are in system.\nQueue length and duration for queues of interest.\nRate of resource utilisation (ie % of time a resource is in use for activities in the model).\nProbability of exceeding a defined queue length / queue time / resource utilisation threshold (e.g. 4 hour wait in ED, overcrowding thresholds).",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "exercise_des_design.html",
    "href": "exercise_des_design.html",
    "title": "2  Exercise - Designing a DES",
    "section": "",
    "text": "Design a Discrete Event Simulation for a system of your choosing.\nThink about some different possibilities (and these don’t have to be health-related, they can be anything! A restaurant? Airport? Customer service line?).\nYou should then draw up a design for the model. This should include:\n\nThe “what if?” question(s) you would use the model to answer.\nA process map of the system you are looking to model.\nA conceptual model for the proposed Discrete Event Simulation (which may not include everything in the process map).\n\nIdentify the types of entities, generators, activities, queues, resources and sinks.\nDescribe what each of your inter-arrival times and activity times represent, and from where you might draw the data.\nConsider the scope, level of detail etc when designing your model. What do you need to model to answer your question? How can you simplify your model?\n\n\n\n\n\n\nTip\n\n\n\nThe website draw.io (also known as diagrams.net) is a great free resource for creating process maps.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Exercise - Designing a DES</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html",
    "href": "intro_to_simpy.html",
    "title": "3  An Introduction to SimPy",
    "section": "",
    "text": "3.1 Simulation time\nSimPy is a Python package that allows us to create powerful Discrete Event Simulation (DES) models.\nYou can read SimPy’s own tutorials and reference guides on its website (https://simpy.readthedocs.io/en/latest/) but we’d recommend working through at least the first few chapters in this book first.\nBefore we look at how we put together a SimPy model, there’s a couple of concepts we need to cover first that are important to understand.\nSimPy simulations run in time units. These units of time can represent any real world amount of time we like as long as we are consistent within the same model.\nOur time units should represent the lowest level of real world time that we need to represent in the model. In models of pathways where people arrive for a service, this will likely be minutes (seconds is too much, and hours is probably not enough, unless all the processes are slow). But we may have pathways where we measure time in days or weeks (e.g. referral pathways).\nFor example, in an emergency department (ED) model, our time units may represent minutes. So we specify everything in minutes - inter-arrival times, activity times etc.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html#simulation-time",
    "href": "intro_to_simpy.html#simulation-time",
    "title": "3  An Introduction to SimPy",
    "section": "",
    "text": "Note\n\n\n\nStrictly speaking, SimPy doesn’t progress in fixed time units. Instead, it schedules events and jumps to the next one. However, you don’t need to worry about that. Just note that, as a result, the simulation time is represented as floating-point numbers (e.g., the current time could be 3.6).",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html#generator-functions",
    "href": "intro_to_simpy.html#generator-functions",
    "title": "3  An Introduction to SimPy",
    "section": "3.2 Generator functions",
    "text": "3.2 Generator functions\nSimPy is built around a special type of function in Python known as a Generator Function.\nSo let’s have a look at what we mean by a Generator Function.\nConventional functions in Python are called, then run with some (optional) inputs, and then finish (usually by returning some output). When we call the function again, it runs again, from scratch.\nGenerator functions remember where they were and what they did when control is passed back (they retain their local state), so that they can continue where they left off, and can be used as powerful iterators (for and while loops are other examples of iterators).\nThis is very useful where we want state to be maintained, so we can remember how long until we generate the next entity, or where an entity is in a pathway…\nLet’s look at a very simple example of a generator function to see how they work.\n\nIn SimPy, we use Generator Functions in two different places:\n\nTo model the DES generators (arrival points).\nTo model the individual journey of each entity.\n\nLet’s imagine we are modelling patients in a patient pathway.\nFor 1. Modelling the DES generators (arrival points): The generator function basically creates a patient, sets them off on their pathway, then freezes in place for an amount of time representing the inter-arrival time to the next patient. Then it does it all over again.\nFor 2. Modelling the individual journey of each entity: The generator function requests a resource and freezes until that resource is available (the queue). When the resource is available it freezes in place for an amount of time with it (the activity). It will then either move on to the next activity (and request the resource for it, as above) or end if there are no further activities.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html",
    "href": "recommended_structure_classes_for_des_models.html",
    "title": "4  The Recommended Structure for DES Models",
    "section": "",
    "text": "4.1 Class breakdown\nThere are many different ways to structure SimPy models.\nYou will often find different coders have their own preferred approach!\nWe’re going to structure our SimPy model in an Object Oriented way.\nSpecifically, we’re going to have 4 different classes: g, entity, model, and trial.\nWhile object oriented code can feel a bit cumbersome for small models, following the same sort of pattern each time makes it really easy to keep track of what your model is doing. It also makes it a lot easier to expand and modify your model over time.\nThe other benefit is that you will find other models from people who have done the HSMA course are likely to have a similar structure - so you should find it easier to read, reuse and tweak their models too!\ng Class\nThis is a special class that will store our global level parameters for the model.\nUnlike most OOP cases, we won’t create an instance of this class (hence the lower case) - we’ll just refer to the blueprint directly.\nEntity\nThis class will represent our entity.\nAn entity could be a customer, a passenger, etc., but often in our healthcare models, our entities will be patients.\nEntities will carry with them information that we can record to and / or read from (e.g. an ID, how long they spent queuing, their condition etc).\nIf we had more than one entity, we’d need a class for each.\nMultiple entities could be different types of patients - e.g. trauma patients and non-trauma patients.\nModel\nThis is the big one that represents the system that we are modelling.\nThis could be a phone helpline, a clinic, an emergency department, an airport terminal, a healthcare clinic that runs appointments - many processes are suitable.\nIt’ll have our generators, our entity journeys and more, and it’s where our SimPy environment (where everything lives) will be kept.\nTrial\nThis class will represent a batch of runs of our simulation, and will have methods to run a trial, extract results etc.\nLet’s look at the purpose and recommended structure of each class in a bit more detail.\nHere, the example code given relates to a customer support helpline. Customers call a helpline, wait on hold until a customer support agent is ready to speak to them, speak to the agent for a period of time, and then the call ends and the agent connects to the next person who is waiting on hold. If there is no-one on hold at the time, the agent will get a break until someone else arrives!",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html#class-breakdown",
    "href": "recommended_structure_classes_for_des_models.html#class-breakdown",
    "title": "4  The Recommended Structure for DES Models",
    "section": "",
    "text": "4.1.1 g class\nThe g Class stores our global parameter values for the model so we can easily change aspects of the model to test scenarios. This includes:\n\nValues to define inter-arrival time distributions (eg mean, standard deviation etc).\nValues to define activity time distributions (eg mean, standard deviation etc).\nNumber of each resource.\nDuration of simulation runs.\nNumber of runs in a trial.\n\nWe do not create an instance of g class. Instead, we refer to it directly when we need to access something in it.\n\n\n\n\n\n\nExample g class\n\n\n\n\nclass g:\n    time_units_between_customer_arrivals = 5\n    mean_customer_service_time = 6\n    number_of_customer_support_agents = 1\n    sim_duration = 1440\n    number_of_runs = 10\n\n\n\n\n\n4.1.2 Entity class\nThe entity class represents our entity in the model - which, for healthcare models, will often be patients.\nWe can store attributes here that entities carry with them that we may want to access (think of a person carrying a clipboard with them with information on it).\nIn a simple model, an entity may just carry their ID and how long they spent queuing for a resource (once known). But more advanced models could store things like their condition, their priority, probability of going down path x, etc.\n\n\n\n\n\n\nExample entity class\n\n\n\n\nclass Customer:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.queue_time_customer_support_agent = 0\n\n\n\n\n\n4.1.3 Model class\nThe Model Class represents the system we are modelling - this might be a clinic, for example. As such, there’s a lot more to unpack here, so let’s take this bit by bit.\nFirst, we’ll look at the constructor for our model.\nThe constructor will set up:\n\nA SimPy Environment (basically where everything lives).\nAn entity counter (which we’ll use to give entities - such as patients - a simple ID).\nThe resources we need (for example, our nurses).\nA DataFrame to store per-entity results in a single run of the model.\nAttributes to store things like how long the entities queued for each activity.\n\nWhat the constructor sets up doesn’t have to be limited to these things - anything relating to the system as a whole that makes sense to store here could be included.\n\n4.1.3.1 DES generator - arrivals of entities to the system\nWithin the Model Class we have a generator function that will represent our DES generator for entities arriving into our process.\nHere’s basically how it works:\nKEEP REPEATING THE FOLLOWING FOREVER (until the simulation stops running):\n\nIncrement the counter to get ID for next entity.\nCreate a new entity and give them that ID.\nStart up an instance of the generator function for their journey through the process and chuck them in it.\nSample the time until the next entity arrives.\nFREEZE this function until that time elapses.\nReturn to 1.\n\n\n\n4.1.3.2 DES Generator - the entity journey\nNow, let’s look at the big one. The other generator function - the one that represents an entity’s journey through the system (this is the one we lobbed the new entities generated by the previous generator).\nHere’s how this works:\n\nRecord time started queuing for first activity.\nRequest resource for first activity.\nWait until resource is free.\nOnce resource is free, grab the resource and keep hold of the resource until finished with them. Record time finished queuing and calculate queue time.\nSample how long will spend in this activity.\nFREEZE this instance of the function until that time elapses (freezing the resource with it, so it’s not available to anyone else).\nIf there’s another activity, do the same again for that one. If not, end (and therefore entity leaves the model).\n\n\n\n4.1.3.3 Running the model\nFinally, we need a run method in our Model class. Basically, the run method will:\n\nStart up our DES generators (our arrival points) - we only have one here.\nTell the simulation to run for the duration specified in g Class.\nCall the calculate run results method in the previous slide.\nPrint out the run number with the patient-level results from this run.\n\n\n\n\n\n\n\nFull Example model class\n\n\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a customer counter (which we'll use as a customer ID)\n        self.customer_counter = 0\n\n        # Create a SimPy resource to represent a customer support agent, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.customer_support_agent = simpy.Resource(self.env, capacity=number_of_customer_support_agents)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the customer ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Customer ID\"] = [1]\n        self.results_df[\"Queue Time\"] = [0.0]\n        self.results_df[\"Time with Customer Support Agent\"] = [0.0]\n        self.results_df.set_index(\"Customer ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the support agents\n        # across this run of the model\n        self.mean_queue_time_support_agent = 0\n\n    # A generator function that represents the DES generator for customer\n    # arrivals\n    def generator_customer_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the customer counter by 1 (this means our first customer\n            # will have an ID of 1)\n            self.customer_counter += 1\n\n            # Create a new customer - an instance of the customer Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # customer - so here we pass the customer counter to use as the ID.\n            c = Customer(self.customer_counter)\n\n            # Tell SimPy to start up the use_customer_service_helpline generator function with\n            # this customer (the generator function that will model the\n            # customer's journey through the system)\n            self.env.process(self.use_customer_service_helpline (c))\n\n            # Randomly sample the time to the next customer arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter_arrival_time = random.expovariate(1.0 / g.time_units_between_customer_arrivals)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter_arrival_time)\n\n    # A generator function that represents the pathway for a customer calling our helpline\n    # Here the pathway is extremely simple - a customer\n    # arrives in the call system, waits to be connected to a customer support agent,\n    # spends a varying amount of time being helped by the agent, and then leaves,\n    # meaning the agent is free to help the next person.\n    # The customer object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def use_customer_service_helpline(self, customer):\n        # Record the time the patient started queuing for a nurse\n        start_q_customer_support_agent = self.env.now\n\n        # This code says request a customer support agent resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.customer_support_agent.request() as req:\n            # Freeze the function until the request for a customer support agent can be met.\n            # The customer is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a customer support agent has\n            # been met.  We now have the customer support agent, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_customer_support_agent = self.env.now\n\n            # Calculate the time this patient was queuing for the customer support agent, and\n            # record it in the customer's attribute for this.\n            customer.queue_time_customer_support_agent = end_q_customer_support_agent - start_q_customer_support_agent\n\n            # Now we'll randomly sample the time this customer with the customer support agent.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_customer_support_agent_activity_time = random.expovariate(1.0 /\n                                                        g.mean_customer_service_time)\n\n            # Here we'll store the queuing time for the customer support agent and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this customer.\n            #\n            # In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            #\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[customer.id, \"Queue Time\"] = (\n                customer.queue_time_customer_support_agent)\n            self.results_df.at[customer.id, \"Time with Customer Support Agent\"] = (\n                sampled_customer_support_agent_activity_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the customer support\n            # agent.\n            yield self.env.timeout(sampled_customer_support_agent_activity_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_queue_time_support_agent = self.results_df[\"Time with Customer Support Agent\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new customers.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_customer_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the customer-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n\n\n\n\n4.1.4 Trial class\nOur final class is the Trial class. This represents a batch of simulation runs, and will contain methods to run a batch of runs, as well as store, record and display results from the trial.\n\n\n\n\n\n\nExample trial class\n\n\n\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Customer Supoprt Agent\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_queue_time_support_agent]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\nWe can, of course, then take the means over the runs in the trial to get the average predicted queuing time etc. - and we should probably do that in a separate method in the Trial class.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html",
    "href": "an_example_simpy_model.html",
    "title": "5  An Example SimPy Model",
    "section": "",
    "text": "5.1 Import statements\nIn the example we’re going to look at, we’ll model a very simple model - patients arriving at a clinic for a nurse consultation. One type of entity, one generator, one activity, one queue, one sink, one type of resource.\nA SimPy model can seem quite complex at first, particularly for such a simple model as this. But the good news is the overall structure is always the same, regardless of complexity.\nFirst we need our import statements. The libraries you import will vary depending on your model and what you need, but these three are likely going to always be in there (the first must be!)\nimport simpy\nimport random\nimport pandas as pd",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#import-statements",
    "href": "an_example_simpy_model.html#import-statements",
    "title": "5  An Example SimPy Model",
    "section": "",
    "text": "Tip\n\n\n\nrandom gives us access to stochastic sampling from probability distributions",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#g-class",
    "href": "an_example_simpy_model.html#g-class",
    "title": "5  An Example SimPy Model",
    "section": "5.2 g class",
    "text": "5.2 g class\nRemember - the g Class stores our global parameter values for the model so we can easily change aspects of the model to test scenarios.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#patient-entity-class",
    "href": "an_example_simpy_model.html#patient-entity-class",
    "title": "5  An Example SimPy Model",
    "section": "5.3 Patient (entity) class",
    "text": "5.3 Patient (entity) class\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#model-class",
    "href": "an_example_simpy_model.html#model-class",
    "title": "5  An Example SimPy Model",
    "section": "5.4 Model class",
    "text": "5.4 Model class\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#trial-class",
    "href": "an_example_simpy_model.html#trial-class",
    "title": "5  An Example SimPy Model",
    "section": "5.5 Trial class",
    "text": "5.5 Trial class\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nNow we just need to run the trial and print out the results!\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         1.999138\n2               0.000000         0.050537\n3               0.000000         5.534735\n4               4.842668         4.343900\n5               1.980890         4.924788\n6               4.764097         0.152606\n7               2.337300         1.856604\n8               0.000000         1.922575\n9               0.000000         0.239433\n10              0.000000         8.600984\n11              6.927535        11.445952\n12             13.543065         1.240832\n13             13.082921        11.657120\n14             22.523634        10.764221\n15             31.828509        10.500593\n16             42.134821         6.316369\n17             37.695450        13.727550\nRun Number 1\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         2.981912\n2               0.000000         5.026403\n3               0.851660         7.055668\n4               7.819162         2.161976\n5               6.037519         3.926844\n6               9.961891         0.007959\n7               7.421316        16.748293\n8              20.297538         1.416732\n9              19.635925         4.975646\n10             20.252205         2.157325\n11             20.774943         2.453720\n12              9.135544         0.371875\n13              0.000000         4.513592\n14              0.000000         4.997927\n15              4.964756         7.118073\n16              0.098442         9.726582\n17              5.953267        14.555791\n18             12.176320        14.945011\n19             26.060330         6.083494\n20             29.686997         3.183870\n21             32.121814        10.472416\nRun Number 2\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.635599\n2               0.000000         5.942180\n3               0.000000         1.410380\n4               0.609115         4.260951\n5               0.000000         1.663679\n6               0.695821         1.412957\n7               0.000000         0.554011\n8               0.000000         2.452848\n9               0.000000        14.063074\n10             13.843788         6.510570\n11             13.066584         2.988807\n12             12.285030        10.118939\n13             20.511573         1.102553\n14              9.879036         7.931369\n15             16.066427         4.197728\n16             14.189824        17.966929\nRun Number 3\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000        20.662152\n2              17.081906         1.179041\n3              15.198943         6.259041\n4              20.950419        11.435987\n5              29.045439         6.555010\n6              21.430206        11.056897\n7              27.633772         6.599005\n8              32.169563        20.819183\n9              51.984937         2.410215\n10             53.267007         0.056786\n11             51.777849         5.734249\n12             46.700455         9.924293\n13             51.234464         6.474207\n14             48.087152         4.759622\n15             52.045918         6.343605\nRun Number 4\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         5.360526\n2               0.717629         0.666898\n3               0.000000        20.445285\n4              19.376320         2.561793\n5              10.823152         0.816809\n6               7.382799        21.078977\n7              15.480541         2.647045\n8              11.309890        20.781928\n9              31.034256         1.381996\n10             30.422640        23.961155\n11             36.540842         1.385177\n12             35.322946         2.141456\n13             33.710611         0.495245\n14             33.326393         2.979572\n15             35.705080         5.416627\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                   10.685935\n1                   11.107125\n2                    6.321700\n3                   34.573869\n4                   20.076873",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>An Example SimPy Model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_multiple_steps.html",
    "href": "an_example_simpy_model_multiple_steps.html",
    "title": "6  Adding Multiple Activities",
    "section": "",
    "text": "6.1 Coding the model\nVery often there will be more than one activity in a model.\nWhat if instead of this model\nWe wanted something more like this?\nIf we want patients to flow from one activity to another, we just write another one after the first one in the pathway generator function. That (aside from adding in any extra resources and results capture elsewhere) is it.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Adding Multiple Activities</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_multiple_steps.html#coding-the-model",
    "href": "an_example_simpy_model_multiple_steps.html#coding-the-model",
    "title": "6  Adding Multiple Activities",
    "section": "",
    "text": "Tip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n6.1.1 The g class\nFirst, lets add some additional parameters to our g class.\n\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5\n\n\n\n6.1.2 The patient class\nNext we’ll add an additional attribute - think of it as an extra box on their clipboard that they need to fill in - to record how long they are queuing for the receptionist.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n\n\n\n6.1.3 The model class\nNow we move to our model class. Let’s start by looking at the init method - the list of things that are set up when we create an instance of our model class.\nFirst, we have added in a new type of resource - a receptionist, pulling in the number of receptionist to create from our g class.\nWe’ve then added two additional fields to our results dataframe - how long each patient queues for a receptionist, and how long each patient spends with the receptionist.\nFinally, we add in an attribute that we will use to store the mean average queuing time for receptionists across the whole model.\n\ndef __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n\nOur generator_patient_arrivals method remains unchanged as nothing has been tweaked about how patients turn up to the system.\nOur attend_clinic method is where we make the actual change to the process the patient goes through.\nNote that we have a new line with an indended section inside it.\n\nwith self.receptionist.request() as req:\n\nEverything at one level of indentation within this now relates to the use of the receptionist resource.\n\n # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n\n\n6.1.4 The trial class\nThe trial class is unchanged.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Adding Multiple Activities</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_multiple_steps.html#the-full-code",
    "href": "an_example_simpy_model_multiple_steps.html#the-full-code",
    "title": "6  Adding Multiple Activities",
    "section": "6.2 The full code",
    "text": "6.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 2\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean() ##NEW\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0] ##NEW\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW (added receptionist queuing mean as first item to list)\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Adding Multiple Activities</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_multiple_steps.html#evaluating-the-outputs",
    "href": "an_example_simpy_model_multiple_steps.html#evaluating-the-outputs",
    "title": "6  Adding Multiple Activities",
    "section": "6.3 Evaluating the outputs",
    "text": "6.3 Evaluating the outputs\nLet’s run the updated code and see the outputs.\nWe can see we now get results for the time queueing for and the time spent with the receptionist and the nurse, displayed separately, and that these times are different from each other.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         0.971999      0.000000         4.290605\n2               0.000000         0.110098      0.000000         3.520545\n3               0.000000         3.295441      0.000000         5.125294\n4               3.276749         2.125569      2.999725         3.685311\n5               0.000000         2.728743      2.119007         7.894289\n6               1.895009         0.715557      9.297739         5.511429\n7               0.000000         4.500982      8.912020         1.446649\n8               0.917021         1.275261      9.083408        14.649955\n9               0.000000         0.703484     18.072800         1.895313\n10              0.000000         1.208143     16.241934         2.479590\n11              0.000000         3.421643     13.927296         2.255097\n12              0.000000         0.125478     14.787427         5.782837\n13              0.000000         0.931172     18.254003         0.597325\n14              0.000000         1.116871     17.239309         2.448820\n15              0.000000         0.697740     15.827708         1.757600\n16              0.000000         0.526777     13.493230         2.220310\n17              0.000000         0.198663      0.000000         1.885045\n18              0.000000         0.862126      0.000000         1.221127\n19              0.000000         0.833302           NaN              NaN\nRun Number 1\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         1.593026      0.000000         9.345104\n2               0.000000         2.723372      0.378510         1.562441\n3               2.163104         2.903513      0.000000         6.137468\n4               0.000000         0.335004      5.031974         5.857652\n5               0.000000         0.718053      0.000000         3.313900\n6               0.047869         0.713944      2.599956         1.901189\n7               0.000000         0.006520      0.000000         4.797418\n8               0.000000         0.570416      2.663493         1.131057\n9               0.000000         1.227553      0.000000        10.190476\n10              0.000000         2.860186      3.477825         4.961014\n11              0.000000         0.729655      6.457554        10.197142\n12              0.000000         0.371229     15.694308         0.101973\n13              0.182905         0.452037     15.344244         8.932523\n14              0.000000         0.862469     22.943361        17.259605\n15              0.000000         0.306016     38.748551        16.783636\n16              0.000000         0.729838           NaN              NaN\n17              0.000000         1.984859           NaN              NaN\n18              0.610873         1.384581           NaN              NaN\n19              0.000000         1.292654           NaN              NaN\n20              0.000000         5.589228           NaN              NaN\n21              0.000000         6.054273           NaN              NaN\n22              4.946547         0.388561           NaN              NaN\n23              0.000000         0.008673           NaN              NaN\n24              0.000000         0.962845           NaN              NaN\n25              0.000000         6.698285           NaN              NaN\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse\nRun Number                                      \n0                    0.320462           8.903089\n1                    0.318052           7.555985",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Adding Multiple Activities</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html",
    "href": "an_example_simpy_model_branching.html",
    "title": "7  Adding Branching Paths",
    "section": "",
    "text": "7.1 Coding the model\n“Most real world systems aren’t linear!” we hear you say. “Some people go over here, some go over there.”\nYou want branching paths? Coming right up!\nSo this time, instead of this model\nOr this model\nWe will create something more like this:\nTo model a branching path, we can use our good old Python friend Conditional Logic.\nOften, the branches in a DES are based on probabilities that represent the proportion of patients (or whatever your entity is) that travel along a certain route. For example, the data might show that 60% of patients see a doctor after seeing a nurse.\nTo model this, we can randomly sample from a uniform distribution between 0 and 1, and compare the value to this probability. If we pick a value below the probability, then we say that the patient follows this route. Why does this work? Well…\n60% of values between 0 and 1 are below 0.6.\nTherefore, if there’s an equal chance of any value being picked (as is the case in a uniform distribution) then there’s a 60% probability of picking one below 0.6.\nWe can use this to emulate the probability of following a path.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html#coding-the-model",
    "href": "an_example_simpy_model_branching.html#coding-the-model",
    "title": "7  Adding Branching Paths",
    "section": "",
    "text": "Tip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n7.1.1 g class\nWe need to add a few additional parameters to our g class.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20 ##NEW\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2 ##NEW\n    prob_seeing_doctor = 0.6 ##NEW\n    sim_duration = 120\n    number_of_runs = 5\n\n\n\n7.1.2 Patient class\nWe want to add an additional attribute to record the time patients spend with the doctor if they see one.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0 ##NEW\n\n\n\n7.1.3 Model class\n\n7.1.3.1 the init method\nIn the init method, we add a few additional atrributes to store additional outputs from the model.\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0] ##NEW\n        self.results_df[\"Time with Doctor\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW\n\n\n\n7.1.3.2 The generator_patient_arrivals method\nThis method is unchanged.\n\n\n7.1.3.3 The attend_clinic method\nHere, we need to add in a chance of patients seeing the doctor on their journey.\n\ndef attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        start_q_nurse = self.env.now\n\n        with self.nurse.request() as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.\n\n        ##NEW\n        ##\n        ## -----------------------------------------------------------\n        ## This is where our new code for seeing the doctor is\n        ## We use conditional logic to determine whether the patient goes\n        ## on to see the doctor or not\n        ## ------------------------------------------------------------\n        #\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        #\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\nLet’s try and understand a bit more about how we trigger the conditional logic.\nLet’s look at the output of the line random.uniform(0,1)\n\nrandom.uniform(0,1)\n\n0.6394267984578837\n\n\nWhat about if we run it multiple times?\n\nfor i in range(10):\n  print(random.uniform(0,1))\n\n0.025010755222666936\n0.27502931836911926\n0.22321073814882275\n0.7364712141640124\n0.6766994874229113\n0.8921795677048454\n0.08693883262941615\n0.4219218196852704\n0.029797219438070344\n0.21863797480360336\n\n\nSo how does this relate to our code?\nIn our g class, we set a probability threshold for patients being seen. Let’s pull that out:\n\nprint(g.prob_seeing_doctor)\n\n0.6\n\n\nThe code in the Model class tests whether the number generated by the random number generator is below the threshold we’ve set of seeing the doctor. If it is, the indented code where we actually see the doctor will be run for that patient. If it is not, that bit is bypassed - which in this case means they’ve reached the end of their journey and leave the system (a sink).\n\nfor i in range(10):\n  random_number = random.uniform(0,1)\n  is_below_threshold = random_number &lt; g.prob_seeing_doctor\n\n  if is_below_threshold:\n    print(f\"Random number {random_number:.2f} is LOWER than threshold ({g.prob_seeing_doctor}). \" +\n    \"Doctor code is triggered.\")\n  else:\n    print(f\"Random number {random_number:.2f} is HIGHER than threshold ({g.prob_seeing_doctor}). \" +\n    \"Doctor code is **not** triggered.\")\n\nRandom number 0.51 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.03 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.20 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.65 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\nRandom number 0.54 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.22 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.59 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.81 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\nRandom number 0.01 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.81 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\n\n\nIf we run this code a hundred thousand times and plot the results, we can start to see the pattern emerging despite the random element of the number generator.\n\nimport plotly.express as px\nimport pandas as pd\nimport numpy as np\n\nrandom_vals = [random.uniform(0,1) for i in range(100000)]\n\nrandom_vals_df = pd.DataFrame({\"value\" :random_vals})\n\nrandom_vals_df['threshold'] = np.where(random_vals_df[\"value\"]&lt;0.6, 'below', 'above')\n\nfig = px.histogram(random_vals_df, color=\"threshold\")\n\nfig.update_traces(xbins=dict(\n        start=0.0,\n        end=1.0,\n        size=0.1\n    ),\n    marker_line_width=1,marker_line_color=\"black\")\n\n\nfig.show()\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nSo for every 1000 patients, roughly 600 will see a doctor, and roughly 400 will leave the system straight after seeing the nurse.\n\n\n7.1.3.4 The calculate_run_results method\nIn this method, we just add an additional step to measure the mean time spent queueing for a doctor across all patients in this run.\n\n# This method calculates results over a single run.  Here we just calculate\n# a mean, but in real world models you'd probably want to calculate more.\ndef calculate_run_results(self):\n    # Take the mean of the queuing times across patients in this run of the\n    # model.\n    self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n    self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean() ##NEW\n\n\n\n7.1.3.5 The run method\nThe run method is unchanged\n\n\n\n7.1.4 Trial class\n\n7.1.4.1 The init method\nIn the init method, we just add a placeholder for measuring the mean queue time of a doctor.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n7.1.4.2 The run_trial method\nHere, we just add in the mean queue time for the doctor to the trial results dataframe.\n\n  def run_trial(self):\n      # Run the simulation for the number of runs specified in g class.\n      # For each run, we create a new instance of the Model class and call its\n      # run method, which sets everything else in motion.  Once the run has\n      # completed, we grab out the stored run results (just mean queuing time\n      # here) and store it against the run number in the trial results\n      # dataframe.\n      for run in range(g.number_of_runs):\n          my_model = Model(run)\n          my_model.run()\n\n          ##NEW - added mean queue time for doctor to end of list\n          self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                            my_model.mean_q_time_nurse,\n                                            my_model.mean_q_time_doctor]\n\n      # Once the trial (ie all runs) has completed, print the final results\n      self.print_trial_results()",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html#the-full-code",
    "href": "an_example_simpy_model_branching.html#the-full-code",
    "title": "7  Adding Branching Paths",
    "section": "7.2 The full code",
    "text": "7.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20 ##NEW\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2 ##NEW\n    prob_seeing_doctor = 0.6 ##NEW\n    sim_duration = 120\n    number_of_runs = 1\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0 ##NEW\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0] ##NEW\n        self.results_df[\"Time with Doctor\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        ##NEW added conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean() ##NEW\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - added mean queue time for doctor to end of list\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse,\n                                              my_model.mean_q_time_doctor]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html#evaluating-the-outputs",
    "href": "an_example_simpy_model_branching.html#evaluating-the-outputs",
    "title": "7  Adding Branching Paths",
    "section": "7.3 Evaluating the outputs",
    "text": "7.3 Evaluating the outputs\nLet’s look at the outputs for a single run.\nWhen a patient doesn’t see a doctor, notice that their value for that row is NaN - which stands for “not a number”. This will be treated differently to 0 in calculations of the mean - i.e. it won’t be included at all, whereas a queue time of 0 will matter.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse  \\\nPatient ID                                                                 \n1               0.000000         0.164455      0.000000        13.920914   \n2               0.000000         0.517079     12.717109         7.064436   \n3               0.000000         3.507019     13.651053         2.107220   \n4               1.791675         1.914879     13.843393         4.172893   \n5               2.942190         7.578821     10.437466         3.408435   \n6               0.000000         0.137868      5.492462         0.770591   \n7               0.000000         0.038824      4.238580         2.573929   \n8               0.000000         4.497553      0.000000         3.634398   \n9               0.632419         1.127904      2.506494        10.751089   \n10              0.000000         1.827010      9.859928         2.064096   \n11              0.000000         2.691982      0.000000         5.879487   \n12              0.000000         4.235160      0.000000         4.587604   \n13              0.677981         0.348057      4.239547         0.455397   \n14              0.000000         0.286387      0.000000        18.738572   \n15              0.000000         2.380793      0.000000        16.075224   \n16              1.274408         0.609359     15.465865         5.910793   \n17              0.335087         0.758238           NaN              NaN   \n18              0.000000         1.659091           NaN              NaN   \n19              1.568443         0.213691           NaN              NaN   \n20              0.074793         1.532815           NaN              NaN   \n21              0.000000         2.175654           NaN              NaN   \n\n            Q Time Doctor  Time with Doctor  \nPatient ID                                   \n1                0.000000          0.337148  \n2                0.000000         20.124791  \n3                0.000000         10.157277  \n4                5.984384         10.343443  \n5               10.436243          6.464671  \n6                     NaN               NaN  \n7                     NaN               NaN  \n8                0.000000         39.116816  \n9                0.000000         30.225136  \n10                    NaN               NaN  \n11                    NaN               NaN  \n12              14.854357          5.365691  \n13              16.258368          2.616966  \n14               0.000000          9.841665  \n15               0.000000          5.992586  \n16                    NaN               NaN  \n17                    NaN               NaN  \n18                    NaN               NaN  \n19                    NaN               NaN  \n20                    NaN               NaN  \n21                    NaN               NaN  \nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                          \n0                    0.442714           5.778244            4.321214",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "exercise_gp.html",
    "href": "exercise_gp.html",
    "title": "8  Exercise - Building Your First Model",
    "section": "",
    "text": "8.1 Required outputs\nYour task is to build a Discrete Event Simulation model of the following GP surgery.\nPatients:\nAround a quarter of patients need to book a test at reception after they’ve seen the GP, and this takes around 4 minutes.\nIn addition to registering patients and booking tests, receptionists also answer incoming calls, which come in around every 10 minutes and last about 4 minutes.\nThe surgery currently has 1 receptionist and 2 GPs. They feel there is a problem in their system as they are receiving complaints about lengthy delays both from patients and callers. They want you to build a simulation model to find out what’s happening and propose some solutions.\nYour model should represent a “day in the life” of the surgery, which is open to both in-person patients and telephone callers for 8 hours continuously.\nYour trial should be at least 100 runs of the simulation.\nThe surgery is only interested in queuing times for each of the queues in the system (you don’t need to worry about storing sampled activity times for example), but they would like to look at the results for patients and callers separately. You should give them mean results as a minimum, but you may consider providing additional results too.\nYou also need to calculate and provide them with the mean queuing times across the trial (eg mean queue for registration across all runs, for GP etc - so four numbers that you would report). You’ll need a new method in your Trial class to calculate this. You should find this a helpful output, as it’ll help you compare scenarios easily. Report these means to 1 decimal place.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exercise - Building Your First Model</span>"
    ]
  },
  {
    "objectID": "exercise_gp.html#goal",
    "href": "exercise_gp.html#goal",
    "title": "8  Exercise - Building Your First Model",
    "section": "8.2 Goal",
    "text": "8.2 Goal\nOnce you’ve built the model, use it to:\n\nIdentify where you think the problem is\nProvide proposals for how you would fix it (this can include anything you like - they are open to suggestions - more resources, changes to processes to cut activity times, having the GP book the test, anything you can think of!\n\nTry different things, different solutions.\n\n\n\n\n\n\nTip\n\n\n\nTake a copy of the original working file for the base case scenario first :)",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exercise - Building Your First Model</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html",
    "href": "model_warm_up.html",
    "title": "9  Warm Up Periods",
    "section": "",
    "text": "9.1 How long should a warm-up period be?\nIn the models we’ve created so far patients start coming in when the service opens, and then all leave when it closes.\nBut what if our system isn’t like that? What if we have a system that is never empty - like an Emergency Department?\nBy default, a DES model assumes that our system is empty at the start of a simulation run. But if we were modelling an ED, that would skew (throw off) our results, as the initial period during which patients were coming in to an empty system wouldn’t represent what’s happening in the real world - known as the Initialisation Bias.\nThe solution to this in DES modelling is to use a Warm Up Period.\nThe idea of a warm up period is simple. We run the model as normal - from empty - but for a period of time (the warm up period) we don’t collect results.\nThe model continues to run as normal, it’s just we don’t count what’s happening.\nThe length of the warm up period is up to you as the modeller to define.\nYou could be very precise about analysing it and use statistical testing to identify when the system reaches equilibrium (see https://eudl.eu/pdf/10.4108/ICST.SIMUTOOLS2009.5603 as an example).\nOr you could plot what’s happening over time by eye and make an estimate.\nOr you could just set your warm up period long enough that it’ll be representative when it starts collecting results.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html#implementing-the-warm-up-period",
    "href": "model_warm_up.html#implementing-the-warm-up-period",
    "title": "9  Warm Up Periods",
    "section": "9.2 Implementing the warm-up period",
    "text": "9.2 Implementing the warm-up period\nImplementing a warm up period in SimPy is really easy.\nWe just simply check the current time whenever we go to calculate / store a result, and see if it’s beyond the warm up period. If it is, we do it. If it’s not, we don’t.\nLet’s look at an example. This is a slightly amended version of the model of patients coming in for a nurse consultation with a few tweaks (longer duration, more runs, added trial results calculation)\nWe’re going to assume this is a system that’s open 24 hours - let’s imagine this is a triage function at an emergency department.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html#coding-the-model",
    "href": "model_warm_up.html#coding-the-model",
    "title": "9  Warm Up Periods",
    "section": "9.3 Coding the model",
    "text": "9.3 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n9.3.1 The g class\nFirst we add in a new parameter - the length of the warm-up period.\nHere, the sim duration has been set to 2880, and the warm-up-period to half of this (1440). You don’t need to stick to this pattern - your warm-up could even be longer than your results collection if you want!\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    warm_up_period = 1440 ##NEW - this will be in addition to the sim_duration\n    number_of_runs = 100\n\n\n\n\n\n\n\nTip\n\n\n\nIf you find it easier to keep track of, you could define your warm-up like this instead.\n\nresults_collection_period = 2880\nwarm_up_period = 1440\ntotal_sim_duration = results_collection_period + warm_up_period\n\n\n\n\n\n9.3.2 The patient class\nOur patient class is unchanged.\n\n\n9.3.3 The model class\nIn the model class, the ‘attend_clinic’ method changes.\nWe look at the current elapsed simulation time with the attribute self.env.now\nThen, whenever a patient attends the clinic and is using a nurse resource, we check whether the current simulation time is later than the number of time units we’ve set as our warm-up.\n\n9.3.3.1 The attend_clinic method\n\n# Generator function representing pathway for patients attending the\n# clinic.\ndef attend_clinic(self, patient):\n    # Nurse consultation activity\n    start_q_nurse = self.env.now\n\n    with self.nurse.request() as req:\n        yield req\n\n        end_q_nurse = self.env.now\n\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        ##NEW - this checks whether the warm up period has passed before\n        # adding any results\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse\n            )\n\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        yield self.env.timeout(sampled_nurse_act_time)\n\nFor example, if the simulation time is at 840 and our warm_up is 1440, this bit of code - which adds the queuing time for this patient to our records - won’t run:\n\nself.results_df.at[patient.id, \"Q Time Nurse\"] = (\n    patient.q_time_nurse\n)\n\nHowever, if the simulation time is 1680, for example, it will.\n\n\n9.3.3.2 The calculate_run_results method\nAs we now won’t count the first patient, we need to remove the dummy first patient result entry we created when we set up the dataframe.\n\n# Method to calculate and store results over the run\ndef calculate_run_results(self):\n    self.results_df.drop([1], inplace=True) ##NEW\n\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n\n\n9.3.3.3 The run method\nNext we need to tweak the duration of our model to reflect the combination of the period we want to collect results for and the warm-up period.\n\n# Method to run a single run of the simulation\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    ##NEW - we need to tell the simulation to run for the specified duration\n    # + the warm up period if we still want the specified duration in full\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Print patient level results for this run\n    print (f\"Run Number {self.run_number}\")\n    print (self.results_df)\n\n\n\n\n9.3.4 The trial class\nOur trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html#the-impact-of-the-warm-up-period",
    "href": "model_warm_up.html#the-impact-of-the-warm-up-period",
    "title": "9  Warm Up Periods",
    "section": "9.4 The impact of the warm-up period",
    "text": "9.4 The impact of the warm-up period\nLet’s compare the results we get with and without the warm-up period.\n\n9.4.1 Editing our results method\nTo make it easier to look at the outputs, I’m going to modify two methods slightly.\nFirst, we modify the run method of the Model class slightly to swap from print the patient level dataframes to returning them as an output.\n\n# Method to run a single run of the simulation\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    # We need to tell the simulation to run for the specified duration\n    # + the warm up period if we still want the specified duration in full\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Return patient level results for this run\n    return (self.results_df) ##NEW\n\nNext, we modify the run_trial method of the Trial class so that we get multiple outputs: the full patient level dataframes, a summary of results per trial, and an overall average figure for all of the trials.\n\n# Method to run a trial\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results and store it against\n    # the run number in the trial results dataframe. We also return the\n    # full patient-level dataframes.\n\n    # First, create an empty list for storing our patient-level dataframes.\n    results_dfs = []\n\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        patient_level_results = my_model.run()\n\n        print( self.df_trial_results)\n        # First let's record our mean wait time for this run\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Next let's work on our patient-level results dataframes\n        # We start by rounding everything to 2 decimal places\n        patient_level_results = patient_level_results.round(2)\n        # Add a new column recording the run\n        patient_level_results['run'] = run\n        # Now we're just going to add this to our empty list (or, after the first\n        # time we loop through, as an extra dataframe in our list)\n        results_dfs.append(patient_level_results)\n\n    all_results_patient_level = pd.concat(results_dfs)\n\n    # This calculates the attribute self.mean_q_time_nurse_trial\n    self.calculate_means_over_trial()\n\n    # Once the trial (ie all runs) has completed, return the results\n    return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n\n\n9.4.2 The full updated code\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 20\n    warm_up_period = 1440 ##NEW - this will be in addition to the sim_duration\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request() as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            ##NEW - this checks whether the warm up period has passed before\n            # adding any results\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        ##NEW - as we now won't count the first patient, we need to remove\n        # the dummy first patient result entry we created when we set up the\n        # dataframe\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        ##NEW - we need to tell the simulation to run for the specified duration\n        # + the warm up period if we still want the specified duration in full\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Return patient level results for this run\n        return (self.results_df)\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            print( self.df_trial_results)\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        # EDIT: We are omitting the printouts of the patient level data for now\n        # print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\ndf_trial_results_warmup, all_results_patient_level_warmup, means_over_trial_warmup = my_trial.run_trial()\n\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n14                 364.831108\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n14                 364.831108\n15                 536.169935\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n14                 364.831108\n15                 536.169935\n16                 325.580491\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n14                 364.831108\n15                 536.169935\n16                 325.580491\n17                 890.902108\n            Mean Q Time Nurse\nRun Number                   \n0                  182.792322\n1                  508.561548\n2                  769.603539\n3                  853.199673\n4                  482.289648\n5                  681.686391\n6                  576.518287\n7                  768.166716\n8                  379.533642\n9                  735.583284\n10                 577.048562\n11                 494.124387\n12                 429.016676\n13                 515.492910\n14                 364.831108\n15                 536.169935\n16                 325.580491\n17                 890.902108\n18                 446.904203\n\n\n\n\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n14                 328.847411\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n14                 328.847411\n15                 373.458309\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n14                 328.847411\n15                 373.458309\n16                 398.752813\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n14                 328.847411\n15                 373.458309\n16                 398.752813\n17                 368.380480\n            Mean Q Time Nurse\nRun Number                   \n0                  187.772337\n1                  420.603395\n2                  400.113768\n3                  589.947551\n4                  404.975477\n5                  420.243730\n6                  339.488885\n7                  487.760530\n8                  408.545050\n9                  437.072707\n10                 389.335518\n11                 346.229741\n12                 204.571764\n13                 455.625014\n14                 328.847411\n15                 373.458309\n16                 398.752813\n17                 368.380480\n18                 337.084612\n\n\n\n\n9.4.3 Comparing the results\n\n9.4.3.1 Patient-level dataframes\nFirst, let’s look at the first five rows of our patient dataframes.\nWithout the warm-up, our patient IDs start at 1.\n\n9.4.3.1.1 Without warm-up\n\nall_results_patient_level.head()\n\n\n\n\n\n\n\n\nQ Time Nurse\nTime with Nurse\nrun\n\n\nPatient ID\n\n\n\n\n\n\n\n1\n0.00\n2.20\n0\n\n\n2\n0.00\n7.98\n0\n\n\n3\n7.54\n2.07\n0\n\n\n4\n5.11\n2.68\n0\n\n\n5\n0.00\n16.49\n0\n\n\n\n\n\n\n\n\n\n9.4.3.1.2 With warm-up\nWith the warm-up, our patient IDs start later.\n\nall_results_patient_level_warmup.head()\n\n\n\n\n\n\n\n\nQ Time Nurse\nrun\n\n\nPatient ID\n\n\n\n\n\n\n256\n156.20\n0\n\n\n257\n142.01\n0\n\n\n258\n138.70\n0\n\n\n259\n139.52\n0\n\n\n260\n132.92\n0\n\n\n\n\n\n\n\n\n\n\n9.4.3.2 Per-run results\n\n9.4.3.2.1 Without warm-up\n\ndf_trial_results.round(2).head()\n\n\n\n\n\n\n\n\nMean Q Time Nurse\n\n\nRun Number\n\n\n\n\n\n0\n187.77\n\n\n1\n420.60\n\n\n2\n400.11\n\n\n3\n589.95\n\n\n4\n404.98\n\n\n\n\n\n\n\n\n\n9.4.3.2.2 With warm-up\nWith the warm-up, our patient IDs start later.\n\ndf_trial_results_warmup.round(2).head()\n\n\n\n\n\n\n\n\nMean Q Time Nurse\n\n\nRun Number\n\n\n\n\n\n0\n182.79\n\n\n1\n508.56\n\n\n2\n769.60\n\n\n3\n853.20\n\n\n4\n482.29\n\n\n\n\n\n\n\n\n\n\n9.4.3.3 Overall results\nWithout the warm up, our overall average wait time is\n\n\n'377.27 minutes'\n\n\nWith the warm up, our overall average wait time is\n\n\n'545.91 minutes'\n\n\nYou can see overall that the warm-up time can have a very significant impact on our waiting times!\nLet’s look at this in a graph.\n\n\n9.4.3.4 Results over time\n\nimport plotly.express as px\n\ndf_trial_results = df_trial_results.reset_index()\ndf_trial_results['Warm Up'] = 'No Warm Up'\n\ndf_trial_results_warmup = df_trial_results_warmup.reset_index()\ndf_trial_results_warmup['Warm Up'] = 'With Warm Up'\n\nfig = px.histogram(\n    pd.concat([df_trial_results, df_trial_results_warmup]).round(2).reset_index(),\n    x=\"Warm Up\",\n    color=\"Run Number\", y=\"Mean Q Time Nurse\",\n    barmode='group',\n    title='Average Queue Times per Run - With and Without Warmups')\n\nfig.show()",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html",
    "href": "priority_based_queueing.html",
    "title": "10  Priority-Based Queueing",
    "section": "",
    "text": "10.1 Implementing priority-based queueing\nSo far, we’ve assumed that the queues in our models follow a FIFO (First in First Out) policy. This means that whoever has been queuing the longest is seen next.\nBut in healthcare systems, very often there is an element of prioritisation in a real world queue. Typically this represents the severity of the patient’s condition.\nWe can build in priority-based queuing in our SimPy models in a few different ways - but one of the easiest is using something known as a PriorityResource.\nA PriorityResource is a class in SimPy that’s like the standard Resource class we’ve used so far, but also has functionality that allows it to select which entity to pull out of a queue next based on a priority value we specify.\nThe way this works in SimPy is:",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#implementing-priority-based-queueing",
    "href": "priority_based_queueing.html#implementing-priority-based-queueing",
    "title": "10  Priority-Based Queueing",
    "section": "",
    "text": "We set up resources that will be dealing with priority-based queues as PriorityResources rather than Resources.\nWe have an attribute stored against the entity that specifies that entity’s priority (with lower values indicating higher priority).\nWhen we request a PriorityResource, we tell it the attribute to use to determine priority in that queue (this also means we could have multiple attributes for priority and use different ones for different queues).",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#coding-the-model",
    "href": "priority_based_queueing.html#coding-the-model",
    "title": "10  Priority-Based Queueing",
    "section": "10.2 Coding the model",
    "text": "10.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n10.2.1 g class\nThe g class is unchanged\n\n\n10.2.2 Patient class\nHere we add an attribute of the patient that determines their priority.\n\n\n\n\n\n\nTip\n\n\n\nWhen using a priority resource, lower value = higher priority.\n\n\nIn this example, we just randomly pick a value between 1 and 5, but you can use whatever logic you like.\nIn reality, you’d likely have probabilities to determine what priority a patient is based on your data - maybe there’s a 20% chance they are a high priority and an 80% chance they are a low priority.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        ##NEW\n        self.priority = random.randint(1,5)\n\n\n\n10.2.3 Model class\n\n10.2.3.1 _init\nHere we set up the nurse as an instance of PriorityResource rather than Resource\n\ndef __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        ##NEW\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Priority\"] = [1] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n\n\n10.2.3.2 attend_clinic\nNear the beginning of the attend_clinic() method, we have added a print message so we can see how priority works.\n\n\n\n\n\n\nTip\n\n\n\nLogging in this way can help you check that your model is behaving as expected.\n\n\nNow that the nurse is set up as a PriorityResource, we can pass in the value that we want it to look at to determine who’s seen next when we request the resource (here, that’s the priority attribute of the patient we set up in the Patient class).\nWe have also added a step that records the patient priority to our dataframe of individual patient results.\n\n# Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        ##NEW\n        print (f\"Patient {patient.id} with priority {patient.priority} is\",\n               \"queuing for the nurse.\")\n\n        ##NEW\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            ##NEW\n            print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                   f\"being seen at minute {self.env.now}.\")\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n                ##NEW\n                self.results_df.at[patient.id, \"Priority\"] = (\n                    patient.priority\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n\n\n\n10.2.4 Trial class\nThe trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#the-full-code",
    "href": "priority_based_queueing.html#the-full-code",
    "title": "10  Priority-Based Queueing",
    "section": "10.3 The full code",
    "text": "10.3 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - We've changed the parameters to have no warm-up\n    # Simulation meta parameters\n    sim_duration = 5000\n    number_of_runs = 1\n    warm_up_period = 0\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        ##NEW - here we add an attribute of the patient that determines their\n        # priority (lower value = higher priority).  In this example, we just\n        # randomly pick a value between 1 and 5, but you can use whatever logic\n        # you like (in reality, you'd likely have probabilities to determine\n        # what priority a patient is based on your data)\n        self.priority = random.randint(1,5)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        ##NEW - here we set up the nurse as an instance of PriorityResource\n        # rather than Resource\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Priority\"] = [1] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        ##NEW - added a print message so we can see how priority works\n        # I'm limiting it to the first 10 patients so we're not swamped by outputs!\n        if patient.id &lt;= 10:\n            print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                \"queuing for the nurse.\")\n\n        ##NEW - now that the nurse is set up as a PriorityResource, we can pass\n        # in the value that we want it to look at to determine who's seen next\n        # when we request the resource (here, that's the priority attribute of\n        # the patient we set up in the Patient class)\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            ##NEW - added a print message so we can see how priority works\n            # I'm limiting it to the first 10 patients so we're not swamped by outputs!\n            if patient.id &lt;= 10:\n                print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                    f\"being seen at minute {self.env.now}\")\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n                ##NEW\n                self.results_df.at[patient.id, \"Priority\"] = (\n                    patient.priority\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        return self.results_df\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            print( self.df_trial_results)\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\ndf_trial_results, all_results_patient_level, means_over_trial  = my_trial.run_trial()\n\nPatient 1 with priority 5 is queuing for the nurse.\nPatient 1 with priority 5 is being seen at minute 0\nPatient 2 with priority 5 is queuing for the nurse.\nPatient 2 with priority 5 is being seen at minute 3.9263852022788073\nPatient 3 with priority 4 is queuing for the nurse.\nPatient 3 with priority 4 is being seen at minute 13.925995845116113\nPatient 4 with priority 4 is queuing for the nurse.\nPatient 4 with priority 4 is being seen at minute 15.480365661058993\nPatient 5 with priority 3 is queuing for the nurse.\nPatient 5 with priority 3 is being seen at minute 25.069503418275517\nPatient 6 with priority 4 is queuing for the nurse.\nPatient 7 with priority 2 is queuing for the nurse.\nPatient 7 with priority 2 is being seen at minute 45.52189965104935\nPatient 8 with priority 1 is queuing for the nurse.\nPatient 9 with priority 2 is queuing for the nurse.\nPatient 8 with priority 1 is being seen at minute 51.02128671060248\nPatient 10 with priority 4 is queuing for the nurse.\nPatient 9 with priority 2 is being seen at minute 77.30834723191384\nPatient 6 with priority 4 is being seen at minute 80.7057025802554\nPatient 10 with priority 4 is being seen at minute 107.92058758766433\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#evaluating-the-outputs",
    "href": "priority_based_queueing.html#evaluating-the-outputs",
    "title": "10  Priority-Based Queueing",
    "section": "10.4 Evaluating the outputs",
    "text": "10.4 Evaluating the outputs\nFirst let’s look at some sample patients.\n\nall_results_patient_level.head()\n\n\n\n\n\n\n\n\nQ Time Nurse\nPriority\nrun\n\n\nPatient ID\n\n\n\n\n\n\n\n1\n0.0\n1.0\n0\n\n\n2\n0.0\n5.0\n0\n\n\n3\n0.0\n4.0\n0\n\n\n4\n1.3\n4.0\n0\n\n\n5\n0.0\n3.0\n0\n\n\n\n\n\n\n\nLet’s calculate the mean queue time by priority.\n\n(all_results_patient_level\n    .groupby('Priority')\n    .agg({'Priority':'size', 'Q Time Nurse':'mean'}) \\\n    .rename(columns={'Priority':'count','Q Time Nurse':'mean queue time'})\n    .round(2)\n    )\n\n\n\n\n\n\n\n\ncount\nmean queue time\n\n\nPriority\n\n\n\n\n\n\n1.0\n196\n10.89\n\n\n2.0\n175\n18.32\n\n\n3.0\n196\n34.00\n\n\n4.0\n173\n117.42\n\n\n5.0\n79\n1472.35\n\n\n\n\n\n\n\nWe can see that the queueing time is shorter for the clients with a lower priority value (and therefore a higher actual priority in terms of the model - i.e. they will be seen first).\n\n\n\n\n\n\nWarning\n\n\n\nRemember that we are only recording the queue time at the point at which someone exits the queue to be seen by a nurse.\nThis means that there may be lots of people - particularly those with a higher priority number (and therefore the least important to see as far as the model is concerned) who are still sitting waiting to be seen when our model stops running.\nThink about ways you might try to account for that.\n\n\n\nimport plotly.express as px\n\nfig = px.box(all_results_patient_level.reset_index(), x=\"Priority\", y=\"Q Time Nurse\", points=\"all\")\nfig.show()",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html",
    "href": "modelling_resource_unavailability.html",
    "title": "11  Modelling Resource Unavailability",
    "section": "",
    "text": "11.1 The approach\nSo far in our models, we’ve assumed that, outside of working on our modelled activities, our modelled resources are always available for the time we’re simulating. But that won’t always be the case in the real world.\nResources may not always be “on shift”, or may be called off to other areas of the system (e.g. different parts of a hospital). How we deal with this depends on the answer to the following question :\nWhen this happens, does another resource of the same type cover?\nIf yes, then it doesn’t matter to the model and we don’t need to change the model to reflect it. For example, in a ward there might always be 5 doctors available, even if who those doctors are changes.\nIf no, and the level of resource availability changes, then we can model this in SimPy by “obstructing” a resource for a certain amount of time.\nLet’s consider our nurse consultation model as an example. Let’s imagine that every 2 hours, our nurse has a 15 minute break.\nLet’s look at how we’d model that.\nBasically, we will:",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#the-approach",
    "href": "modelling_resource_unavailability.html#the-approach",
    "title": "11  Modelling Resource Unavailability",
    "section": "",
    "text": "Set up the frequency and duration of unavailability as parameter values in g class.\nMake sure that the nurse is set up as a PriorityResource.\nCreate a new entity generator whose sole purpose is to demand the nurse resource with a higher priority than any patient every 2 hours, and will freeze the nurse with them for 15 minutes (this means the nurse will complete the current patient, they won’t walk out midway through!).\nStart this new generator running in our run method of the Model class.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#coding-the-model",
    "href": "modelling_resource_unavailability.html#coding-the-model",
    "title": "11  Modelling Resource Unavailability",
    "section": "11.2 Coding the model",
    "text": "11.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n11.2.1 g class\nIn the g class, we have added values to specify how long nurse is unavailable and at what frequency.\nIn this example, every 2 hours, the nurse will be unavailable for 15 minutes.\n\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    unav_time_nurse = 15 ##NEW\n    unav_freq_nurse = 120 ##NEW\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n\n\n\n11.2.2 Patient class\nThe patient class is unchanged.\n\n\n11.2.3 Model class\n\n11.2.3.1 The obstruct_nurse method\nWe create a new method within the model class called obstruct_nurse.\n\n\n\n\n\n\nTip\n\n\n\nNote that here we are using a priority value of -1.\nNegative priorities are higher (i.e. are seen first) compared to higher priorities; a priority value of -1 will be seen before a priority value of 1, but a priority value of 1 will be seen before a priority value of 2.\nThis is a very helpful feature to use to keep your breaktime functions from clashing with high-priority patients.\n\n\n\n##NEW\n# Generator function to obstruct a nurse resource at specified intervals\n# for specified amounts of time\ndef obstruct_nurse(self):\n    while True:\n        print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n        # The generator first pauses for the frequency period\n        yield self.env.timeout(g.unav_freq_nurse)\n\n        # Once elapsed, the generator requests (demands?) a nurse with\n        # a priority of -1.  This ensure it takes priority over any patients\n        # (whose priority values start at 1).  But it also means that the\n        # nurse won't go on a break until they've finished with the current\n        # patient\n        with self.nurse.request(priority=-1) as req:\n            yield req\n\n            print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                    f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n            # Freeze with the nurse held in place for the unavailability\n            # time (ie duration of the nurse's break).  Here, both the\n            # duration and frequency are fixed, but you could randomly\n            # sample them from a distribution too if preferred.\n            yield self.env.timeout(g.unav_time_nurse)\n\n\n\n11.2.3.2 The run method\nIn our run method, we now start up the obstruct_nurse process in addition to the generator_patient_arrivals process.\n\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n    ##NEW - we also need to start up the obstructor generator now too\n    self.env.process(self.obstruct_nurse())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    return self.results_df\n\n\n\n\n11.2.4 Trial class\nThe trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#the-full-code",
    "href": "modelling_resource_unavailability.html#the-full-code",
    "title": "11  Modelling Resource Unavailability",
    "section": "11.3 The full code",
    "text": "11.3 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - added values to specify how long nurse is unavailable and at what\n    # frequency (in this example, every 2 hours, the nurse will be unavailable\n    # for 15 minutes)\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        random.seed(42)\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    ##NEW\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                   f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                       f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        ##NEW - we also need to start up the obstructor generator now too\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        return self.results_df\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#evaluating-the-outputs",
    "href": "modelling_resource_unavailability.html#evaluating-the-outputs",
    "title": "11  Modelling Resource Unavailability",
    "section": "11.4 Evaluating the outputs",
    "text": "11.4 Evaluating the outputs\nLet’s look at the printed output showing when our nurses were obstructed.\nThe first number in each line of output shows the simulation time when the message was generated.\n\n\n0.00: The nurse will go on a break at around time 120.00\n120.15: The nurse is now on a break and will be back at 135.15\n135.15: The nurse will go on a break at around time 255.15\n258.44: The nurse is now on a break and will be back at 273.44\n273.44: The nurse will go on a break at around time 393.44\n404.26: The nurse is now on a break and will be back at 419.26\n419.26: The nurse will go on a break at around time 539.26\n540.82: The nurse is now on a break and will be back at 555.82\n555.82: The nurse will go on a break at around time 675.82\n680.63: The nurse is now on a break and will be back at 695.63\n695.63: The nurse will go on a break at around time 815.63\n827.06: The nurse is now on a break and will be back at 842.06\n842.06: The nurse will go on a break at around time 962.06\n968.91: The nurse is now on a break and will be back at 983.91\n983.91: The nurse will go on a break at around time 1103.91\n1106.20: The nurse is now on a break and will be back at 1121.20\n1121.20: The nurse will go on a break at around time 1241.20\n1242.30: The nurse is now on a break and will be back at 1257.30\n1257.30: The nurse will go on a break at around time 1377.30\n1389.51: The nurse is now on a break and will be back at 1404.51\n1404.51: The nurse will go on a break at around time 1524.51\n1532.18: The nurse is now on a break and will be back at 1547.18\n1547.18: The nurse will go on a break at around time 1667.18\n1672.09: The nurse is now on a break and will be back at 1687.09\n1687.09: The nurse will go on a break at around time 1807.09\n1807.86: The nurse is now on a break and will be back at 1822.86\n1822.86: The nurse will go on a break at around time 1942.86\n1947.64: The nurse is now on a break and will be back at 1962.64\n1962.64: The nurse will go on a break at around time 2082.64\n2084.27: The nurse is now on a break and will be back at 2099.27\n2099.27: The nurse will go on a break at around time 2219.27\n2221.93: The nurse is now on a break and will be back at 2236.93\n2236.93: The nurse will go on a break at around time 2356.93\n2359.05: The nurse is now on a break and will be back at 2374.05\n2374.05: The nurse will go on a break at around time 2494.05\n2494.42: The nurse is now on a break and will be back at 2509.42\n2509.42: The nurse will go on a break at around time 2629.42\n2635.29: The nurse is now on a break and will be back at 2650.29\n2650.29: The nurse will go on a break at around time 2770.29\n2776.28: The nurse is now on a break and will be back at 2791.28\n2791.28: The nurse will go on a break at around time 2911.28\n2911.72: The nurse is now on a break and will be back at 2926.72\n2926.72: The nurse will go on a break at around time 3046.72\n3050.18: The nurse is now on a break and will be back at 3065.18\n3065.18: The nurse will go on a break at around time 3185.18\n3203.13: The nurse is now on a break and will be back at 3218.13\n3218.13: The nurse will go on a break at around time 3338.13\n3350.63: The nurse is now on a break and will be back at 3365.63\n3365.63: The nurse will go on a break at around time 3485.63\n3486.03: The nurse is now on a break and will be back at 3501.03\n3501.03: The nurse will go on a break at around time 3621.03\n3623.49: The nurse is now on a break and will be back at 3638.49\n3638.49: The nurse will go on a break at around time 3758.49\n3768.95: The nurse is now on a break and will be back at 3783.95\n3783.95: The nurse will go on a break at around time 3903.95\n3908.67: The nurse is now on a break and will be back at 3923.67\n3923.67: The nurse will go on a break at around time 4043.67\n4045.96: The nurse is now on a break and will be back at 4060.96\n4060.96: The nurse will go on a break at around time 4180.96\n4184.07: The nurse is now on a break and will be back at 4199.07\n4199.07: The nurse will go on a break at around time 4319.07\n\n\nNow let’s look at some of the other outputs and compare them with a version without the nurse obstruction.\nNow let’s look at some of the other outputs and compare them with a version without the nurse obstruction.\n\n\nThe average wait when there are no nurse breaks is 143.18 minutes\n\n\n\n\nThe average wait when there are nurse breaks is 299.7 minutes",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html",
    "href": "choosing_distributions.html",
    "title": "12  Using Different Distributions for Different Processes",
    "section": "",
    "text": "12.1 A bit of background\nIn the previous session, we mentioned that whilst it’s a useful tip to start by having all of the distributions in our model be Exponential (because it’s easy to tweak an Exponential Distribution), for real world models we probably want to then adapt them to use a Lognormal Distribution for activity times.\nA Lognormal Distribution is commonly used in Discrete Event simulation to model the time to perform a task. It is right-skewed, which basically means it has a long tail. To put it in more understandable terms, it suggests that most activity times will be similar, but some will be longer, and some will be MUCH longer. This tends to capture activity times in patient pathways well.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Using Different Distributions for Different Processes</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#a-bit-of-background",
    "href": "choosing_distributions.html#a-bit-of-background",
    "title": "12  Using Different Distributions for Different Processes",
    "section": "",
    "text": "Tip\n\n\n\nThe good news is that we will be using some prewritten code to specify our lognormal, and all we will need to know to do this is the mean (average) time for our activity, and the standard deviation (a measure of how much the times vary across the dataset that python can calculate for us if given a list of activity times).\nHowever - it’s useful to have a bit more of an idea about what a lognormal is - so do have a read of the section below, but if you don’t quite get it just yet, don’t fret - just remember that lognormal is good for activity times in general, and the exponential distribution is good for inter-arrival times (the time between patients arriving).\n\n\n\n12.1.1 The normal distribution\nA normal distribution is a bell shaped curve that is symmetrical. It is defined by two parameters : μ (Mu) and σ (Sigma), which represent the mean and standard deviation of the distribution. So it’s easy to plug in such values from our own data.\n\n\n\n12.1.2 Logarithms\nBefore we proceed, let’s remind ourselves about something many of us learned at school (and then promptly forgot) : Logarithms.\nLogarithms are basically the opposite of exponentials.\nEffectively, lognormals relate to how many copies of one number multiply together to make another number.\nHow many 4s multiply together to make 64?\n4 x 4 x 4 = 64\nWe had to multiply 3 copies of the number 4 to get 64.\nThis means that the logarithm is 3.\nWe’d write this as \\[\nY = log_4(64) = 3\n\\]\n\n\n12.1.3 Bringing it all together - lognormal distributions\nHow does this relate to the distribution?\nWell, a Lognormal distribution is one in which the logarithm of the random variable we’re modelling is normally distributed.\nThis means that the the two parameters μ (Mu) and σ (Sigma) used to specify a Lognormal distribution do not represent the mean and standard deviation, unlike the normal distribution; rather, they represent what are known as the location and scale of the distribution respectively.\n\n\n\n\n\n\nNote\n\n\n\nμ (Mu) and σ (Sigma) represent the mean and standard deviation once the data in the log normal distribution has been transformed using logarithms.\n\n\nIt’s easy to get the mean and standard deviation of our data.\nIf we used the Normal distribution, we could do that.\n\n\n\n\n\n\nWarning\n\n\n\nThe Normal distribution often isn’t good for activity times - it allows negative values - activity distributions are rarely symmetrical - they’re more likely to be a bit ‘wonky’ (skewed), with just a few activities being much longer\n\n\nThe probalm is we can’t just give a Lognormal distribution the mean and standard deviation, because in a Lognormal distribution, the mean and standard deviation of our data is represented in the underlying normal distribution not the Lognormal distribution (remember, it’s the logarithms of the values that are normally distributed).\n\n\n\n\n\n\nTip\n\n\n\nSo what do we do?\nWe need to convert our mean and standard deviation values (that we get from our real world data) into Mu and Sigma for a Lognormal distribution.\nThis is the key bit you need to understand!",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Using Different Distributions for Different Processes</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#code-for-the-lognormal-distribution",
    "href": "choosing_distributions.html#code-for-the-lognormal-distribution",
    "title": "12  Using Different Distributions for Different Processes",
    "section": "12.2 Code for the lognormal distribution",
    "text": "12.2 Code for the lognormal distribution\nThis code was written by Tom Monks .\n\nimport numpy as np\nimport math\n\nclass Lognormal:\n    \"\"\"\n    Encapsulates a lognormal distirbution\n    \"\"\"\n    def __init__(self, mean, stdev, random_seed=None):\n        \"\"\"\n        Params:\n        -------\n        mean = mean of the lognormal distribution\n        stdev = standard dev of the lognormal distribution\n        \"\"\"\n        self.rand = np.random.default_rng(seed=random_seed)\n        mu, sigma = self.normal_moments_from_lognormal(mean, stdev**2)\n        self.mu = mu\n        self.sigma = sigma\n\n    def normal_moments_from_lognormal(self, m, v):\n        '''\n        Returns mu and sigma of normal distribution\n        underlying a lognormal with mean m and variance v\n        source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal\n        -data-with-specified-mean-and-variance.html\n\n        Params:\n        -------\n        m = mean of lognormal distribution\n        v = variance of lognormal distribution\n\n        Returns:\n        -------\n        (float, float)\n        '''\n        phi = math.sqrt(v + m**2)\n        mu = math.log(m**2/phi)\n        sigma = math.sqrt(math.log(phi**2/m**2))\n        return mu, sigma\n\n    def sample(self):\n        \"\"\"\n        Sample from the normal distribution\n        \"\"\"\n        return self.rand.lognormal(self.mu, self.sigma)\n\nWe will add this into our model code.\nThen we just need to make sure we have both a mean and standard deviation (SD) for activity times that we want to represent on Lognormal distributions\nWhen we need to sample an activity time, we create an instance of the Lognormal class with our mean and SD, and call the sample method.\nWe are going to do this in the attend_clinic method of the Model class.\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\ndef attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            ##NEW - we now use a lognormal distribution for the activity time,\n            # so we create an instance of our Lognormal class with the mean\n            # and standard deviations specified in g class, and then sample\n            # from it (we do this in a single line of code here, much as we\n            # did when sampling from the exponential distribution before).\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Using Different Distributions for Different Processes</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#additional-distributions",
    "href": "choosing_distributions.html#additional-distributions",
    "title": "12  Using Different Distributions for Different Processes",
    "section": "12.3 Additional distributions",
    "text": "12.3 Additional distributions\nIn fact, there are many different distributions available.\nThe sim-tools package makes it easy to make use of them without having to write lots of classes yourself.\nThe source code for the package can be investigated in its Github Repository.\nTo install the package, run\n\npip install sim-tools\n\nYou can then import a class with\n\nfrom sim_tools.distributions import Exponential\n\nreplacing Exponential with any of the supported distribution classes.\nAn overview of how to use the classes, and of the different distributions included, is embedded below:",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Using Different Distributions for Different Processes</span>"
    ]
  },
  {
    "objectID": "getting_the_distribution_from_real_world_data.html",
    "href": "getting_the_distribution_from_real_world_data.html",
    "title": "13  The fitter package",
    "section": "",
    "text": "13.0.1 A quick fitter demo\nGoing beyond using some standard distributions that tend to fit certain things well, such as\nand using the relevant averages (and, where relevant, spread metrics) from our real-world data to parameterise them, we can go a step further and look to use a distribution with a different shape that reflects our real-world data even more exactly.\nWe will make use of the fitter package in this section.\nIf you do not already have fitter, run\nFitter provides helper functions to find the most appropriate distribution for your real-world data, and then return the distribution and all relevant parameters.\nLet’s start with a sample csv of historical activity times.\nHere, we have a dataframe with the historical duration of a particular step of a process - the duration of a nurse appointment.\nimport pandas as pd\n\ndf = pd.read_csv(\"resources/MINORS_examination_duration.csv\")\n\ndf.head()\n\n\n\n\n\n\n\n\nP_ID\nduration\n\n\n\n\n0\n1_0\n16.217771\n\n\n1\n1_1\n16.527785\n\n\n2\n1_2\n13.318456\n\n\n3\n1_3\n16.115894\n\n\n4\n1_4\n15.033374\nLet’s visualise it to begin with.\nimport plotly.express as px\n\npx.histogram(df[\"duration\"].round(1))\nThis looks like it might be a normal distribution - a bell-shaped curve with roughly equal tails either side. But what parameters do we need? And is it definitely a normal?",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The fitter package</span>"
    ]
  },
  {
    "objectID": "getting_the_distribution_from_real_world_data.html#fitting-with-fitter",
    "href": "getting_the_distribution_from_real_world_data.html#fitting-with-fitter",
    "title": "13  The fitter package",
    "section": "13.1 Fitting with fitter",
    "text": "13.1 Fitting with fitter\n\nfrom fitter import Fitter\n\nf = Fitter(df[\"duration\"], distributions=distributions_to_scan, timeout=60)\n\nf.fit()\n\nThe summary method gives us an output showing several possible distributions and how well they fit.\nHere, gamma, erlang, lognorm, pearson3 and norm all appear to approximate this data very well - with a gamma distribution being the best fit, though there is very little in it.\n\nnurse_appt_duration_fit = f.summary()\n\nnurse_appt_duration_fit\n\n\n\n\n\n\n\n\nsumsquare_error\naic\nbic\nkl_div\nks_statistic\nks_pvalue\n\n\n\n\ngamma\n0.003110\n854.790795\n875.703235\ninf\n0.004345\n0.998265\n\n\nerlang\n0.003110\n854.792833\n875.705273\ninf\n0.004342\n0.998284\n\n\nlognorm\n0.003110\n854.803534\n875.715974\ninf\n0.004365\n0.998137\n\n\npearson3\n0.003110\n854.790946\n875.703386\ninf\n0.004371\n0.998098\n\n\nnorm\n0.003112\n853.003887\n866.945513\ninf\n0.004655\n0.995350\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nEach of these columns is a measure of the fit, with some of the measures also penalising overly complex distributions.\nSmaller = better: sumsquare_error, aic, bic, ks_statistic\nLarger = better: ks_pvalue\n\n\nLet’s now just pull out the details of the best fitting distribution.\nThis returns a dictionary containing the parameter values we need to be able to set up the distribution using one of the python libraries for distributions.\n\nnurse_appt_duration_fit = f.get_best()\n\nnurse_appt_duration_fit\n\n{'gamma': {'a': 148119.25230778163,\n  'loc': -642.781546778717,\n  'scale': 0.004447598384144486}}",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The fitter package</span>"
    ]
  },
  {
    "objectID": "getting_the_distribution_from_real_world_data.html#setting-up-a-distribution",
    "href": "getting_the_distribution_from_real_world_data.html#setting-up-a-distribution",
    "title": "13  The fitter package",
    "section": "13.2 Setting up a distribution",
    "text": "13.2 Setting up a distribution\nWe can then use these parmeters to set up and sample from a gamma distribution.\n\n13.2.1 scipy\nThe random library doesn’t actually have a gamma distribution!\nrandom also has limitations when it comes to making your simulations reproducible and reducing variance across runs when comparing scenario - which are things we will talk about more in a later chapter on reproducibility.\nFor these reasons, instead of using the random package, we will instead use scipy’s distributions.\n\nfrom scipy.stats import gamma\n\n# Example: generate one random sample\nsample = gamma.rvs(\n  a=nurse_appt_duration_fit['gamma'][\"a\"],\n  loc=nurse_appt_duration_fit['gamma'][\"loc\"],\n  scale=nurse_appt_duration_fit['gamma'][\"scale\"]\n  )\n\nsample\n\n13.783045187528614\n\n\nAlternatively we can write something like this:\n\ndef gamma_duration():\n    return gamma.rvs(\n        a=nurse_appt_duration_fit['gamma'][\"a\"],\n        loc=nurse_appt_duration_fit['gamma'][\"loc\"],\n        scale=nurse_appt_duration_fit['gamma'][\"scale\"]\n        )\n\nThen, each time we need a duration, we just run:\n\ngamma_duration()\n\n18.27170203506421\n\n\n\n\n13.2.2 simtools\nInstead, you could consider using the sim-tools package, which has several additional helpers for managing distributions and randomness.\nYou can find more out about sim-tools here.\nTo use sim-tools, you will first need to run\npip install sim-tools\n\n\n\n\n\n\nWarning\n\n\n\nNote that there’s a hyphen in the package name, but we must use an underscore instead when importing it!\n\n\n\nfrom sim_tools.distributions import Gamma\n\n# Define a distribution\nmy_gamma = Gamma(\n  alpha=nurse_appt_duration_fit['gamma'][\"a\"],\n  location=nurse_appt_duration_fit['gamma'][\"loc\"],\n  beta=nurse_appt_duration_fit['gamma'][\"scale\"], # Note that sim-tools calls the the 'scale' parameter 'beta'\n  random_seed=42\n  )\n\n# Get a random sample\nsample = my_gamma.sample()\n\nsample\n\n16.513643626815565\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn a full simulation, we may set up the distribution for each activity time, inter-arrival time, and other decision points in the __init__ method of our Model class.\nEach time we need to sample, we can then just call the .sample() method - and because of the setup of the random seed, we will get reproducible results.\nThat’s the gist of it - we cover this in more detail in the reproducibility chapter, or you can look at the DistributionRegistry class in SimTools for an even more robust way of managing this.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The fitter package</span>"
    ]
  },
  {
    "objectID": "getting_the_distribution_from_real_world_data.html#a-quick-demo-that-this-works",
    "href": "getting_the_distribution_from_real_world_data.html#a-quick-demo-that-this-works",
    "title": "13  The fitter package",
    "section": "13.3 A quick demo that this works!",
    "text": "13.3 A quick demo that this works!\nLet’s prove all three produce something similar!\n\n# Generate samples from each method\n# We'll use len(df[\"duration\"]) to generate as many samples as we have in our real (historical) dataset\nsamples_scipy = [gamma_duration() for _ in range(len(df[\"duration\"]))]\nsamples_simtools = [my_gamma.sample() for _ in range(len(df[\"duration\"]))]\n\n\n\nShow the code\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\n# Real data histogram\nfig.add_trace(go.Histogram(\n    x=df[\"duration\"], # Our 'real' data\n    nbinsx=50,\n    name='Historical Data',\n    opacity=0.3,\n    marker_color='green'\n))\n\n# Scipy samples histogram\nfig.add_trace(go.Histogram(\n    x=samples_scipy,\n    nbinsx=50,\n    name='scipy.stats.gamma Samples',\n    opacity=0.3,\n    marker_color='blue'\n))\n\n# sim_tools samples histogram\nfig.add_trace(go.Histogram(\n    x=samples_simtools,\n    nbinsx=50,\n    name='sim_tools Gamma Samples',\n    opacity=0.3,\n    marker_color='red'\n))\n\n# Overlay histograms\nfig.update_layout(\n    barmode='overlay',\n    title_text='Comparison of Sample Distributions',\n    xaxis_title_text='Duration',\n    yaxis_title_text='Count',\n    legend_title_text='Data Source'\n)\n\nfig.show()\n\n\n                                                \n\n\n\n\nShow the code\nfrom scipy.stats import gaussian_kde\nimport numpy as np\n\n# --- Create density estimations ---\n# Use scipy's gaussian_kde for smooth density curves\nreal_data = df[\"duration\"].copy()\n\nkde_real = gaussian_kde(real_data)\nkde_scipy = gaussian_kde(samples_scipy)\nkde_simtools = gaussian_kde(samples_simtools)\n\n# Define a common x-axis range (based on min/max of all data)\nxmin = min(real_data.min(), min(samples_scipy), min(samples_simtools))\nxmax = max(real_data.max(), max(samples_scipy), max(samples_simtools))\nx_values = np.linspace(xmin, xmax, 500)\n\n# --- Create plot ---\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=x_values,\n    y=kde_real(x_values),\n    mode='lines',\n    name='Historical Data',\n    line=dict(color='green')\n))\n\nfig.add_trace(go.Scatter(\n    x=x_values,\n    y=kde_scipy(x_values),\n    mode='lines',\n    name='scipy.stats.gamma Samples',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=x_values,\n    y=kde_simtools(x_values),\n    mode='lines',\n    name='sim_tools Gamma Samples',\n    line=dict(color='red')\n))\n\n# Layout\nfig.update_layout(\n    title='Density Plot Comparison of Real and Simulated Data',\n    xaxis_title='Duration',\n    yaxis_title='Density',\n    legend_title_text='Source'\n)\n\nfig.show()",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The fitter package</span>"
    ]
  },
  {
    "objectID": "getting_the_distribution_from_real_world_data.html#summary",
    "href": "getting_the_distribution_from_real_world_data.html#summary",
    "title": "13  The fitter package",
    "section": "13.4 Summary",
    "text": "13.4 Summary\nHere we’ve demonstrated some libraries that can help make sure your simulation’s distributions accurately reflect real-world data.\nYou could now try repeating this process for every different activity time in your data, as well as things such as inter-arrival times - and see how much difference it makes compared to using the Exponential and Lognormal distributions we’ve used so far in the book.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>The fitter package</span>"
    ]
  },
  {
    "objectID": "reproducibility.html",
    "href": "reproducibility.html",
    "title": "14  Reproducibility",
    "section": "",
    "text": "14.1 Exploring ways of coding in reproducibility\nOne great thing about DES is controlled randomness.\nNow, computers aren’t very good at being completely random!\nWhat we do is give it a ‘seed’ to start from when we are sampling from a distribution..\nIf our seed is 1, maybe the arrival times sampled from the distribution will be\n5 minutes, 2 minutes, 3 minutes, 6 minutes, 5 minutes\nIf our seed is 101, maybe the arrival times will be\n10 minutes, 2 minutes, 5 minutes, 5 minutes, 3 minutes\nWhy is this good?\nWe can either:\nLet’s go back to our branching model.\nAt the moment, we have not set a seed anywhere explicitly.\nWhat the random package will do is default the seed to being the date and time that the code is run at - this helps to ensure the results are random, but this can then cause us some problems.\nWhen we do 100 runs, change the parameters (say add an extra nurse) and then do another 100 runs, we don’t currently know how much of the difference in results is due to the change in system (the extra nurse), and how much is due to random variation in the number and timing of arrivals, how long their consultations take, and the chance of them going on to the second consultation.\nSo let’s set a random seed so that we fix the patterns and arrivals.\nThe best place to do this is in our trial class.\nIn our run_trial method within that class, we can set the seed so that it matches the run number.\nThis will ensure each run has a different seed, but that the seed is the same across different runs.\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                          my_model.mean_q_time_nurse,\n                                          my_model.mean_q_time_doctor]\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.print_trial_results()\nLet’s look at the output now.\nLet’s run 100 trials and look at the outputs.\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nNow let’s run 100 trials again. Are the results the same?\nLet’s run 100 trials and look at the outputs.\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nYes!\nNow let’s compare this when we start changing the number of nurses.\nThis is going to change the queue times for nurses and, by extension, for doctors (as people will be turning up to the doctors at different times).\nHowever, the number of arrivals should remain unchanged.\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              106.0               0.96               0.78               52.59\n1               99.0               0.43               2.29               22.72\n2              116.0               2.96               2.84               93.46\n3              123.0               0.86               1.27               57.58\n4              114.0               2.40               3.53               68.42\n...              ...                ...                ...                 ...\n95             123.0               1.39               3.73               45.02\n96             138.0               0.97               1.95              102.04\n97             116.0               1.33               2.34               24.49\n98             125.0               1.07               1.59               40.84\n99             129.0               1.47               5.90               17.22\n\n[100 rows x 4 columns]\nArrivals              118.39\nMean Q Time Recep       1.23\nMean Q Time Nurse       2.98\nMean Q Time Doctor     53.23\ndtype: float64\nUnfortunately, what we wanted (and needed) to happen, hasn’t.\nInstead, we are seeing that the number of arrivals are changing too.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#exploring-ways-of-coding-in-reproducibility",
    "href": "reproducibility.html#exploring-ways-of-coding-in-reproducibility",
    "title": "14  Reproducibility",
    "section": "",
    "text": "Tip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe method shown in this section has limitations - but reading through this section will help you understand more about seeds and why the method in Section 14.2 (“A robust way to ensure controlled randomness”) is better.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis is because of the way random number generation occurs.\nThe order the random numbers are generated in matters - and as the order of events changes (in this case, as we have more nurses, they can see more patients quicker, changing the order that subsequent events happen in).\nLet’s investigate this with two examples.\n\nrandom.seed(42)\n\nprint(f\"1: inter-arrival time 1 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"3: inter-arrival time 2 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"2: reception consult time 1 {random.expovariate(1.0 / g.mean_reception_time):.2f}\")\nprint(f\"4: inter-arrival time 3 {random.expovariate(1.0 / g.patient_inter):.2f}\")\n\n1: inter-arrival time 1 5.10\n3: inter-arrival time 2 0.13\n2: reception consult time 1 0.64\n4: inter-arrival time 3 1.26\n\n\n\nrandom.seed(42)\n\nprint(f\"1: inter-arrival time 1 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"2: inter-arrival time 2 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"4: inter-arrival time 3 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"3: reception consult time  1 {random.expovariate(1.0 / g.mean_reception_time):.2f}\")\n\n1: inter-arrival time 1 5.10\n2: inter-arrival time 2 0.13\n4: inter-arrival time 3 1.61\n3: reception consult time  1 0.51\n\n\nWe can see that the first two inter-arrival times are consistent. However, when we swap the order of generating the next inter-arrival time and generating a length of time for someone to spend with a receptionist, we see that the times are different.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nSo while this method is ok just to ensure that a single output remains consistent when you rerun your analysis, it’s no good for ensuring you’re making good comparisons across different simulation scenarios.\nSo how can we do this?",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#sec-robust",
    "href": "reproducibility.html#sec-robust",
    "title": "14  Reproducibility",
    "section": "14.2 A robust way to ensure controlled randomness",
    "text": "14.2 A robust way to ensure controlled randomness\nEffectively, we want separate seeds for the random number generator for each separate type of event we are generating random numbers for.\nThis means that we have separate random number streams for the different parts of our process - our inter-arrival times - our consult times - our probabilities\nThe easiest way to implement this is to switch from using the random library to using the distributions provided in simtools.\nWe will replace random.expovariate with the Exponential class.\nFirst, we need to import this class.\n\nfrom sim_tools.distributions import Exponential\n\nWe now set up the distributions when initialising the model.\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        ##NEW - initialise distributions\n        self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(mean = g.mean_reception_time, random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(mean = g.mean_d_consult_time, random_seed = self.run_number*5)\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that the value we pass to initialise the Exponential variable here is just the mean time.\nWhen we were using random.expovariate, we passed 1 dividided by the mean time.\n\n\nNext, everywhere we have previously used random.expovariate, we replace this with the .sample() method of our newly initialised distributions.\nFor example\n\nsampled_doctor_act_time = random.expovariate(\n    1.0 / g.mean_d_consult_time\n)\n\nbecomes\n\nsampled_doctor_act_time = self.doctor_consult_time_dist.sample()\n\n\n14.2.1 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential ##NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(mean = g.mean_reception_time, random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(mean = g.mean_d_consult_time, random_seed = self.run_number*5)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample() ##NEW\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample() ##NEW\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = self.nurse_consult_time_dist.sample() ##NEW\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.nurse_consult_time_dist.sample() ##NEW\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        return (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ##NEW\n        print(\"\") ##NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n14.2.2 Evaluating the outputs\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00              57.19                1.15\n1              125.0               1.84             144.69                0.02\n2              112.0               0.85              15.30                1.13\n3              120.0               1.08              82.67                0.04\n4              132.0               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n95              91.0               0.35               9.08                0.15\n96             122.0               1.09              63.11                0.32\n97              97.0               0.58              21.86                0.10\n98             133.0               1.86             124.94                0.09\n99             122.0               0.57              63.14                0.66\n\n[100 rows x 4 columns]\nArrivals              122.39\nMean Q Time Recep       1.27\nMean Q Time Nurse      61.35\nMean Q Time Doctor      0.48\ndtype: float64\n\n\n\n\n1 receptionists, 2 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00               2.49                1.01\n1              125.0               1.84               3.55                1.56\n2              112.0               0.85               3.61                0.59\n3              120.0               1.08               3.43                0.19\n4              132.0               1.94               4.20                0.91\n...              ...                ...                ...                 ...\n95              91.0               0.35               1.08                0.07\n96             122.0               1.09               2.20                0.73\n97              97.0               0.58               1.09                1.04\n98             133.0               1.86               4.19                1.41\n99             122.0               0.57               1.86                0.85\n\n[100 rows x 4 columns]\nArrivals              122.39\nMean Q Time Recep       1.27\nMean Q Time Nurse       2.97\nMean Q Time Doctor      0.89\ndtype: float64\n\n\nWith these changes made, we can see that the number of arrivals and the queue time for the receptionists across the trials has remained consistent, while the waits for nurses and doctors have changed, but we can now be confident that this is because of alterations to the parameters - not uncontrolled randomness.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html",
    "href": "reneging_balking_jockeying.html",
    "title": "15  Reneging, Balking and Jockeying",
    "section": "",
    "text": "15.1 Reneging\nNot all queues run “as planned”. We may wish to model behaviours where entities stop waiting, switch queues, or never join the queue in the first place.\nReneging refers to an entity removing themselves from a queue after a certain amount of time has elapsed (eg person not willing to wait any longer, or test sample no longer being viable)\nBalking refers to an entity not entering a queue in the first place because of the length and / or capacity of the queue (eg person seeing long queue or no capacity in waiting room)\nJockeying refers to an entity switching queues in the hope of reducing queuing time. (eg switching till queues at the supermarket)\nLet’s imagine that each of our patients has a patience level - an amount of time they’re prepared to wait for the nurse.\nTo model this, we:",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, Balking and Jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#reneging",
    "href": "reneging_balking_jockeying.html#reneging",
    "title": "15  Reneging, Balking and Jockeying",
    "section": "",
    "text": "Add patience level as an attribute to each patient, with some way of determining what a patient’s patience is.\nWhen we request a resource, we’ll tell SimPy to either wait until the request can be met OR until the patient’s patience has expired (whichever comes first).\nWe’ll then check what happened - did the patient wait or did they renege? If they waited, we’ll proceed as before. If they reneged, then they won’t see the nurse, and we’ll record that they reneged.\nWe’ll add the number of patients that reneged to our outputs from each run, and take the average number of patients who reneged per run over the trial.\n\n\n15.1.1 Coding a reneging example\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n15.1.1.1 g class\nThe g class is unchanged.\n\n\n15.1.1.2 Patient class\nIn the patient class, we add a patience attribute.\nThis determines how long the patient is prepared to wait for the nurse.\nHere we just randomly sample an integer between 5 and 50 (so the patient will be prepared to wait for somewhere between 5 and 50 minutes in the queue), but in a real world application you would probably want to have a more refined way of allocating patience to patients (e.g basing probabilities off prior data, or using a non-uniform named distribution).\nYou could have different patience levels for different queues, or just a general patience level. Or even get creative and have a patience level that decreases the longer they’ve been in the system if your system has multiple steps!\nIf we want to see the effect of this, we can try changing the patience levels - but you’ll need to make the patience levels MUCH higher as this system is in bad shape (after 3 days patients are waiting on average over 3 hours… and a lot are waiting much longer!)\nMaybe try adding another nurse in to get the system under control first!\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        self.patience_nurse = random.randint(5, 50) ##NEW\n\n\n\n15.1.1.3 Model class\n\n15.1.1.3.1 The init method\nIn the init method, we set up an additional attribute to track the number of people reneging.\n\ndef __init__(self, run_number):\n    # Set up SimPy environment\n    self.env = simpy.Environment()\n\n    # Set up counters to use as entity IDs\n    self.patient_counter = 0\n\n    # Set up resources\n    self.nurse = simpy.PriorityResource(self.env,\n                                        capacity=g.number_of_nurses)\n\n    # Set run number from value passed in\n    self.run_number = run_number\n\n    # Set up DataFrame to store patient-level results\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Q Time Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Set up attributes that will store mean queuing times across the run\n    self.mean_q_time_nurse = 0\n\n    ##NEW - we'll set up a new attribute that will store the number of\n    # people that reneged from queues in the run (we only have one queue in\n    # this model)\n    self.num_reneged_nurse = 0\n\n    random.seed(42)\n\n\n\n15.1.1.3.2 The attend_clinic method\nIn the attend clinic, we now add in an OR statement (the vertical line | , also known as a pipe) to our request for the nurse.\n\nresult_of_queue = (yield req | self.env.timeout(patient.patience_nurse))\n\nIt basically says “Wait for the request for the nurse to be fulfilled OR until the patient’s patience level has passed, whichever comes first, and then store whatever the outcome was.\nWe then need to check whether we got our req - the resource we requested - or whether the timeout occurred.\nWe do this with conditional logic:\n\nif req in result_of_queue:\n\nThe indented code after this statement will only take place if the resource became available before the patient’s patience ran out (i.e. if the resource became available before the patience period elapsed).\n\ndef attend_clinic(self, patient):\n    # Nurse consultation activity\n    start_q_nurse = self.env.now\n\n    with self.nurse.request(priority=patient.priority) as req:\n        ##NEW\n        result_of_queue = (yield req |\n                            self.env.timeout(patient.patience_nurse))\n\n        ##NEW - we now need to check whether the patient waited or reneged,\n        # as we could have got to this point of the generator function\n        # either way.  We'll now only get them to see the nurse if they\n        # waited.  If they didn't wait, we'll add to our counter of how\n        # many patients reneged from the queue.\n        if req in result_of_queue:\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)\n        else:\n            self.num_reneged_nurse += 1\n\n            print (f\"Patient {patient.id} reneged after waiting\",\n                    f\"{patient.patience_nurse} minutes\")\n\n\n\n15.1.1.3.3 The run method\nThe only change to the run method is adding a print statement to the end of it to print the patients who reneged.\n\nprint (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n\n\n\n\n15.1.1.4 Trial class\n\n15.1.1.4.1 The init method\nIn the init method, we add in an addiitonal attribute that is a placeholder column for the number of people in each run who reneged.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    ##NEW - additional column of trial results to store the number of\n    # patients that reneged in each run\n    self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n15.1.1.4.2 The calculate_means_over_trial method\nWe also now need to calculate the mean number of patients reneging per run.\n\ndef calculate_means_over_trial(self):\n    self.mean_q_time_nurse_trial = (\n        self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n    )\n\n    ##NEW\n    self.mean_reneged_q_nurse = (\n        self.df_trial_results[\"Reneged Q Nurse\"].mean()\n    )\n\n\n\n15.1.1.4.3 The print_trial_results method\n\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n    ##NEW - we will also now print out the mean number of patients who\n    # reneged from the nurse's queue per run\n    print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n\n\n\n15.1.1.4.4 The run_trial method\nWe also need to add the number of patients who reneged from the nurse’s queue as one of the results against each run.\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_reneged_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n\n\n\n\n\n15.1.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 120\n    number_of_runs = 1\n    warm_up_period = 360\n\n    random.seed(42)\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        ##NEW - added a new patience attribute of the patient.  This determines\n        # how long the patient is prepared to wait for the nurse.  Here we just\n        # randomly sample an integer between 5 and 50 (so the patient will be\n        # prepared to wait for somewhere between 5 and 50 minutes in the queue),\n        # but in a real world application you would probably want to have a\n        # more refined way of allocating patience to patients (e.g basing\n        # probabilities off prior data, or using a non-uniform named\n        # distribution).  You could have different patience levels for different\n        # queues, or just a general patience level.  Or even get creative and\n        # have a patience level that decreases the longer they've been in the\n        # system!\n        # If we want to see the effect of this, we can try changing the patience\n        # levels - but you'll need to make the patience levels MUCH higher as\n        # this system is in bad shape (remember, after 3 days patients are\n        # waiting on average over 3 hours... and a lot are waiting much longer!)\n        # Maybe try adding another nurse in to get the system under control\n        # first!\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        ##NEW - we'll set up a new attribute that will store the number of\n        # people that reneged from queues in the run (we only have one queue in\n        # this model)\n        self.num_reneged_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            ##NEW - this statement now uses a vertical bar (|) / pipe as an \"or\"\n            # statement.  It basically says \"Wait for the request for the nurse\n            # to be fulfilled OR until the patient's patience level has passed,\n            # whichever comes first, and then store whatever the outcome was.\n            result_of_queue = (yield req |\n                               self.env.timeout(patient.patience_nurse))\n\n            ##NEW - we now need to check whether the patient waited or reneged,\n            # as we could have got to this point of the generator function\n            # either way.  We'll now only get them to see the nurse if they\n            # waited.  If they didn't wait, we'll add to our counter of how\n            # many patients reneged from the queue.\n            if req in result_of_queue:\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n            else:\n                self.num_reneged_nurse += 1\n\n                print (f\"Patient {patient.id} reneged after waiting\",\n                       f\"{patient.patience_nurse} minutes\")\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - we'll print out the number of patients that reneged from the\n        # nurse queue in this run of the model.\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - additional column of trial results to store the number of\n        # patients that reneged in each run\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - we also now need to calculate the mean number of patients\n        # reneging per run\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - we will also now print out the mean number of patients who\n        # reneged from the nurse's queue per run\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - we also need to add the number of patients who reneged from\n            # the nurse's queue as one of the results against each run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\n\n\n15.1.3 Exploring the outputs\nWhat are the outputs?\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n\nPatient 4 reneged after waiting 10 minutes\nPatient 9 reneged after waiting 22 minutes\nPatient 12 reneged after waiting 11 minutes\nPatient 8 reneged after waiting 31 minutes\nPatient 16 reneged after waiting 10 minutes\nPatient 21 reneged after waiting 15 minutes\nPatient 41 reneged after waiting 5 minutes\nPatient 34 reneged after waiting 32 minutes\nPatient 35 reneged after waiting 28 minutes\nPatient 51 reneged after waiting 6 minutes\nPatient 61 reneged after waiting 12 minutes\nPatient 57 reneged after waiting 43 minutes\nPatient 63 reneged after waiting 19 minutes\nPatient 67 reneged after waiting 22 minutes\nPatient 74 reneged after waiting 8 minutes\nPatient 75 reneged after waiting 11 minutes\nPatient 80 reneged after waiting 5 minutes\nPatient 78 reneged after waiting 9 minutes\nPatient 70 reneged after waiting 31 minutes\nPatient 79 reneged after waiting 11 minutes\nPatient 77 reneged after waiting 16 minutes\nPatient 69 reneged after waiting 41 minutes\nPatient 92 reneged after waiting 10 minutes\nPatient 91 reneged after waiting 15 minutes\nPatient 95 reneged after waiting 20 minutes\nPatient 98 reneged after waiting 18 minutes\nPatient 97 reneged after waiting 41 minutes\nRun Number 0\n            Q Time Nurse\nPatient ID              \n72             29.775128\n81              0.000000\n82              2.882096\n83              0.497733\n84              3.535558\n85              0.000000\n86              4.253027\n88              1.246385\n89              0.975995\n87             15.898992\n90             13.091388\n93              5.540775\n96              4.973317\n94             14.738309\n100             4.846364\n99             12.956481\n101            11.904287\n102             3.337391\n104             4.246539\n27 patients reneged from nurse queue\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse\nRun Number                                    \n0                    7.089461               27\nMean Q Nurse : 7.1 minutes\nMean Reneged Q Nurse : 27.0 patients\n\n\nWe can see that not every patient is reneging.\nWe can also see that some patients who arrived in the system later balk earlier than patients who have been there longer (i.e. a patient with a later ID balks before a patient with an earlier ID). This is due to the randomly set reneging threshold for each patient - some people aren’t willing to wait as long.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, Balking and Jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#balking",
    "href": "reneging_balking_jockeying.html#balking",
    "title": "15  Reneging, Balking and Jockeying",
    "section": "15.2 Balking",
    "text": "15.2 Balking\nFor balking, there are two different ways in which balking can occur (and both could occur in the same model):\n\nAn entity may choose not to join a queue because it is too long for their preferences / needs.\nAn entity may not be able to join a queue because there is no capacity for them.\n\nWe will look at the latter, but the way we approach it is the same for both - the only difference is that, in the former, the maximum queue length is likely to be an attribute of the patient (and may be individual per patient) just like in the reneging example, rather than an attribute of the model.\nHere, we’ll imagine that in our clinic, there is only space for 3 people to wait to see the nurse, and if there is no space, they cannot wait.\nTo model our balking requirements, we will:\n\nAdd a parameter to g class to store the maximum queue length allowed (if this were patient-decided balking, we’d put this in the patient class instead).\nAdd a list to our model attributes that will store all the patient objects currently in the queue for the nurse. This is really useful as it allows us to see who is in the queue at any time, as well as how many etc.\nWhenever a patient joins or leaves the queue, we’ll update the list of patients in the queue.\nBefore we ask for the nurse resource, we’ll first check if the queue is at maximum size. If it is, the patient will never join the queue and we’ll record that. If not, we’ll proceed as before.\n\nWe’ll add results of number of patients who balked to our results.\n\n15.2.1 Coding a balking example\n\n15.2.1.1 g class\nWe’ll add a parameter value that will store the maximum length of the queue we allow for the nurse.\nLet’s imagine there’s only space for 3 people in the waiting room and so no more than 3 people can wait at any time.\n\n\n\n\n\n\nNote\n\n\n\nNote - we could simulate balking from the perspective of the patient instead (or as well) - e.g. the patient will only wait if there are no more than x people waiting etc. If we did this, we’d probably want to make this level an attribute of the patient, as it may vary between patients.\n\n\n\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    ##NEW\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 100\n    warm_up_period = 1440\n\n\n\n15.2.1.2 Patient class\nThis class is unchanged.\n\n\n15.2.1.3 Model class\n\n15.2.1.3.1 The init method\nHere we add in an additional attribute to count the number of people who balk.\nWe also we add a list that will store patient objects queuing for the nurse consultation. This will allow us to see who is in the queue at any time, as well as the length of the queue etc.a reneging example\n\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW\n\n        self.q_for_nurse_consult = [] ##NEW\n\n\n\n15.2.1.3.2 The generator_patient_arrival method\nThis method is unchanged.\n\n\n15.2.1.3.3 The attend_clinic method\n\ndef attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) &lt; g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n\n\n\n15.2.1.3.4 The calculate_run_results method\nThis method is unchanged.\n\n\n15.2.1.3.5 The run method\nHere we have added a print message displaying how many patients balked in this run.\n\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Print patient level results for this run\n    print (f\"Run Number {self.run_number}\")\n    print (self.results_df)\n    print (f\"{self.num_balked_nurse} patients balked at the nurse queue\") ##NEW\n\n\n\n\n15.2.1.4 Trial class\n\n15.2.1.4.1 The init method\nFirst we add in a column to store the number who balked at the nurse queue in each run.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Balked Q Nurse\"] = [0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n15.2.1.4.2 The calculate_means_over_trial method\nWe add a calculation of mean number of patients who balked at the nurse queue per run.\n\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n\n\n15.2.1.4.3 The print_trial_results method\nWe add in a print message of mean number of patients balking at nurse queue per run.\n\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n    print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\") ##NEW\n\n\n\n15.2.1.4.4 The run_trial method\nFinally we add the number that balked at the nurse queue to results in the run.\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_balked_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n\n\n\n\n\n15.2.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - we'll add a parameter value that will store the maximum length of\n    # the queue we allow for the nurse.  Let's imagine there's only space for 3\n    # people in the waiting room and so no more than 3 people can wait at any\n    # time.  Note - we could simulate balking from the perspective of the\n    # patient instead (or as well) - e.g. the patient will only wait if there\n    # are no more than x people waiting etc.  If we did this, we'd probably\n    # want to make this level an attribute of the patient, as it may vary\n    # between patients.\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 3\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW - added to record number balking\n\n        ##NEW - we add a list that will store patient objects queuing for the\n        # nurse consultation.  This will allow us to see who is in the queue at\n        # any time, as well as the length of the queue etc\n        self.q_for_nurse_consult = []\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) &lt; g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - added print message displaying how many patients balked in this\n        # run\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store the number who balked at the nurse queue\n        # in each run\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - added calculation of mean number of patients who balked at the\n        # nurse queue per run\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - added print message of mean number of patients balking at nurse\n        # queue per run\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - added number balked at nurse queue to results in the run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_balked_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\n\n\n15.2.3 Exploring the outputs\nWhat are the outputs?\nWe are doing three runs in this case.\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse\nPatient ID              \n285             1.187896\n286             6.171316\n287             8.404058\n284            27.968353\n289             0.000000\n...                  ...\n874            10.401421\n875            15.042325\n879             3.874218\n876            18.374498\n881             4.260767\n\n[448 rows x 1 columns]\n215 patients balked at the nurse queue\nRun Number 1\n            Q Time Nurse\nPatient ID              \n266             3.427072\n267             2.909220\n268             4.149866\n270             1.517552\n271             4.371772\n...                  ...\n836             5.166214\n837             3.093724\n831            43.525229\n839             2.747625\n840             8.486514\n\n[453 rows x 1 columns]\n165 patients balked at the nurse queue\nRun Number 2\n            Q Time Nurse\nPatient ID              \n298             6.192226\n297            14.968568\n300             5.139509\n302             2.315511\n303             4.039407\n...                  ...\n907             9.574678\n908             3.791233\n909             2.115460\n910             0.588321\n911             5.172178\n\n[464 rows x 1 columns]\n216 patients balked at the nurse queue\nTrial Results\n            Mean Q Time Nurse  Balked Q Nurse\nRun Number                                   \n0                   10.743632           215.0\n1                   10.645624           165.0\n2                   10.539909           216.0\nMean Q Nurse : 10.6 minutes\nMean Balked Q Nurse : 198.66666666666666 patients\n\n\nWe can see that we have patients reneging, but due to the random variation across the arrivals and consult times, the size of the queue is different at different points in time, so we get variation in the patients balking each time.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, Balking and Jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#jockeying",
    "href": "reneging_balking_jockeying.html#jockeying",
    "title": "15  Reneging, Balking and Jockeying",
    "section": "15.3 Jockeying",
    "text": "15.3 Jockeying\nTrue jockeying involves entities switching from one queue to another, typically because they make a decision that they will likely be seen faster if they do.\nIn over 13 years, the author has never used jockeying to model a healthcare system. SimPy documentation does not cover it either and makes a point of saying they won’t (which implies it’s complicated, though fundamentally you’d need a model of the behaviour in making that decision combined with removing the entity from one queue and placing it in another).\nThere are likely to be few systems that you will model that would use jockeying. However, you might encounter systems where entities pick which queue to join in the first place based on queue length (eg patients deciding which Minor Injury Unit or Emergency Department to attend based on live waiting time data online).\nFor that reason, the example here will be based on this kind of model.\n\n15.3.1 A ‘choosing queues’ example\nLet’s imagine a slight change to our nurse clinic model.\nLet’s imagine that, as well as the nurse, there is also a doctor that patients can see that offers the same service. Patients can choose to join whichever queue they prefer - and they do this by joining the nurse queue if it’s shorter (and the nurse has capacity), and otherwise joining the doctor’s queue.\nThe doctor’s queue has no limits on capacity, and the doctor does not take a break (or rather, there is always a doctor available).\nConsultation times with the doctor are slightly shorter on average (5 mins vs 6 mins for the nurse), but more variable (with a standard deviation of 3 mins vs 1 min for the nurse).\nWe’re also going to imagine that word has got out that there’s now a doctor available too, and demand has more than doubled - patients are now arriving at the clinic every 2 minutes on average, compared to an average of every 5 minutes before.\nDue to the new logic, there should never be any patients balking (as they’d join the doctor’s queue if the nurse queue is full, and the doctor’s queue doesn’t have a capacity constraint), but we’ll still record these numbers so we can check that.\n\n\n15.3.2 Coding the ‘choosing queues’ example\nThe full updated code for the model is given below.\nThis example brings together code for:\n\nNurse breaks.\nReneging.\nBalking.\nQueue choosing.\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 2 ##NEW - decreased time to generate more frequent arrivals\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    mean_d_consult_time = 5 ##NEW - added mean consult time for doctor\n    sd_d_consult_time = 3 ##NEW - added SD consult time for doctor\n\n    # Resource numbers\n    number_of_nurses = 1\n    number_of_doctors = 1 ##NEW - added parameter to store number of doctors\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Maximum allowable queue lengths\n    max_q_nurse = 10\n\n    # Simulation meta parameters\n    sim_duration = 480 ##NEW significantly shortened so can see clear queue plot\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.q_time_doc = 0 ##NEW - attribute to store queuing time for doctor\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n        ##NEW - added random allocation of patience level to see doctor\n        self.patience_doctor = random.randint(20, 100)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        ##NEW - added doctor resource also as PriorityResource\n        self.doctor = simpy.PriorityResource(self.env,\n                                             capacity=g.number_of_doctors)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store queuing time for doctor for each patient\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW - store mean q time for doctor\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_reneged_nurse = 0\n        self.num_balked_nurse = 0\n\n        ##NEW - added equivalent queuing behaviour attributes for doctor\n        # though no balking should occur for the doctor or the nurse in this\n        # scenario - if there is no capacity in the nurse queue, the patient\n        # will join the doctor queue, which has no limit\n        self.num_reneged_doctor = 0\n        self.num_balked_doctor = 0\n\n        # Set up lists to store patient objects in each queue\n        self.q_for_nurse_consult = []\n        self.q_for_doc_consult = [] ##NEW - list to store queue for doctor\n\n        # Pandas dataframe to record number in queue(s) over time\n        self.queue_df = pd.DataFrame()\n        self.queue_df[\"Time\"] = [0.0]\n        self.queue_df[\"Num in Q Nurse\"] = [0]\n        self.queue_df[\"Num in Q Doctor\"] = [0] ##NEW added column for doctor\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n\n        ##NEW - check whether queue for the nurse is shorter than the queue for\n        # the doctor AND that there is space in the nurse's queue (which is\n        # constrained).  If both of these are true, then join the queue for the\n        # nurse, otherwise join the queue for the doctor.\n        if ((len(self.q_for_nurse_consult) &lt; len(self.q_for_doc_consult)) and\n            (len(self.q_for_nurse_consult) &lt; g.max_q_nurse)):\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            self.q_for_nurse_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            ##NEW need to also add length of current queue for doctor to the\n            # list (need to add both even though this is just an update to the\n            # length of the nurse list)\n            if self.env.now &gt; g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.nurse.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_nurse))\n\n                self.q_for_nurse_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                ##NEW need to also add length of current queue for doctor to the\n                # list (need to add both even though this is just an update to\n                # the length of the nurse list)\n                if self.env.now &gt; g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_nurse = self.env.now\n\n                    patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                    if self.env.now &gt; g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                            patient.q_time_nurse\n                        )\n\n                    sampled_nurse_act_time = Lognormal(\n                        g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                    yield self.env.timeout(sampled_nurse_act_time)\n                else:\n                    self.num_reneged_nurse += 1\n        else:\n            ##NEW - logic for patient to join queue for the doctor instead.\n            # In this system, there should be no balking as if the queue for the\n            # nurse has no more capacity, they'll just see the doctor which\n            # doesn't have a limit.\n\n            # Doctor consultation activity\n            start_q_doc = self.env.now\n\n            self.q_for_doc_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            if self.env.now &gt; g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.doctor.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_doctor))\n\n                self.q_for_doc_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                if self.env.now &gt; g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_doc = self.env.now\n\n                    patient.q_time_doc = end_q_doc - start_q_doc\n\n                    if self.env.now &gt; g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                            patient.q_time_doc\n                        )\n\n                    sampled_doc_act_time = Lognormal(\n                        g.mean_d_consult_time, g.sd_d_consult_time).sample()\n\n                    yield self.env.timeout(sampled_doc_act_time)\n                else:\n                    self.num_reneged_doctor += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        ##NEW - added calculation for mean queuing time for doctor\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n        ##NEW added print statements for reneging and balking from doctor queue\n        print (f\"{self.num_reneged_doctor} patients reneged from the doctor\",\n               \"queue\")\n        print (f\"{self.num_balked_doctor} patients balked at the doctor queue\")\n        # Print queues over time dataframe for this run\n        print (\"Queues over time\")\n        print (self.queue_df)\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        ##NEW added columns to store number trial results relating to doctor\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Doctor\"] = [0]\n        self.df_trial_results[\"Balked Q Doctor\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n        ##NEW added calculations for doctor queue and activity across trial\n        self.mean_q_time_doc_trial = (\n            self.df_trial_results[\"Mean Q Time Doctor\"].mean()\n        )\n\n        self.mean_reneged_q_doc = (\n            self.df_trial_results[\"Reneged Q Doctor\"].mean()\n        )\n\n        self.mean_balked_q_doc = (\n            self.df_trial_results[\"Balked Q Doctor\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n        ##NEW added print statements for trial results related to doctor\n        print (f\"Mean Q Doctor : {self.mean_q_time_doc_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Doctor : {self.mean_reneged_q_doc} patients\")\n        print (f\"Mean Balked Q Doctor : {self.mean_balked_q_doc} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW added doctor results to end of list of results to add for this\n            # run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse,\n                                              my_model.num_balked_nurse,\n                                              my_model.mean_q_time_doctor,\n                                              my_model.num_reneged_doctor,\n                                              my_model.num_balked_doctor]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\n\n\n15.3.3 Exploring the outputs\n\nmy_trial = Trial()\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse  Q Time Doctor\nPatient ID                             \n715                  NaN      10.769071\n722             4.944191            NaN\n717                  NaN      15.113367\n716            17.308768            NaN\n729                  NaN       0.770431\n...                  ...            ...\n961                  NaN       9.896039\n962             9.591018            NaN\n959                  NaN      16.960930\n958            18.176180            NaN\n969             4.431502            NaN\n\n[166 rows x 2 columns]\n198 patients reneged from nurse queue\n0 patients balked at the nurse queue\n95 patients reneged from the doctor queue\n0 patients balked at the doctor queue\nQueues over time\n            Time  Num in Q Nurse  Num in Q Doctor\n0       0.000000             0.0              0.0\n1    1440.447541             3.0              5.0\n2    1440.550052             4.0              5.0\n3    1441.801075             4.0              4.0\n4    1441.816771             3.0              4.0\n..           ...             ...              ...\n502  1913.508621             5.0              6.0\n503  1914.375700             6.0              6.0\n504  1914.919764             6.0              7.0\n505  1915.435042             7.0              7.0\n506  1916.332824             6.0              7.0\n\n[507 rows x 3 columns]\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse  Balked Q Nurse  \\\nRun Number                                                       \n0                   10.942746              198               0   \n\n            Mean Q Time Doctor  Reneged Q Doctor  Balked Q Doctor  \nRun Number                                                         \n0                    10.254885                95                0  \nMean Q Nurse : 10.9 minutes\nMean Reneged Q Nurse : 198.0 patients\nMean Balked Q Nurse : 0.0 patients\nMean Q Doctor : 10.3 minutes\nMean Reneged Q Doctor : 95.0 patients\nMean Balked Q Doctor : 0.0 patients",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, Balking and Jockeying</span>"
    ]
  },
  {
    "objectID": "one_or_the_other.html",
    "href": "one_or_the_other.html",
    "title": "16  (Coming Soon!) Waiting for One or The Other",
    "section": "",
    "text": "Warning\n\n\n\nThis section is a work in progress\n\n\nSometimes in a system you may find yourself in a situation where you need to \nFor example, you may have:\n\nAn operating theatre where the operation will be cancelled if a recovery bed resource is not available within a certain time of the patient beginning to be prepped.\nAn air ambulance where the call will be regarded as ‘missed’ and exit the system if an air ambulance resource is not immediately available.\n\nThis is really just a similar situation to reneging - but instead of using a patience attribute, we instead provide some other value - often a fixed period of time - to check against.\n\n\n\n\n\n\nNote\n\n\n\nCode for this example is coming soon.\nIn the meantime, take a look at the reneging section - in particular the use of the OR statement in the form of the | (pipe).",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>(Coming Soon!) Waiting for One or The Other</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html",
    "href": "modelling_variable_arrival_rates.html",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "",
    "text": "17.1 The principle used\nIt is often the case that arrivals to a system do not occur completely regularly throughout the day.\nFor example, in an emergency department, we may find that the number of arrivals climb in the afternoon and early evening before dropping off again overnight.\nOne way to implement this is to return to the sim-tools package by Tom Monks, which we used in (Chapter 12): Choosing Distributions and Chapter 14: Reproducibility. We will use a class that creates a non-stationary poisson process via thinning.\nThe sim-tools documentation states the following about the approach we will be using:\nThe NSPP thinning class takes in a dataframe with two columns:\nLet’s look at an example of the sort of dataframe we would create and pass in.\nt\nmean_iat\n\n\n\n\n0\n0\n15\n\n\n1\n60\n15\n\n\n2\n120\n20\n\n\n3\n180\n23\n\n\n4\n240\n25\n\n\n5\n300\n28\n\n\n6\n360\n25\n\n\n7\n420\n22\n\n\n8\n480\n18\n\n\n9\n540\n16\n\n\n10\n600\n15\n\n\n11\n660\n13\n\n\n12\n720\n10\n\n\n13\n780\n8\n\n\n14\n840\n10\n\n\n15\n900\n11\n\n\n16\n960\n8\n\n\n17\n1020\n8\n\n\n18\n1080\n7\n\n\n19\n1140\n6\n\n\n20\n1200\n9\n\n\n21\n1260\n11\n\n\n22\n1320\n13\n\n\n23\n1380\n14\nLet’s add a few more columns so we can better understand what’s going on.\nt\ntime_minutes\nmean_iat\narrival_rate\narrivals_per_hour\n\n\n\n\n0\n0\n00:00:00\n15\n1/15\n4.0\n\n\n1\n60\n01:00:00\n15\n1/15\n4.0\n\n\n2\n120\n02:00:00\n20\n1/20\n3.0\n\n\n3\n180\n03:00:00\n23\n1/23\n2.6\n\n\n4\n240\n04:00:00\n25\n1/25\n2.4\n\n\n5\n300\n05:00:00\n28\n1/28\n2.1\n\n\n6\n360\n06:00:00\n25\n1/25\n2.4\n\n\n7\n420\n07:00:00\n22\n1/22\n2.7\n\n\n8\n480\n08:00:00\n18\n1/18\n3.3\n\n\n9\n540\n09:00:00\n16\n1/16\n3.8\n\n\n10\n600\n10:00:00\n15\n1/15\n4.0\n\n\n11\n660\n11:00:00\n13\n1/13\n4.6\n\n\n12\n720\n12:00:00\n10\n1/10\n6.0\n\n\n13\n780\n13:00:00\n8\n1/8\n7.5\n\n\n14\n840\n14:00:00\n10\n1/10\n6.0\n\n\n15\n900\n15:00:00\n11\n1/11\n5.5\n\n\n16\n960\n16:00:00\n8\n1/8\n7.5\n\n\n17\n1020\n17:00:00\n8\n1/8\n7.5\n\n\n18\n1080\n18:00:00\n7\n1/7\n8.6\n\n\n19\n1140\n19:00:00\n6\n1/6\n10.0\n\n\n20\n1200\n20:00:00\n9\n1/9\n6.7\n\n\n21\n1260\n21:00:00\n11\n1/11\n5.5\n\n\n22\n1320\n22:00:00\n13\n1/13\n4.6\n\n\n23\n1380\n23:00:00\n14\n1/14\n4.3\nLet’s visualise this in a graph.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html#the-principle-used",
    "href": "modelling_variable_arrival_rates.html#the-principle-used",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "",
    "text": "Thinning is an acceptance-rejection approach to sampling inter-arrival times (IAT) from a time dependent distribution where each time period follows its own exponential distribution.\n\n\n\nThe first, called ‘t’, is a list of time points at which the arrival rate changes.\nThe second, called ‘arrival_rate’, is the arrival rate in the form of the average inter-arrival time in time units.\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe key things to note here are\n\nA higher inter-arrival time means there are fewer arrivals per hour\nWe store the time as a number of simulation units. Here we are interpreting this as the number of minutes, but we could correspond this instead to days, which we will do in a later example.\n\n\n\n\n\n\n\n\n\nClick here for a more in-depth breakdown about how the NSPPThinning class works under the hood\n\n\n\n\n\nThe NSPP thinning class uses this table to do a few things:\n\nSet up an exponential distribution using the highest observed arrival rate.\nWork out the time interval between our dataframe rows.\n\nLet’s first look at 20,000 samples taken from the exponential distribution that is set up using the maximum arrival rate (1 divided by the lowest inter-arrival time).\n\n\n                            \n                                            \n\n\nNow let’s take a look at the distribution that is generated when the code thinks the simulation time is 480.\n\n\nThe index of the row to return from the dataframe - is 8\nThe value of lambda at this time is 0.05555555555555555\n\n\n\n\n                            \n                                            \n\n\nLet’s repeat this for all the different time periods in our dataset.\n\n\n                            \n                                            \n\n\nThe wider distributions - where more of the blue ‘unthinned’ distribution is still visible - indicate that the sampled inter-arrival time is likely to be longer.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html#coding-the-model",
    "href": "modelling_variable_arrival_rates.html#coding-the-model",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "17.2 Coding the model",
    "text": "17.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n17.2.1 Imports\nIn addition to our existing imports, we need to import the NSPPThinning class from the time_dependent module as follows.\n\nfrom sim_tools.time_dependent import NSPPThinning\n\n\n\n17.2.2 g class\nWe need to add a new dataframe to our g class.\nThis will be used by the NSPPThinning class to determine the arrival rate depending on the current simulation time.\nNote that the dataframe we have loaded in only contains a column for the mean interarrival time. We need to convert this to a rate by dividing 1 by the mean interarrival time.\n\n\n\n\n\n\nTip\n\n\n\nThe two essential columns to have in our new arrivals_time_dependent_df are:\n\nt\narrival_rate\n\nt is an integer representing the simulation time at which the rate applies from.\narrival_rate is an indication of the arrivals per time unit (1 over the average interarrival time).\n\n\nWe will also remove our patient_inter attribute as that’s no longer going to be in use.\n\narrivals_df = pd.read_csv(\"resources/nspp_example_1.csv\")\narrivals_df[\"arrival_rate\"] = arrivals_df['mean_iat'].apply(lambda x: 1/x)\n\nclass g:\n    arrivals_time_dependent_df = arrivals_df  ##NEW\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5\n\n\n\n17.2.3 Patient class\nLet’s add an attribute to our patient class so we can track their arrival time.\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.arrival_time = 0 ##NEW\n        self.q_time_nurse = 0\n\n\n\n17.2.4 Model class\n\n17.2.4.1 The init method\nIn our init method we will set up our random number generator.\nWe are also going to create an empty list to store our patient objects - this is so we can track the arrival times.\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ##NEW\n        # Here we set up our arrivals distribution\n        self.arrivals_dist = NSPPThinning(\n          data=g.arrivals_time_dependent_df,\n          random_seed1 = run_number * 42,\n          random_seed2 = run_number * 88\n        )\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create somewhere to store our patient objects\n        self.patient_list = [] ##NEW\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n\n\n17.2.4.2 The generator_patient_arrivals method\nIn this method, we just need to swap our use of random.expovariate(1.0 / g.patient_inter) with using the sample() method of the NSPPThinning class.\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            self.patient_list.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.arrivals_dist.sample(simulation_time=self.env.now) ##NEW\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\n17.2.4.3 The attend_clinic and calculate_run_results methods\nThese methods are unchanged.\n\n\n17.2.4.4 The run method\nFor the purposes of checking the model is working as intended, we are going to return the list of patient arrival times after every run.\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        ##NEW - return list of arrival times\n        return [p.arrival_time for p in self.patient_list]\n\n\n\n\n17.2.5 The trial class\n\n17.2.5.1 The init class\nWe are going to add somewhere to store the arrival times from each run so we can monitor them.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.arrival_time_lists = [] ##NEW\n\n\n\n17.2.5.2 The run_trial method\nWe are going to modify this to return the arrival times from each run.\n\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        model_outputs = my_model.run() ##NEW\n        ## Saves output from my_model.run to a variable\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n        ##NEW\n        self.arrival_time_lists.append(\n              pf.DataFrame({\"run\": [run for i in range(len(model_outputs))], \"arrival_times\": model_outputs})\n              )\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.print_trial_results()\n\n    ##NEW - return the arrival times as well\n    return self.arrival_time_lists",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html#the-full-code",
    "href": "modelling_variable_arrival_rates.html#the-full-code",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "17.3 The full code",
    "text": "17.3 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\narrivals_df = pd.read_csv(\"resources/nspp_example_1.csv\") ##NEW\narrivals_df[\"arrival_rate\"] = arrivals_df['mean_iat'].apply(lambda x: 1/x) ##NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\n\nclass g:\n    arrivals_time_dependent_df = arrivals_df ##NEW\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 1440\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.arrival_time = 0 ##NEW\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ##NEW\n        # Here we set up our arrivals distribution\n        self.arrivals_dist = NSPPThinning(\n          data=g.arrivals_time_dependent_df,\n          random_seed1 = run_number * 42,\n          random_seed2 = run_number * 88\n        )\n\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create somewhere to store our patient objects\n        self.patient_list = [] ##NEW\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n            p.arrival_time = self.env.now\n\n            self.patient_list.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.arrivals_dist.sample(simulation_time=self.env.now) ##NEW\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        ##NEW - return list of arrival times\n        return [p.arrival_time for p in self.patient_list]\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.arrival_time_lists = [] ##NEW\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            model_outputs = my_model.run() ##NEW\n            ## Saves output from my_model.run to a variable\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            ##NEW\n            self.arrival_time_lists.append(\n              pd.DataFrame({\"run\": [run for i in range(len(model_outputs))], \"arrival_times\": model_outputs})\n              )\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n        ##NEW - return the arrival times as well\n        return self.arrival_time_lists",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html#evaluating-the-outputs",
    "href": "modelling_variable_arrival_rates.html#evaluating-the-outputs",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "17.4 Evaluating the outputs",
    "text": "17.4 Evaluating the outputs\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\narrival_times = my_trial.run_trial()\n\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                    6.249508\n1                    7.112333\n2                   11.094958\n3                    5.961113\n4                   21.239694\n...                       ...\n95                   5.220083\n96                  15.817044\n97                   6.665153\n98                   8.361758\n99                  10.122620\n\n[100 rows x 1 columns]\n\n\n\narrival_times_df = pd.concat(arrival_times)\n\narrival_times_df['arr_time_bins'] = pd.cut(arrival_times_df['arrival_times'], bins=[i for i in range(0, g.sim_duration+1, 60)], include_lowest=True, right=False)\n\narrival_times_df.head(10)\n\n\n\n\n\n\n\n\nrun\narrival_times\narr_time_bins\n\n\n\n\n0\n0\n0.000000\n[0, 60)\n\n\n1\n0\n10.197174\n[0, 60)\n\n\n2\n0\n10.316014\n[0, 60)\n\n\n3\n0\n10.329630\n[0, 60)\n\n\n4\n0\n104.958166\n[60, 120)\n\n\n5\n0\n119.007720\n[60, 120)\n\n\n6\n0\n130.517720\n[120, 180)\n\n\n7\n0\n153.383899\n[120, 180)\n\n\n8\n0\n162.559241\n[120, 180)\n\n\n9\n0\n163.371226\n[120, 180)\n\n\n\n\n\n\n\n\narrival_times_df.tail(10)\n\n\n\n\n\n\n\n\nrun\narrival_times\narr_time_bins\n\n\n\n\n117\n99\n1295.435342\n[1260, 1320)\n\n\n118\n99\n1304.067663\n[1260, 1320)\n\n\n119\n99\n1310.314246\n[1260, 1320)\n\n\n120\n99\n1314.964087\n[1260, 1320)\n\n\n121\n99\n1336.090239\n[1320, 1380)\n\n\n122\n99\n1339.544378\n[1320, 1380)\n\n\n123\n99\n1361.553145\n[1320, 1380)\n\n\n124\n99\n1370.050482\n[1320, 1380)\n\n\n125\n99\n1376.985002\n[1320, 1380)\n\n\n126\n99\n1402.424834\n[1380, 1440)\n\n\n\n\n\n\n\nLet’s count the number of arrivals that have turned up during each 60-minute interval across the hundred runs we have done.\n\narrival_times_df_grouped = (\n  arrival_times_df\n  .groupby(\"arr_time_bins\")\n  .count()\n  .reset_index()\n)\n\n\narrival_times_df_grouped['arr_time_bins_str'] = (\n  arrival_times_df_grouped['arr_time_bins'].astype('str')\n)\n\narrival_times_df_grouped[\"mean_arrivals_in_period_per_run\"] = (\n  arrival_times_df_grouped[\"arrival_times\"] / g.number_of_runs\n)\n\npx.line(\n  arrival_times_df_grouped,\n  x=\"arr_time_bins_str\",\n  y=\"mean_arrivals_in_period_per_run\"\n)",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html#modifying-this-example---varying-arrivals-across-the-course-of-a-week",
    "href": "modelling_variable_arrival_rates.html#modifying-this-example---varying-arrivals-across-the-course-of-a-week",
    "title": "17  Modelling Variable Arrival Rates",
    "section": "17.5 Modifying this example - varying arrivals across the course of a week",
    "text": "17.5 Modifying this example - varying arrivals across the course of a week\n\ng.sim_duration = 1440 * 7\n\narrivals_df_weekly = pd.read_csv(\"resources/nspp_example_2.csv\")\narrivals_df_weekly[\"arrival_rate\"] = arrivals_df_weekly['mean_iat'].apply(lambda x: 1/x)\n\ng.arrivals_time_dependent_df = arrivals_df_weekly\n\n\n17.5.1 Evaluating the outputs\nLet’s count the number of arrivals that have turned up during each daily interval (1440 minutes) across the hundred runs we have done.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\narrival_times = my_trial.run_trial()\n\narrival_times_df = pd.concat(arrival_times)\n\narrival_times_df['arr_time_bins'] = pd.cut(arrival_times_df['arrival_times'], bins=[i for i in range(0, g.sim_duration+1, 1440)], include_lowest=True, right=False)\n\narrival_times_df_grouped = (\n  arrival_times_df\n  .groupby(\"arr_time_bins\")\n  .count()\n  .reset_index()\n)\n\n\narrival_times_df_grouped['arr_time_bins_str'] = (\n  arrival_times_df_grouped['arr_time_bins'].astype('str')\n)\n\narrival_times_df_grouped[\"mean_arrivals_in_period_per_run\"] = (\n  arrival_times_df_grouped[\"arrival_times\"] / g.number_of_runs\n)\n\npx.line(\n  arrival_times_df_grouped,\n  x=\"arr_time_bins_str\",\n  y=\"mean_arrivals_in_period_per_run\"\n)\n\n                            \n                                            \n\n\nIf we run this over a period of several weeks, we can see that the pattern repeats - despite going past the duration we specified in our csv. This means we only need to write in one repeat of the pattern.\n\ng.sim_duration = 1440 * 7 * 5\n\n\n\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                   10.508614\n1                    8.565151\n2                    8.117485\n3                   10.493240\n4                    7.058289\n...                       ...\n95                   8.599638\n96                   9.279805\n97                   8.294566\n98                   8.711545\n99                   7.344154\n\n[100 rows x 1 columns]",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "requesting_multiple_resources.html",
    "href": "requesting_multiple_resources.html",
    "title": "18  Requesting Multiple Resources Simultaneously",
    "section": "",
    "text": "18.1 Coding the model\nIn your models, you may sometimes require multiple kinds of resources to be available for a single step.\nFor example, in an emergency department, you may need both a cubicle and a nurse to be available so a patient can be seen. Cubicles may be released slower than nurses if the patient in the cubicle is now waiting for a different step of their journey in the cubicle, such as having an x-ray, seeing a different type of practitioner, or waiting for a bed to become available within the hospital so they can be admitted.\nImagine this department is having problems seeing patients fast enough. They have 15 cubicles, and 8 nurses. They can either increase the number of nurses on shift to 9, or increase the capacity to 18 cubicles. Which should they do?\nBy setting up a model where we look at how both kinds of resources are used, we can begin to explore these questions.\nLet’s return to our branching model from before.\nRemember, in this, patients:\nIn the original version of the model, we assumed that there was always a room available for patients to be seen in. Maybe each nurse and doctor in this example clinic has their own designated room they are always in.\nBut let’s imagine the setup is slightly different:\nThe cubicle is released for the next patient after seeing the nurse IF the patient leaves at this point. Otherwise, it will be released after seeing the doctor.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Requesting Multiple Resources Simultaneously</span>"
    ]
  },
  {
    "objectID": "requesting_multiple_resources.html#coding-the-model",
    "href": "requesting_multiple_resources.html#coding-the-model",
    "title": "18  Requesting Multiple Resources Simultaneously",
    "section": "",
    "text": "Tip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n\n\nSee a receptionist.\nSee a nurse.\nHave a chance of going on to see a doctor.\n\n\n\n\n\nPatients see a receptionist and go to a waiting area.\nOnce both a cubicle and a nurse are available, the patient is seen by a nurse.\nIf the patient then needs to see a doctor (which, as before, only a certain % of patients will) then they will remain in the same cubicle while waiting for a doctor.\nThe doctor will see them in the cubicle.\n\n\n\n18.1.1 g class\nWe add in an additional parameter for the number of\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 2\n    number_of_doctors = 2\n    number_of_cubicles = 5 ##NEW\n    prob_seeing_doctor = 0.6\n    sim_duration = 1800\n    number_of_runs = 10\n\n\n\n18.1.2 Patient class\nWe add in an new attribute where we will record the time spent queueing for a cubicle.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n        self.q_time_cubicle = 0 ##NEW\n\n\n\n18.1.3 Model class\n\n18.1.3.1 The init method\nWe do several things here:\n\ncreate a new cubicle resource using the number of cubicles we set in g\ncreate columns in our patient-level results dataframe for cubicle queuing time and time in the cubicle\nadd an attribute for storing the average cubicle queueing time\n\n\ndef __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(self.env, capacity=g.number_of_receptionists)\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(self.env, capacity=g.number_of_doctors)\n        self.cubicle = simpy.Resource(self.env, capacity=g.number_of_cubicles) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Q Time Cubicle\"] = [0.0] ##NEW\n        self.results_df[\"Time Using Cubicle\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n        self.mean_q_time_cubicle = 0 ##NEW\n\n\n\n18.1.3.2 The generator_patient_arrivals method\nThis method is unchanged.\n\n\n18.1.3.3 The attend_clinic method\nThis is where the majority of our changes take place.\n\n\n\n\n\n\nTip\n\n\n\nThere are two ways you can request a resource in simpy.\nWe’ve used the first method so far:\n\nwith self.receptionist.request() as req:\n    yield req\n\n    ## the rest of the code you want to run while holding on\n    ## to this resource\n\nHowever, an alternative option is this:\n\nnurse_request = self.receptionist.request()\n\nyield nurse_request\n\n## the rest of the code you want to run while holding on\n## to this resource\n\nself.nurse.release(nurse_request)\n\nHere, we don’t use indentation, and instead manually specify when we stop using the nurse and pass it back to the pool of available resources.\nIt’s useful to know about this second option as it gives us an easier way of writing the code for requesting multiple resources at once.\n\n\nOnce we finish our time with the receptionist, we are going to record two attributes.\n\n# Record the time the patient started queuing for a nurse\nstart_q_nurse = self.env.now\nstart_q_cubicle = self.env.now ##NEW\n\nYes, they are the same - but it’s a bit easier to refer back to them when they are named separately!\nNext we are going to request both a nurse and a cubicle.\n\nnurse_request = self.nurse.request()  ##NEW\ncubicle_request = self.cubicle.request() ##NEW\n\nWe then place both of these requests in a list, and wait until either of them become available.\n\nclinic_resource = yield self.env.any_of([nurse_request,cubicle_request]) ##NEW\n\nNext, we have to check three possible scenarios and act accordingly:\n\nBoth were available at the same time.\nWe got the nurse but are still waiting for a cubicle.\nWe got the cubicle but are still waiting for a nurse.\n\n\nclinic_resource_list = list(clinic_resource.keys()) ##NEW\n\nif len(clinic_resource_list) &lt; 2:\n    ## Work out which we didn't get and wait for that one\n    got_resource = clinic_resource_list[0]\n\n    if got_resource == nurse_request:\n        end_q_nurse = self.env.now\n        yield(cubicle_request)\n        end_q_cubicle = self.env.now\n    else:\n        end_q_cubicle = self.env.now\n        yield(nurse_request)\n        end_q_nurse = self.env.now\nelse:\n    end_q_cubicle = self.env.now\n    end_q_nurse = self.env.now\n\npatient.q_time_cubicle = end_q_cubicle - start_q_cubicle\n\nself.results_df.at[patient.id, \"Q Time Cubicle\"] = (\n      patient.q_time_cubicle\n)\n\n# Calculate the time this patient was queuing for the nurse, and\n# record it in the patient's attribute for this.\npatient.q_time_nurse = end_q_nurse - start_q_nurse\n\nself.results_df.at[patient.id, \"Q Time Nurse\"] = (\n  patient.q_time_nurse\n)\n\n\n\n\n\n\n\nTip\n\n\n\nRemember - we don’t have to indent all of the code where the resource is used here because we will manually specify when we release it.\nYou can still use the first method of requesting resources on top of this one - for example, our code for requesting a doctor is unchanged.\nWe just don’t release the cubicle resource until that section completes.\n\n\nNow, the only thing left to do is to find the right place to release both resources.\nFor the nurse, this is after the activity time has elapsed.\n\n## Other code relating to nurse activity...\n\n# Freeze this function in place for the activity time we sampled\n# above.  This is the patient spending time with the nurse.\nyield self.env.timeout(sampled_nurse_act_time)\n\n# When the time above elapses, the generator function will return\n# here.  As there's nothing moref that we've written, the function\n# will simply end.  This is a sink.  We could choose to add\n# something here if we wanted to record something - e.g. a counter\n# for number of patients that left, recording something about the\n# patients that left at a particular sink etc.\n\nself.nurse.release(nurse_request) ##NEW\n\nFinally, for the cubicle, we don’t release this until either after sampling to decide whether the patient goes on to see a doctor, and release it accordingly.\nPreviously we just had an if clause with no else for seeing the doctor. However, now we need to release the cubicle and record the total time spent in the cubicle even if they don’t see a doctor, so the else clause becomes necessary.\n\nif random.uniform(0,1) &lt; g.prob_seeing_doctor:\n    start_q_doctor = self.env.now\n\n    with self.doctor.request() as req:\n        yield req\n\n        end_q_doctor = self.env.now\n\n        patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n        sampled_doctor_act_time = random.expovariate(\n            1.0 / g.mean_d_consult_time\n        )\n\n        self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n            patient.q_time_doctor\n        )\n        self.results_df.at[patient.id, \"Time with Doctor\"] = (\n            sampled_doctor_act_time\n        )\n\n        yield self.env.timeout(sampled_doctor_act_time)\n\n        self.results_df.at[patient.id, \"Time Using Cubicle\"] = ( ##NEW\n            self.env.now - end_q_cubicle\n        )\n\n        self.cubicle.release(cubicle_request) ##NEW\n\n\nelse: ##NEW\n\n      self.results_df.at[patient.id, \"Time Using Cubicle\"] = (  ##NEW\n            self.env.now - end_q_cubicle\n            )\n      self.cubicle.release(cubicle_request) ##NEW\n\nThe only step remaining now is to record the average queueing time for a cubicle.\n\nself.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\nself.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\nself.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\nself.mean_q_time_cubicle = self.results_df[\"Q Time Cubicle\"].mean() ##NEW\n\n\n\n\n18.1.4 Trial class\n\n18.1.4.1 The init method\nIn the init method, we add in a column for the average cubicle queue time per run.\n\nself.df_trial_results = pd.DataFrame()\nself.df_trial_results[\"Run Number\"] = [0]\nself.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\nself.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\nself.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\nself.df_trial_results[\"Mean Q Time Cubicle\"] = [0.0] ##NEW\nself.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n18.1.4.2 The run method\nIn the run method, we just need to add the cubcicle queueing mean to the results dataframe after each run.\nAfter all runs are complete, w can also add in a column that checks which was longer on average - the queue for the cubicle, or the queue for the nurse. This can give an indication of which is the limiting resource.\n\nfor run in range(g.number_of_runs):\n    my_model = Model(run)\n    my_model.run()\n\n    self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                      my_model.mean_q_time_nurse,\n                                      my_model.mean_q_time_doctor,\n                                      my_model.mean_q_time_cubicle ##NEW\n                                      ]\n\n# Once the trial (ie all runs) has completed, add an additional column\nself.df_trial_results['nurse_queue_longer'] = np.where(self.df_trial_results['Mean Q Time Nurse'] &gt; self.df_trial_results['Mean Q Time Cubicle'], True, False) ##NEW\n\n# Print the final results\nself.print_trial_results()\n\nprint(f\"Queue for nurse was longer than queue for cubicle in {sum(self.df_trial_results['nurse_queue_longer'].values)} trials of {g.number_of_runs}\")",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Requesting Multiple Resources Simultaneously</span>"
    ]
  },
  {
    "objectID": "requesting_multiple_resources.html#the-full-code",
    "href": "requesting_multiple_resources.html#the-full-code",
    "title": "18  Requesting Multiple Resources Simultaneously",
    "section": "18.2 The full code",
    "text": "18.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nimport numpy as np ##NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 2\n    number_of_doctors = 2\n    number_of_cubicles = 5 ##NEW\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n        self.q_time_cubicle = 0 ##NEW\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(self.env, capacity=g.number_of_receptionists)\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(self.env, capacity=g.number_of_doctors)\n        self.cubicle = simpy.Resource(self.env, capacity=g.number_of_cubicles) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Q Time Cubicle\"] = [0.0] ##NEW\n        self.results_df[\"Time Using Cubicle\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n        self.mean_q_time_cubicle = 0 ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n        ##NEW: They will also be queueing for a cubicle at this point.\n        #\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n        start_q_cubicle = self.env.now ##NEW\n\n        #########\n        ##NEW\n        #########\n\n        # As we are going to require the cubicle for the entire time period from\n        # here on, and won't release it until they exit the system, we will request\n        # the cubicle here and indent all of the existing code by one level.\n\n        nurse_request = self.nurse.request()  ##NEW\n        cubicle_request = self.cubicle.request() ##NEW\n\n        clinic_resource = yield self.env.any_of([nurse_request,cubicle_request]) ##NEW\n\n        # First, check if both were available at once. If so, we can continue.\n\n        clinic_resource_list = list(clinic_resource.keys()) ##NEW\n\n        if len(clinic_resource_list) &lt; 2:\n            ## Work out which we didn't get and wait for that one\n            got_resource = clinic_resource_list[0]\n\n            if got_resource == nurse_request:\n                #print(f\"{patient.id} got nurse first at {self.env.now}\")\n                end_q_nurse = self.env.now\n                yield(cubicle_request)\n                end_q_cubicle = self.env.now\n                #print(f\"{patient.id} got cubicle at {self.env.now}\")\n            else:\n                #print(f\"{patient.id} got cubicle first at {self.env.now}\")\n                end_q_cubicle = self.env.now\n                yield(nurse_request)\n                end_q_nurse = self.env.now\n                #print(f\"{patient.id} got nurse at {self.env.now}\")\n        else:\n            #print(f\"{patient.id} got both resources simultaneously at {self.env.now}\")\n            end_q_cubicle = self.env.now\n            end_q_nurse = self.env.now\n\n        patient.q_time_cubicle = end_q_cubicle - start_q_cubicle\n\n        self.results_df.at[patient.id, \"Q Time Cubicle\"] = (\n              patient.q_time_cubicle\n        )\n\n        # Calculate the time this patient was queuing for the nurse, and\n        # record it in the patient's attribute for this.\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n          patient.q_time_nurse\n        )\n        #########\n        ##END NEW\n        #########\n\n        # Now we'll randomly sample the time this patient with the nurse.\n        # Here, we use an Exponential distribution for simplicity, but you\n        # would typically use a Log Normal distribution for a real model\n        # (we'll come back to that).  As with sampling the inter-arrival\n        # times, we grab the mean from the g class, and pass in 1 / mean\n        # as the lambda value.\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        # Here we'll store the queuing time for the nurse and the sampled\n        # time to spend with the nurse in the results DataFrame against the\n        # ID for this patient.  In real world models, you may not want to\n        # bother storing the sampled activity times - but as this is a\n        # simple model, we'll do it here.\n        # We use a handy property of pandas called .at, which works a bit\n        # like .loc.  .at allows us to access (and therefore change) a\n        # particular cell in our DataFrame by providing the row and column.\n        # Here, we specify the row as the patient ID (the index), and the\n        # column for the value we want to update for that patient.\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n\n        # Freeze this function in place for the activity time we sampled\n        # above.  This is the patient spending time with the nurse.\n        yield self.env.timeout(sampled_nurse_act_time)\n\n        # When the time above elapses, the generator function will return\n        # here.  As there's nothing moref that we've written, the function\n        # will simply end.  This is a sink.  We could choose to add\n        # something here if we wanted to record something - e.g. a counter\n        # for number of patients that left, recording something about the\n        # patients that left at a particular sink etc.\n\n        self.nurse.release(nurse_request) ##NEW\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n                self.results_df.at[patient.id, \"Time Using Cubicle\"] = ( ##NEW\n                    self.env.now - end_q_cubicle\n                )\n\n                self.cubicle.release(cubicle_request) ##NEW\n\n        else: ##NEW\n\n            self.results_df.at[patient.id, \"Time Using Cubicle\"] = (  ##NEW\n                  self.env.now - end_q_cubicle\n                  )\n            self.cubicle.release(cubicle_request) ##NEW\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n        self.mean_q_time_cubicle = self.results_df[\"Q Time Cubicle\"].mean() ##NEW\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # EDIT: Omit patient-level results in this model\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Cubicle\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(1)) ##NEW: Added rounding\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse,\n                                              my_model.mean_q_time_doctor,\n                                              my_model.mean_q_time_cubicle ##NEW\n                                              ]\n\n        # Once the trial (ie all runs) has completed, add an additional column\n        self.df_trial_results['nurse_queue_longer'] = np.where(self.df_trial_results['Mean Q Time Nurse'] &gt; self.df_trial_results['Mean Q Time Cubicle'], True, False) ##NEW\n\n        # Print the final results\n        self.print_trial_results()\n\n        print(f\"Queue for nurse was longer than queue for cubicle in {sum(self.df_trial_results['nurse_queue_longer'].values)} trials of {g.number_of_runs}\")",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Requesting Multiple Resources Simultaneously</span>"
    ]
  },
  {
    "objectID": "requesting_multiple_resources.html#evaluating-the-outputs",
    "href": "requesting_multiple_resources.html#evaluating-the-outputs",
    "title": "18  Requesting Multiple Resources Simultaneously",
    "section": "18.3 Evaluating the outputs",
    "text": "18.3 Evaluating the outputs\n\n\n\n\n\n\nWarning\n\n\n\nWe haven’t fully controlled the randomness in our trials here, so the different trials will each have slightly differing arrival times and activity times. Even though we have run a high number of trials to compensate, this is not an ideal solution.\nFor information on how to properly control for randomness across trials, make sure to read the reproducibility section (Chapter 14).\n\n\n\n\n9 cubicles, 2 nurses, 2 doctors\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor  \\\nRun Number                                                             \n0                         0.6                3.3                30.4   \n1                         0.8               51.3                36.0   \n2                         1.6                3.9                24.5   \n3                         2.0               27.8                34.2   \n4                         1.0                4.2                16.0   \n...                       ...                ...                 ...   \n95                        1.2               28.5                37.4   \n96                        1.3               52.0                48.8   \n97                        0.8               24.3                41.8   \n98                        1.1               32.2                42.6   \n99                        1.4               29.1                46.9   \n\n            Mean Q Time Cubicle  nurse_queue_longer  \nRun Number                                           \n0                           4.4               False  \n1                          51.2                True  \n2                           2.4                True  \n3                          28.6               False  \n4                           0.5                True  \n...                         ...                 ...  \n95                         30.5               False  \n96                         54.9               False  \n97                         27.0               False  \n98                         34.3               False  \n99                         33.0               False  \n\n[100 rows x 5 columns]\nQueue for nurse was longer than queue for cubicle in 27 trials of 100\n\n\n\n\n3 cubicles, 2 nurses, 2 doctors\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor  \\\nRun Number                                                             \n0                         1.0              100.0                 4.1   \n1                         0.8              118.5                 4.8   \n2                         1.6              107.1                 4.7   \n3                         1.4               66.2                 4.3   \n4                         0.8               46.5                 2.5   \n...                       ...                ...                 ...   \n95                        0.7               74.5                 3.4   \n96                        1.5               55.4                 3.3   \n97                        0.7               66.6                 4.3   \n98                        1.1               53.6                 3.5   \n99                        0.7               28.5                 3.5   \n\n            Mean Q Time Cubicle  nurse_queue_longer  \nRun Number                                           \n0                         107.2               False  \n1                         127.3               False  \n2                         115.2               False  \n3                          73.3               False  \n4                          51.9               False  \n...                         ...                 ...  \n95                         80.9               False  \n96                         61.3               False  \n97                         73.7               False  \n98                         60.0               False  \n99                         34.5               False  \n\n[100 rows x 5 columns]\nQueue for nurse was longer than queue for cubicle in 0 trials of 100\n\n\n\n\n12 cubicles, 2 nurses, 2 doctors\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor  \\\nRun Number                                                             \n0                         1.1                1.6                36.6   \n1                         0.6                3.5                47.7   \n2                         1.1                2.5                11.2   \n3                         1.5                8.3                32.9   \n4                         2.2               29.8                81.2   \n...                       ...                ...                 ...   \n95                        2.1               50.9                63.8   \n96                        0.9               11.3                53.8   \n97                        0.8                1.2                16.3   \n98                        1.5                0.9                25.3   \n99                        1.2               22.4                78.2   \n\n            Mean Q Time Cubicle  nurse_queue_longer  \nRun Number                                           \n0                           0.4                True  \n1                           2.1                True  \n2                           0.0                True  \n3                           7.8                True  \n4                          33.7               False  \n...                         ...                 ...  \n95                         51.0               False  \n96                         11.3                True  \n97                          0.0                True  \n98                          0.4                True  \n99                         26.7               False  \n\n[100 rows x 5 columns]\nQueue for nurse was longer than queue for cubicle in 54 trials of 100\n\n\n\n18.3.1 Exploring the number of cubicles\nLet’s tweak our output to see the impact of changing the number of cubicles while keeping the number of receptionists, nurses and doctors consistent.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(1)) ##NEW: Added rounding\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse,\n                                              my_model.mean_q_time_doctor,\n                                              my_model.mean_q_time_cubicle\n                                              ]\n\n        # Once the trial (ie all runs) has completed, add an additional column\n        self.df_trial_results['nurse_queue_longer'] = np.where(self.df_trial_results['Mean Q Time Nurse'] &gt; self.df_trial_results['Mean Q Time Cubicle'], True, False)\n\n        return (sum(self.df_trial_results['nurse_queue_longer'].values) / g.number_of_runs) ##NEW\n\n\nresults = []\n\nfor num_cubicles in range(1, 20, 1):\n    g.number_of_cubicles = num_cubicles\n\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    trial_results = my_trial.run_trial()\n\n    results.append({\"Number of cubicles\": num_cubicles,\n      \"% of Trials with longer nurse queue time than cubicle queue time\": trial_results})\n\nresults_df = pd.DataFrame(results)\n\nresults_df\n\n\n\n\n\n\n\n\nNumber of cubicles\n% of Trials with longer nurse queue time than cubicle queue time\n\n\n\n\n0\n1\n0.00\n\n\n1\n2\n0.00\n\n\n2\n3\n0.00\n\n\n3\n4\n0.00\n\n\n4\n5\n0.03\n\n\n5\n6\n0.09\n\n\n6\n7\n0.18\n\n\n7\n8\n0.29\n\n\n8\n9\n0.35\n\n\n9\n10\n0.40\n\n\n10\n11\n0.46\n\n\n11\n12\n0.54\n\n\n12\n13\n0.62\n\n\n13\n14\n0.68\n\n\n14\n15\n0.72\n\n\n15\n16\n0.75\n\n\n16\n17\n0.71\n\n\n17\n18\n0.78\n\n\n18\n19\n0.81\n\n\n\n\n\n\n\n\nimport plotly.express as px\n\npx.line(\n  results_df,\n  x=\"Number of cubicles\",\n  y=\"% of Trials with longer nurse queue time than cubicle queue time\",\n  title=f\"Impact of cubicle numbers with {g.number_of_nurses} nurses\"\n  )\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nNow, our rate limiting step might actually be the number of doctors, as their consultations take longer on average (20 minutes on average with roughly 60% of patients needing to see a doctor after seeing the nurse; nurse consults take on average 6 minutes but every patient sees a nurse). Let’s fix the number of cubicles at 8 and look at the impact of changing the number of doctors instead.\n\ng.number_of_cubicles = 8\n\nresults = []\n\nfor num_doctors in range(1, 20, 1):\n    g.number_of_doctors = num_doctors\n\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    trial_results = my_trial.run_trial()\n\n    results.append({\"Number of doctors\": num_doctors,\n      \"% of Trials with longer nurse queue time than cubicle queue time\": trial_results})\n\nresults_df = pd.DataFrame(results)\n\nresults_df\n\n\n\n\n\n\n\n\nNumber of doctors\n% of Trials with longer nurse queue time than cubicle queue time\n\n\n\n\n0\n1\n0.00\n\n\n1\n2\n0.29\n\n\n2\n3\n0.87\n\n\n3\n4\n1.00\n\n\n4\n5\n1.00\n\n\n5\n6\n1.00\n\n\n6\n7\n1.00\n\n\n7\n8\n1.00\n\n\n8\n9\n1.00\n\n\n9\n10\n1.00\n\n\n10\n11\n1.00\n\n\n11\n12\n1.00\n\n\n12\n13\n1.00\n\n\n13\n14\n1.00\n\n\n14\n15\n1.00\n\n\n15\n16\n1.00\n\n\n16\n17\n1.00\n\n\n17\n18\n1.00\n\n\n18\n19\n1.00\n\n\n\n\n\n\n\n\npx.line(\n  results_df,\n  x=\"Number of doctors\",\n  y=\"% of Trials with longer nurse queue time than cubicle queue time\",\n  title=f\"Impact of doctor numbers with {g.number_of_nurses} nurses and {g.number_of_cubicles} cubicles\"\n  )\n\n                            \n                                            \n\n\nYou can see that with more doctors we very quickly start to see the number of nurses being the rate limiting factor rather than the number of nurses.\n\n\n\n\n\n\nNote\n\n\n\nTake a look at the chapter “Testing Large Numbers of Scenarios” (Chapter 41) to see how you could automatically try out different combinations of nurse, doctor and cubicle numbers to find the optiumum value.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Requesting Multiple Resources Simultaneously</span>"
    ]
  },
  {
    "objectID": "exercise_des_advanced.html",
    "href": "exercise_des_advanced.html",
    "title": "20  Exercise - Practicing Advanced Concepts",
    "section": "",
    "text": "In this section we’ve looked at how we can implement the following DES features in SimPy:\n\nSimulation warm-up.\nPriority-based queuing.\nResource unavailability.\nUse of the alternative distributions.\nReneging.\nBalking.\nEntities choosing queues based on queue length.\n\nDesign and build a DES model in SimPy that uses at least four of the features above.\nThe model can be of anything you like - you may choose to try to build the conceptual model you designed in the DES Design exercise at the end of section 1, or you might choose something completely different.",
    "crumbs": [
      "Part 3 - Extending Your Basic Model",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Exercise - Practicing Advanced Concepts</span>"
    ]
  },
  {
    "objectID": "part_4_intro.html",
    "href": "part_4_intro.html",
    "title": "21  An Introduction to Modelling Complex Real-World Systems",
    "section": "",
    "text": "21.1 The challenge now…\nAs you begin to model your first real-world systems, you may find yourself uncertain of the best approach to take to a problem, and seeking out the ‘right’ way to do something.\nWhile there are often rules of thumb and efficient or less efficient ways of doing things, there often isn’t a single answer to how you structure a solution.\nThe chapters that follow in this section will tend to give you an idea of how you might approach a situation, and some general rules of thumb to follow, but you should not be afraid of trying a different approach.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>An Introduction to Modelling Complex Real-World Systems</span>"
    ]
  },
  {
    "objectID": "part_4_intro.html#the-challenge-now",
    "href": "part_4_intro.html#the-challenge-now",
    "title": "21  An Introduction to Modelling Complex Real-World Systems",
    "section": "",
    "text": "Tip\n\n\n\nPart 5 will also be crucial for building your confidence in real-world systems, as it will help you to understand how you can build logging, testing and visualisation into various parts of your model to confirm that it is working in the way it should be.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>An Introduction to Modelling Complex Real-World Systems</span>"
    ]
  },
  {
    "objectID": "part_4_intro.html#what-do-i-do-if-what-i-need-isnt-covered-in-the-book",
    "href": "part_4_intro.html#what-do-i-do-if-what-i-need-isnt-covered-in-the-book",
    "title": "21  An Introduction to Modelling Complex Real-World Systems",
    "section": "21.2 What do I do if what I need isn’t covered in the book?",
    "text": "21.2 What do I do if what I need isn’t covered in the book?\n\n21.2.1 Check the SimPy documentation\nThe SimPy documentation is a rich resource for information on how to do things.\nhttps://simpy.readthedocs.io/en/latest/\nIt covers a range of things that we don’t yet touch on in the book, such as:\n\nInterrupting processes.\nBuilding custom events.\nWaiting for any of or all events before triggering a process.\nAdditional resource types, such as containers and stores.\n\n\n\n21.2.2 Experiment!\nThere’s no harm in trying things out!\nIt may take a while and a few false starts to get things working as expected, but that’s entirely normal - if your code works first time, that would be quite unusual!\nMake use of some of the debugging and logging tips to determine whether your approach is leading to events happening in the order expected and at the frequency expected.\nIf you’re having issues, check your indentation - this is a common thing to get wrong as your model gets more complex.\nMake sure you have a clean working copy of your original code saved to go back to (ideally tracked via version control on a platform like GitHub!) and make notes of the different approaches you have tried - it’s very easy to accidentally circle back to a non-working solution.\nFinally, don’t be afraid to step away from the code for a bit - you will often find that you will ruminate over the problem without even realising, and inspiration will strike when you least expect it.\n\n\n21.2.3 Check out StackOverflow\nStackOverflow is a long-running site where users post questions about coding problems.\nOften, relevant StackOverflow questions will come up near the top of a Google search on coding topics.\nYou can also ask questions yourself, though try to include a very clear description of your aim, your difficulty, what you have already tried to solve the problem yourself, and a ‘reproducible example’ (reprex) that someone trying to answer your question can run themselves to get them started.\n\n\n\n\n\n\nWarning\n\n\n\nTake the time to understand any code that is presented on StackOverflow and thoroughly test it to ensure it’s doing what it says it’s doing.\n\n\n\n\n21.2.4 Try using general AI\n\n\n\n\n\n\nWarning\n\n\n\nAll AI tools should be used with caution. They may give you wrong information, may suggest functions or functionality that doesn’t exist, and more. Take the time to understand any code that is generated by an AI tool and thoroughly test it to ensure it’s doing what it says it’s doing.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNever upload any sensitive data to one of these tools. Data is processed on external servers, potentially in other countries, and you may be in serious breach of the information governance rules of your organisation.\n\n\nAI chat assistants can be helpful coding buddies.\nChatGPT is often quite good at generating code and ideas, and can be used for free. Claude also gets good feedback for this purpose.\nPerplexity is good as it links back to the key sources in its answer, allowing you to interrogate them further.\nTools built in to your coding environment, like Github Copilot and Intellicode in VSCode, can also be of use.\n\n\n21.2.5 Try using a custom AI\nFor example, NotebookLM allows you to upload a series of custom resources, such as videos, websites and slides. Through this you could create an AI trained specifially on the HSMA lectures, this book, and the SimPy documentation, among other SimPy-specific sources.\n\n\n\n\n\n\nNote\n\n\n\nNote that if you are adding an ebook like this resource, or the documentation site of a library, you will need to add each page as a source individually, meaning you can quickly exceed the total number of sources allowed.\n\n\n\n\n21.2.6 Check out the SimPy issues on GitLab\nThe code for SimPy is hosted on GitLab.\nYou can take a look at previously raised issues to see if there is a known difficulty with what you are trying to do - it may be that what you are attempting to achieve is an actual limitation of the library.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>An Introduction to Modelling Complex Real-World Systems</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html",
    "href": "multiple_entity_types.html",
    "title": "22  An Introduction to Approaching Multiple Entity Types",
    "section": "",
    "text": "22.1 Approaches to managing arrivals\nLet’s imagine we want to model some more variety within the patients (entities) arriving in our model.\nMaybe patients are differentiated by something - their method of arrival, or the illness they have, or the severity of their symptoms, and consequently have:\nThe flexibility of simpy and Python does mean there are a range of ways we could approach coding this in.\nIn this chapter, we will give a bit of an introduction to how you might make decisions about:\nWhen we start having multiple types of patients, we will need to think about how we set them up in our system.\nWe could filter our historical data by patient type, work out the inter-arrival time between the ‘seriously injured’ patients and set up a generator for these patients, and then repeat this for the ‘mildly injured’ patients.\nHowever - you could instead have stuck with a single generator, like in our previous approaches throughout the book, but instead sampled whether the incoming patient is a ‘seriously injured’ or ‘mildly injured’ patient at the start of their journey based on known proportions of these patients.\nHow might we decide which of these approaches to use?\nYou may opt for different generators if\nThe authors of this book would generally steer away from having a different generator just for a different patient type or severity, and would instead use attributes to differentiate between the patients. These attributes can then be read when making decisions in the pathway, like where to go in a branch, or which distribution to sample from for an activity time instead.\nHowever, it’s perhaps not always clear cut! For example, our ‘seriously injured’ and ‘mildly injured’ patients above may have different arrival patterns throughout the day, with the seriously injured patients arriving during the morning and evening rush hours, and the mildly injured having a peak in the early evening. Again, we could go about this in multiple ways:",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>An Introduction to Approaching Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#approaches-to-managing-arrivals",
    "href": "multiple_entity_types.html#approaches-to-managing-arrivals",
    "title": "22  An Introduction to Approaching Multiple Entity Types",
    "section": "",
    "text": "Tip\n\n\n\nThe basic rule of thumb is have different generators if the entities - and/or what happens to them - is different if they come in via a different route.\n\n\n\n\n\nThe inter-arrival rate of that way of entering the system is fundamentally different (the most common reason), and/or\n\n\nIf you’re modelling a different pathway in the same modelled system (e.g. telephone calls coming in to the same system as patients turning up in person etc).\n\n\n\n\n\nwe could check the simulation time, then look up the probability of them being seriously injured vs mildly injured at that point in time (relating it back to real-world time), and sample accordingly\nwe could use two generators, using the method described in the variable arrival rates chapter.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>An Introduction to Approaching Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#multiple-patient-classes-versus-a-single-patient-class",
    "href": "multiple_entity_types.html#multiple-patient-classes-versus-a-single-patient-class",
    "title": "22  An Introduction to Approaching Multiple Entity Types",
    "section": "22.2 Multiple patient classes versus a single patient class",
    "text": "22.2 Multiple patient classes versus a single patient class\nSimilarly, when it comes to our patient classes, there are multiple ways we could handle it.\nWe could build multiple separate patient classes. For example, let’s imagine we have trauma patients and non-trauma patients in a system. A diagram of the system is shown below.\n\nIn this system, patients have a shared first step, but then move to very separate pathways. We have no need to track the waiting time for a ‘stabilisation waiting area’ for a non-trauma patient, as they will never use that resource.\nConsequently, we may opt to do the following.\n\nclass TraumaPatient:\n    def __init__(self, p_id):\n        self.id = p_id\n\n        self.q_time_recep = 0\n\n        self.q_time_stabilisation = 0\n        self.q_time_treatment = 0\n\nclass NonTraumaPatient:\n    def __init__(self, p_id):\n        self.id = p_id\n\n        self.q_time_recep = 0\n\n        self.q_time_registration = 0\n        self.q_time_examination = 0\n        self.q_time_treatment = 0\n\nWe could use the concept of inheritance to have a main patient class, then have multiple ‘child’ classes who inherit the properties of the parent class while also recording their own special attributes, with the different processes generating the relevant patient type. You can read more about inheritance in this chapter of the HSMA Python Book. We may opt to do this in cases where our patients share a few attributes, but not all of them.\n\nclass Patient(self, p_id):\n    # Here we can set up any attributes that are common across all of our\n    # patient types\n    self.id = p_id\n    self.q_time_recep = 0\n\nclass TraumaPatient(Patient):\n    def __init__(self, p_id):\n        # This calls the constructor of the parent (super), and passes the\n        # patient ID across to it\n        super().__init__(p_id)\n\n        self.q_time_stabilisation = 0\n        self.q_time_treatment = 0\n\nclass NonTraumaPatient(Patient):\n    def __init__(self, p_id):\n        super().__init__(p_id)\n\n        self.q_time_registration = 0\n        self.q_time_examination = 0\n        self.q_time_treatment = 0\n\nHowever, if our patients are following the same or a sufficiently similar route that means that the attributes of the patient classes don’t substantially change, it is often simpler to add an additional attribute that we set when initialising a patient to track their ‘type’, allowing us to then filter and subset patient groups in our results. This is similar to what is done in the priority resources chapter.\nIn this case, let’s imagine we have two patients of different severities. Patients of a higher severity arrive less frequently but use resources for longer. We may set this up in the following way.\n\nclass Patient:\n    def __init__(self, p_id, severity):\n        self.id = p_id\n\n        self.severity = severity\n\n        self.q_time_recep = 0\n        self.q_time_doctor = 0\n\nThis means that when the patient is set up, it requires two attributes - the ID, as we have done throughout the book so far, and the severity.\nThis approach is itself quite flexible - you could sample the severity when generating the patient, or choose to make the severity a parameter that is passed through in your generator method, allowing you to create patients of a given severity or type in that way. This is demonstrated in the next chapter.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>An Introduction to Approaching Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html",
    "href": "example_multiple_entity_types_similar_pathways.html",
    "title": "23  Example - Multiple Entity Types",
    "section": "",
    "text": "23.1 The approach\nIn this case, we will be wanting to set up a generator for each of the new types of patients we opt to add to this model.\nIn this case, we are going to have patients arriving via different routes: telephone, walk-ins, and ambulance.\nHowever, before we kick off, it will save us time down the road if we first improve the way the model handles randomness. Full details can be found in the reproducibility chapter, but we will cover the key changes in this section as well.\nIn this example, we will be:\nIn short, what we will need do in our model is:",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#the-approach",
    "href": "example_multiple_entity_types_similar_pathways.html#the-approach",
    "title": "23  Example - Multiple Entity Types",
    "section": "",
    "text": "Telephone patients will ‘arrive’ frequently, only spend a short time with a nurse, and have a low probability of needing to see the doctor.\nWalk-in patients will arrive less frequently, spend more time with a nurse than the doctor, and have a medium probability of needing to see the doctor.\nAmbulance patients will arrive even less frequently, spend a short amount of time with the nurse, then always visit the doctor and spend a long time with them.\n\n\n\n\n\n\n\nWarning\n\n\n\nIn this version of our system, we will not be implementing any sort of prioritisation - instead, patients will be seen in the order they arrive (FIFO).\nIt would be more realistic to implement priority-based queueing, with our ambulance patients jumping to the front of the queue, but this is outside the scope of this chapter. Take a look at the priority-based queueing chapter if you would like to find out more about implementing this.\n\n\n\n\n\nKeeping a single patient class and using an attribute to differentiate between them (as their pathways are very similar).\nUsing multiple generators (as each different type of patient has their own inter-arrival time).\n\n\n\nAdd additional attributes to our g class for our different types of patients.\nAdd an additional attribute to our patient class to track the type of patient they are.\nMove the setup of our sampling distributions into our model class.\nAdjust our patient generator function to pull in the appropriate inter-arrival time for the patient type.\nAdjust our patient journey function to pull in the appropriate sampling distribution for each patient type.\nAdjust our model run function to multiple generators that will cause our different patient types to arrive at the appropriate rate.\nUpdate our outputs and visualisations to check our different patient classes are working as expected.\n\n\n\n\n\n\n\nWarning\n\n\n\nRemember - this is just one way of tackling this!",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#coding-the-model",
    "href": "example_multiple_entity_types_similar_pathways.html#coding-the-model",
    "title": "23  Example - Multiple Entity Types",
    "section": "23.2 Coding the model",
    "text": "23.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n23.2.1 Imports\nAs mentioned before, we will be taking the opportunity to better control the randomness of our model runs while we are making this change - so we will import the Exponential and Uniform distribution functions from the sim_tools library written by Tom Monks .\n\n\n\n\n\n\nTip\n\n\n\nIf you don’t already have sim-tools in your environment, install it with pip install sim-tools.\nNote that we use a hyphen in the package name when installing it, but an underscore when importing it into our script.\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential, Uniform ##NEW\n\n\n\n23.2.2 g class\nWe need to add a few additional parameters to our g class.\nAs the number of parameters in our g class continues to increase, it can be worth reordering them and splitting them up with some comments to make it easier to find the parameters we are interested in.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    # Simulation Parameters\n    sim_duration = 60 * 8\n    number_of_runs = 5\n\n    # Shared Parameters between patient classes\n1    mean_reception_time = 2\n\n    # Resource Numbers\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n\n    # -- Entity and Inter-arrival Time Parameters -- #\n\n    # Patients Arriving By Ambulance\n2    entity_1 = {\n3        'label': 'ambulance',\n4        'mean_inter_arrival_time': 25,\n        'mean_n_consult_time': 5,\n        'mean_d_consult_time': 45,\n        'prob_seeing_doctor': 1.0\n    }\n\n    # Walk-in Patients\n5    entity_2 = {\n        'label': 'walkin',\n        'mean_inter_arrival_time': 15,\n        'mean_n_consult_time': 10,\n        'mean_d_consult_time': 20,\n        'prob_seeing_doctor': 0.6\n    }\n\n    # Telephone Patients\n    entity_3 = {\n        'label': 'telephone',\n        'mean_inter_arrival_time': 5,\n        'mean_n_consult_time': 8,\n        'mean_d_consult_time': 10,\n        'prob_seeing_doctor': 0.2\n    }\n\n\n1\n\nIn this case, we will have all of our patients having the same average time spent with the receptionist. Therefore, we can set this parameter up in the usual way.\n\n2\n\nWe are going to structure our parameters per entity type (here, with each entity being a type of patient). We will use a dictionary with the parameter name as a key and the parameter value as the associated value. We could have instead structured this as a dictionary per parameter, with the keys being the entity types and the values being the associated parameter value. We have used the variable name of the form ‘entity_x’ rather than ‘ambulance_patient’, for example. This means our patient type labels are easy to change later as we will simply change the ‘label’ entry for the entity, and not have to make changes to the name of the variable itself in our code.\n\n3\n\nHere, we set our patient type label. This will be used to identify and pull back the correct values for the patient throughout, so they must be different for each entity type.\n\n4\n\nWhile each entity dictionary does not have to have all keys, where they are used across multiple entity types, you should keep the naming consistent.\n\n5\n\nWe repeat the same structure for as many different entity types as we wish to define.\n\n\n\n\n\n\n23.2.3 Patient class\nIn our patient class, we’re going to add a new label that will relate to the type of our patients. We will pass this in when initialising the patients later on.\nWhile it’s not strictly related to our current model, we are also going to add in a new ‘seen_doctor’ parameter to help us with debugging our model later. This will initialise to False - a boolean value.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, type):\n        self.id = p_id\n\n        self.type = type ##NEW\n\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.seen_doctor = False ##NEW\n        self.q_time_doctor = 0\n\n\n\n23.2.4 Model class\n\n23.2.4.1 The init method\nLet’s now start setting up our model class.\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n1        self.results_df[\"Patient type\"] = [\"\"] ##NEW\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Sees Doctor\"] = [False]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Completed Journey\"] = [False]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n2        self.initialise_distributions()\n\n\n1\n\nWe add in an additional column in our dataframe where we will store the patient type. This wll help us to summarise results for different patient groups later.\n\n2\n\nThis is a new function - we will define this shortly.\n\n\n\n\n\n\n23.2.4.2 A new method - initialise_distributions\nAs we have so many distributions, it would be helpful to set up the distributions in their own function rather than putting all of this in the init method.\n\n\n\n\n\n\nNote\n\n\n\nOne of the big changes here is that, unlike our simple models in earlier chapters, we will be setting up our sampling distributions here too. The approach we are using here has strong benefits for reproducibility of your models and ensuring your conclusions on the impact of parameter changes are valid.\nTo see how this is done with a single patient class, head over to the reproducibility chapter. You may find it easier to understand the changes made in this chapter if you read that chapter first.\nThe way we will be setting up a sampling distribution follows a repeatable pattern.\n\nself.patient_inter_arrival_dist = Exponential(\n    mean = g.patient_inter,\n    random_seed = self.run_number * 2\n    )\n\n\nself.patient_reception_time_dist = Exponential(\n    mean = g.mean_reception_time,\n    random_seed = self.run_number * 3\n    )\n\nThen, when we wish to pull back a value from this distribution, we use\n\nself.patient_reception_time_dist.sample()\n\nself.patient_reception_time_dist.sample()\n\nBy using the run number as part of the random seed, we can ensure reproducibility across the same run in different trials.\nThis is crucial for us determining and demonstrating that changes to the parameters are responsible for better or worse system performance - not just randomness.\nTo avoid getting identical numbers in the instance that we had two distributions with the same mean, we multiply the random seed by a number. It doesn’t matter what the number is (as long as you’re not randomly generating it in the code!).\n\n\n\n    def initialise_distributions(self):\n\n1        self.patient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n2                mean = g.entity_1['mean_inter_arrival_time'],\n4                random_seed = self.run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n3                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = self.run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = self.run_number * 4\n                )\n\n        }\n\n        # In this model, all patients have the same distribution for the time they spend with\n        # a receptionist, so we can set up a single distribution instead of a dictionary\n        # of distributions\n5        self.patient_reception_time_dist = Exponential(\n                mean = g.mean_reception_time,\n                random_seed = self.run_number * 5\n                )\n\n        # The time spent with the nurses, with the doctors, and the probability of seeing a\n        # doctor all differ between our tiers of patients, so we need to set up dictionaries of\n        # distributions like with the\n        self.nurse_consult_time_dist = { {6}\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_n_consult_time'],\n                random_seed = self.run_number * 6\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_n_consult_time'],\n                random_seed = self.run_number * 7\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_n_consult_time'],\n                random_seed = self.run_number * 8\n                )\n\n        }\n\n6        self.doctor_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_d_consult_time'],\n                random_seed = self.run_number * 9\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_d_consult_time'],\n                random_seed = self.run_number * 10\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_d_consult_time'],\n                random_seed = self.run_number * 11\n                )\n\n        }\n\n7        self.doctor_prob_seeing_dist = Uniform(\n            low=0.0,\n            high=1.0,\n            random_seed = self.run_number * 12\n            )\n\n8        self.doctor_probs_seeing = {\n            g.entity_1['label']: g.entity_1['prob_seeing_doctor'],\n            g.entity_2['label']: g.entity_2['prob_seeing_doctor'],\n            g.entity_3['label']: g.entity_3['prob_seeing_doctor']\n        }\n\n\n1\n\nNext, we need to set up our inter-arrival time distributions.\n\n2\n\nFor the mean, by having a single attribute but setting these up as a dictionary, we will be able to access the relevant distribution with self.patient_inter_arrival_dist['ambulance'], replacing ‘ambulance’ with the tier of patient (or, in a different model, whichever identifier we have opted to use for our different patients)\n\n3\n\nFor the random seed, we will use the run number to ensure reproducibility across runs, but we will multiply it by some other value (which is random in the sense that it doesn’t matter what it is, but non-random in that we have chosen it and do not vary it across runs). By making it different for different distributions, we avoid the possibility of having different distributions that have the same mean and same set of randomly generated numbers in the same order.\n\n4\n\nWe then repeat this, making sure we pull back the value from our tier 2 patients this time.\n\n5\n\nFinally, we repeat for our tier 3 patients. We could repeat this for as many patient classes as we wished.\n\n6\n\nThe nurse and doctor consult times follow a similar pattern to the inter-arrival times\n\n7\n\nThe distribution for determining whether our patients will see a doctor will be a uniform distribution. Here, there is an equal probability of any value between our ‘high’ and ‘low’ threshold being chosen. The same uniform distribution can be used regardless of our patient type.\n\n8\n\nThis code may seem quite unneccesary - why not just pull back the relevant entity value when we need it? While that would work, it will allow our code to be neater and more consistent overall if we set up this dictionary here, as like with any other of our parameters, we can then pull back the required threshold value by using the standard pattern of self.doctor_probs_seeing[patient.severity], rather than having to do something like a series of conditional logic checks that return the correct entity from our g class.\n\n\n\n\n\n\n\n\n\n\nUnderstanding how these dictionaries work\n\n\n\n\n\nLet’s print the output of one of these dictionaries so you can see the effect of passing in our entity label as the parameter.\n\nrun_number = 1\n\npatient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_inter_arrival_time'],\n                random_seed = run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = run_number * 4\n                )\n\n        }\n\npatient_inter_arrival_dist\n\n{'ambulance': &lt;sim_tools.distributions.Exponential at 0x7f01c649e920&gt;,\n 'walkin': &lt;sim_tools.distributions.Exponential at 0x7f0258807f10&gt;,\n 'telephone': &lt;sim_tools.distributions.Exponential at 0x7f01c64e80a0&gt;}\n\n\nI can now pull back and sample from these distributions.\n\npatient_inter_arrival_dist['ambulance']\n\n&lt;sim_tools.distributions.Exponential at 0x7f01c649e920&gt;\n\n\n\npatient_inter_arrival_dist['ambulance'].sample()\n\n3.2465284000996624\n\n\nLet’s imagine I’ve initiated a patient. Now, I can pass in the type attribute of that patient to pull back the correct distribution.\n\nmy_example_patient = Patient(p_id=123, type=\"telephone\")\n\npatient_inter_arrival_dist[my_example_patient.type].sample()\n\n18.994133312745088\n\n\n\n\n\n\n\n23.2.4.3 The generator_patient_arrivals method\nHere, the key thing we need to do is make it possible to vary the inter-arrival time depending on the class of patient we are working with - as we have just demonstrated above.\nWe will call this method three times later in our code - one per type of patient. You could call it as many times as needed for different patients, or even do this in a loop if you had an unusually large number of entities (though we would caution against this - you should consider whether you model should be simplified or whether separate entity generators are actually the most appropriate way to approach your problem).\n\n# A generator function that represents the DES generator for patient\n    # arrivals\n1    def generator_patient_arrivals(self, patient_type):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n2            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n3            p = Patient(self.patient_counter, patient_type)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n4            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n5            sampled_inter = self.patient_inter_arrival_dist[patient_type].sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n6            yield self.env.timeout(sampled_inter)\n\n\n1\n\nWe begin by adding an extra parameter that will get passed into our patient generator method. By passing in ‘ambulance’, ‘walkin’ or ‘telephone’, we will be able to look up the appropriate inter-arrival time and ensure we set up our patient objects with the correct type indicator.\n\n2\n\nAs we have defined the patient counter at the model level, we will not end up with overlapping IDs across our different patient severities - they will remain unique.\n\n3\n\nHere, we will pass in the patient type to the patient constructor so that it can be added as a patient attribute.\n\n4\n\nOur attend_clinic method will be updated to cope with patients of different type and pull back the correct values. Alternatively, if our patients of different type had substantially different pathways, we may wish to define different attend_clinic methods and use conditional logic here to determine which pathway they will be sent down; however, in this case, our pathways are the same, so we do not need to do this.\n\n5\n\nRemember - our attribute self.patient_inter_arrival_dist is now a dictionary. By passing in the patient type as our ‘key’, it will look up the correct distribution from our self.patient_inter_arrival_dist automatically. We then use the ‘sample()’ method to get out an appropriate inter-arrival time for that type of patient.\n\n6\n\nAs before, we pass this inter-arrival time to the self.env.timeout() method. This will pause the patient-generating process in place for this type of patient until the sampled time has elapsed - but during this time patients of other severities will continue to be generated, and patients will progress through their pathways appropriately.\n\n\n\n\n\n\n23.2.4.4 The attend_clinic method\nLet’s start working through the changes to the method where the patients move through the system.\nTo start with, they see a receptionist. All patients have the same distribution for this regardless of their type; however, we do need to ensure we are sampling from this distribution in the correct way.\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n\n1        self.results_df.at[patient.id, \"Patient type\"] = (\n                 patient.type\n            )\n\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n2            sampled_recep_act_time = self.patient_reception_time_dist.sample()\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n    # Here's where the patient finishes with the receptionist, and starts queuing for the nurse\n\n\n1\n\nFirst, let’s ensure we record the type of our patients against their entry in the dataframe when they enter the system.\n\n2\n\nWe are going to use the .sample() method of our patient_reception_time_dist to pull back a number from our distribution. Everything else in this section of the code is unchanged.\n\n\n\n\nLet’s continue - for the nurse and doctor steps, it will be similar, but we will need to select the correct distribution depending on the patient type.\nRemember - the patient object we have passed in has a ‘type’ attribute that will match the key of one of the entries in the relevant dictionary of distributions.\nWe’ll look at the nurse step next.\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n1            sampled_nurse_act_time = self.nurse_consult_time_dist[patient.type].sample()\n\n            # Here we'll store the queuing time for the nurse and the sampled time to spend with\n            # the nurse in the results DataFrame against the ID for this patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled above.\n            # This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n\n1\n\nHere, we pass in the type attribute of the patient who is currently going through the model to filter our dictionary of nurse consult time distributions. If the label was, for example, ‘ambulance’, we’d get the distribution for our most severe, tier 1 patients. We then sample from this, getting an appropriate length of time for this type of patient to spend with the nurse.\n\n\n\n\nAnd finally, let’s look at the doctor step. Here, we will need to sample twice - once to see whether the patient actually needs to the see the doctor, and if they do, we sample from a different distribution to get the length of time spent with the doctor.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system\n1        if self.doctor_prob_seeing_dist.sample() &lt; self.doctor_probs_seeing[patient.type]:\n            start_q_doctor = self.env.now\n\n            self.results_df.at[patient.id, \"Sees Doctor\"] = True\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n2                sampled_doctor_act_time = self.doctor_consult_time_dist[patient.type].sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n        else:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = False\n\n        self.results_df.at[patient.id, \"Completed Journey\"] = True\n\n\n1\n\nHere, we sample from our uniform distribution, and compare it with the relevant value for our patient depending on their type.\n\n2\n\nThis time, we sample from our exponential distribution, again selecting the correct distribution using the patient type.\n\n\n\n\n\n\n23.2.4.5 The calculate_run_results method\nFor now, we will leave this unchanged. This means our averages will be for the whole cohort, not for the different severities of patients - however, we can calculate the latter using the patient-level\n\n\n23.2.4.6 The run method\nThe key change to the run method is that we will start up three different patient generators. Previously, we have just passed in one.\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients\n1        self.env.process(self.generator_patient_arrivals(g.entity_1['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_2['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_3['label']))\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Return the patient-level results from this run of the model\n        return self.results_df\n\n\n1\n\nFor each entity type, we now set up a separate process to generate them. By passing in the entity label to use here, the label - which in this case we are using to indicate type, but could be any characteristic that separates your patients -",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#the-full-code",
    "href": "example_multiple_entity_types_similar_pathways.html#the-full-code",
    "title": "23  Example - Multiple Entity Types",
    "section": "23.3 The full code",
    "text": "23.3 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential, Uniform ##NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    # Simulation Parameters\n    sim_duration = 60 * 8\n    number_of_runs = 5\n\n    # Shared Parameters between patient classes\n    mean_reception_time = 2\n\n    # Resource Numbers\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n\n    # -- Entity and Inter-arrival Time Parameters -- #\n\n    # Tier 1 Patients - Very Ill\n    entity_1 = {\n        'label': 'ambulance',\n        'mean_inter_arrival_time': 25,\n        'mean_n_consult_time': 5,\n        'mean_d_consult_time': 45,\n        'prob_seeing_doctor': 1.0\n    }\n\n    # Tier 2 Patients - Somewhat Ill\n    entity_2 = {\n        'label': 'walkin',\n        'mean_inter_arrival_time': 15,\n        'mean_n_consult_time': 10,\n        'mean_d_consult_time': 20,\n        'prob_seeing_doctor': 0.6\n    }\n\n    # Tier 3 Patients - Mildly Ill\n    entity_3 = {\n        'label': 'telephone',\n        'mean_inter_arrival_time': 5,\n        'mean_n_consult_time': 8,\n        'mean_d_consult_time': 10,\n        'prob_seeing_doctor': 0.2\n    }\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, type):\n        self.id = p_id\n\n        self.type = type\n\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.seen_doctor = False ##NEW\n        self.q_time_doctor = 0\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Patient type\"] = [\"\"] ##NEW\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Sees Doctor\"] = [False]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Completed Journey\"] = [False]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        self.initialise_distributions()\n\n    def initialise_distributions(self):\n\n        self.patient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_inter_arrival_time'],\n                random_seed = self.run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = self.run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = self.run_number * 4\n                )\n\n        }\n\n        # In this model, all patients have the same distribution for the time they spend with\n        # a receptionist, so we can set up a single distribution instead of a dictionary\n        # of distributions\n        self.patient_reception_time_dist = Exponential(\n                mean = g.mean_reception_time,\n                random_seed = self.run_number * 5\n                )\n\n        # The time spent with the nurses, with the doctors, and the probability of seeing a\n        # doctor all differ between our tiers of patients, so we need to set up dictionaries of\n        # distributions like with the\n        self.nurse_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_n_consult_time'],\n                random_seed = self.run_number * 6\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_n_consult_time'],\n                random_seed = self.run_number * 7\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_n_consult_time'],\n                random_seed = self.run_number * 8\n                )\n\n        }\n\n        self.doctor_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_d_consult_time'],\n                random_seed = self.run_number * 9\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_d_consult_time'],\n                random_seed = self.run_number * 10\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_d_consult_time'],\n                random_seed = self.run_number * 11\n                )\n\n        }\n\n        self.doctor_prob_seeing_dist = Uniform(\n            low=0.0,\n            high=1.0,\n            random_seed = self.run_number * 12\n            )\n\n        self.doctor_probs_seeing = {\n            g.entity_1['label']: g.entity_1['prob_seeing_doctor'],\n            g.entity_2['label']: g.entity_2['prob_seeing_doctor'],\n            g.entity_3['label']: g.entity_3['prob_seeing_doctor']\n        }\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self, patient_type):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter, patient_type)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist[patient_type].sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n\n        self.results_df.at[patient.id, \"Patient type\"] = (\n                 patient.type\n            )\n\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample()\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n    # Here's where the patient finishes with the receptionist, and starts queuing for the nurse\n\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            sampled_nurse_act_time = self.nurse_consult_time_dist[patient.type].sample()\n\n            # Here we'll store the queuing time for the nurse and the sampled time to spend with\n            # the nurse in the results DataFrame against the ID for this patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled above.\n            # This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system\n        if self.doctor_prob_seeing_dist.sample() &lt; self.doctor_probs_seeing[patient.type]:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = True\n\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.doctor_consult_time_dist[patient.type].sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n        else:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = False\n\n        self.results_df.at[patient.id, \"Completed Journey\"] = True\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients\n        self.env.process(self.generator_patient_arrivals(g.entity_1['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_2['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_3['label']))\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Return the patient-level results from this run of the model\n        return self.results_df",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#checking-our-implementation",
    "href": "example_multiple_entity_types_similar_pathways.html#checking-our-implementation",
    "title": "23  Example - Multiple Entity Types",
    "section": "23.4 Checking our implementation",
    "text": "23.4 Checking our implementation\nUsually we would go on to run a trial (several runs with the same set of parameters but variation in the samples picked from our different distributions to simulate different realities within our simulation) - but for now, we’ll just look at the output of a single run of our new model so that we can verify that everything is working as expected.\nFirst, let’s get back and inspect our patient-level results dataframe. This has one row per patient.\n\nmy_model = Model(run_number=1)\n\npatient_level_results = my_model.run()\n\npatient_level_results.head(20).round(2)\n\n\n\n\n\n\n\n\nPatient type\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\nambulance\n0.00\n3.97\n0.00\n3.46\nTrue\n0.00\n148.00\nTrue\n\n\n2\nwalkin\n3.97\n1.50\n1.96\n7.08\nFalse\nNaN\nNaN\nTrue\n\n\n3\ntelephone\n5.47\n2.60\n6.43\n4.30\nTrue\n0.00\n2.30\nTrue\n\n\n4\nwalkin\n6.43\n1.06\n9.67\n10.25\nTrue\n0.00\n15.49\nTrue\n\n\n5\nambulance\n5.89\n0.06\n19.87\n0.92\nTrue\n14.57\n22.21\nTrue\n\n\n6\nwalkin\n1.70\n0.87\n19.91\n5.69\nTrue\n31.10\n9.30\nTrue\n\n\n7\nambulance\n1.35\n1.28\n24.32\n3.01\nTrue\n37.38\n42.34\nTrue\n\n\n8\ntelephone\n0.00\n0.23\n19.45\n11.58\nTrue\n68.15\n5.38\nTrue\n\n\n9\ntelephone\n0.00\n0.12\n28.99\n4.13\nFalse\nNaN\nNaN\nTrue\n\n\n10\nambulance\n0.00\n2.00\n30.83\n2.68\nTrue\n66.72\n44.94\nTrue\n\n\n11\nwalkin\n0.00\n2.18\n26.40\n8.95\nTrue\n89.41\n37.65\nTrue\n\n\n12\ntelephone\n0.00\n2.33\n26.34\n25.07\nFalse\nNaN\nNaN\nTrue\n\n\n13\ntelephone\n1.63\n0.46\n50.95\n6.31\nTrue\n71.33\n11.22\nTrue\n\n\n14\nambulance\n0.90\n4.36\n52.90\n3.67\nTrue\n78.88\n36.13\nTrue\n\n\n15\ntelephone\n1.74\n2.86\n53.71\n2.36\nFalse\nNaN\nNaN\nTrue\n\n\n16\ntelephone\n0.63\n4.03\n52.05\n8.71\nFalse\nNaN\nNaN\nTrue\n\n\n17\ntelephone\n1.59\n1.04\n59.72\n0.57\nFalse\nNaN\nNaN\nTrue\n\n\n18\ntelephone\n0.00\n0.17\n55.16\n0.22\nFalse\nNaN\nNaN\nTrue\n\n\n19\ntelephone\n0.00\n0.88\n51.18\n4.38\nFalse\nNaN\nNaN\nTrue\n\n\n20\nwalkin\n0.26\n1.14\n54.42\n2.07\nTrue\n73.71\n8.95\nTrue\n\n\n\n\n\n\n\nWe can now check the average time spent at each stage.\n\n(\n    patient_level_results.reset_index()\n    .groupby('Patient type')\n    .agg({\n        'Patient ID': 'count',\n        'Time with Recep': 'mean',\n        'Time with Nurse': 'mean',\n        'Sees Doctor': 'mean',\n        'Time with Doctor': 'mean'\n    })\n    .round(2)\n)\n\n\n\n\n\n\n\n\nPatient ID\nTime with Recep\nTime with Nurse\nSees Doctor\nTime with Doctor\n\n\nPatient type\n\n\n\n\n\n\n\n\n\nambulance\n23\n1.73\n3.81\n1.0\n64.81\n\n\ntelephone\n90\n2.04\n6.19\n0.243243\n7.11\n\n\nwalkin\n37\n1.80\n10.72\n0.388889\n23.09\n\n\n\n\n\n\n\nThese numbers look pretty good - we aren’t seeing much variation across the time patients spend with the receptionist, but we are seeing expected variation across the time they spent with the nurse and the doctor, as well as the probability of them seeing the doctor.\n\n\n\n\n\n\nNote\n\n\n\nIn our results dataframe, we stored whether patients saw the doctor or not as a boolean value (True or False).\nTrue is interpreted as 1, whereas False is interpreted as 0.\nWhen we take a mean of a boolean column, we can get an idea of the number of patients who have or have not done something, with values closer to 1 meaning more patients had a value of ‘True’.\nSo here, a value of ‘1.0’ would mean all patients of that type saw a doctor.\nA value of ‘0.24’ would mean 24% of patients (24 in 100) of that type saw a doctor.\n\n\nHowever, if queues build up in the system, or if our simulation is not long enough for a ambulance proportion of the patients who start their journeys to actually make their whole journey through, we may find that some patients in our list haven’t finished their journey before they exit and this may make figures for later parts of the patient journey look a bit strange. Let’s rerun this after filtering to only include patients who finished their full journey and exited the system.\n\n(\n    patient_level_results[patient_level_results[\"Completed Journey\"] == True].reset_index()\n    .groupby('Patient type')\n    .agg({\n        'Patient ID': 'count',\n        'Time with Recep': 'mean',\n        'Time with Nurse': 'mean',\n        'Sees Doctor': 'mean',\n        'Time with Doctor': 'mean'\n    })\n    .round(2)\n)\n\n\n\n\n\n\n\n\nPatient ID\nTime with Recep\nTime with Nurse\nSees Doctor\nTime with Doctor\n\n\nPatient type\n\n\n\n\n\n\n\n\n\nambulance\n13\n1.56\n3.64\n1.0\n44.79\n\n\ntelephone\n37\n1.81\n5.74\n0.243243\n7.11\n\n\nwalkin\n17\n1.74\n10.92\n0.352941\n22.56\n\n\n\n\n\n\n\n\n23.4.1 Exploring this with graphs\nWe can also take a look at all of these figures in a more visual way.\nTo start with, we need to alter the structure of our dataframe slightly.\n\n1import plotly.express as px\n\ntimes_df = (\n2    patient_level_results[['Patient type','Time with Recep', 'Time with Nurse', 'Time with Doctor']]\n3    .reset_index()\n    )\n\n4times_df_long = times_df.melt(\n    id_vars=[\"Patient ID\", \"Patient type\"]\n    )\n\ntimes_df_long.head(10)\n\n\n1\n\nWe’ll import the plotly.express module. Plotly express gives us simplified functions for building interactive graphs.\n\n2\n\nWe use the [[]] syntax and pass it a list of column names to pull back just a subset of columns.\n\n3\n\nResetting the index - where the index was our Patient ID, turns this from a special type of Pandas column called an index into a regular dataframe column that we can access.\n\n4\n\nMelting a dataframe turns it from a ‘wide’ format - with one row per patient - to a ‘long’ format. We want one row per variable, so we will have multiple rows per patient - a row for each different time. You will see shortly why this is necessary for passing the dataframe into plotly.\n\n\n\n\n\n\n\n\n\n\n\nPatient ID\nPatient type\nvariable\nvalue\n\n\n\n\n0\n1\nambulance\nTime with Recep\n3.973340\n\n\n1\n2\nwalkin\nTime with Recep\n1.500383\n\n\n2\n3\ntelephone\nTime with Recep\n2.602708\n\n\n3\n4\nwalkin\nTime with Recep\n1.058856\n\n\n4\n5\nambulance\nTime with Recep\n0.060305\n\n\n5\n6\nwalkin\nTime with Recep\n0.867850\n\n\n6\n7\nambulance\nTime with Recep\n1.284329\n\n\n7\n8\ntelephone\nTime with Recep\n0.230440\n\n\n8\n9\ntelephone\nTime with Recep\n0.115646\n\n\n9\n10\nambulance\nTime with Recep\n2.001424\n\n\n\n\n\n\n\nNow we can display this as a box plot.\n\n1px.box(\n2    times_df_long,\n3    y=\"variable\",\n4    x=\"value\",\n5    color=\"Patient type\"\n)\n\n\n1\n\nWe ask plotly for a box plot (also known as a box-and-whisker plot or a tukey plot). This kind of plot is valuable for showing the spread of values, along with the average.\n\n2\n\nWe pass in our reshaped dataframe.\n\n3\n\nWe put our variables - the metric names - on the vertical axis. Placing them on the vertical axis generally makes them easier to read.\n\n4\n\nWe put our numeric values on the horizontal axis.\n\n5\n\nWe then ask for the values to be coloured by patient type.\n\n\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nThe plot above makes it easy for us to see how the average time - and the spread of times - varies for different patient groups.\nLet’s look at this a different way to instead focus on the difference between times within a type of patient.\n\n(\n    px.box(\n    times_df_long,\n    y=\"variable\",\n    x=\"value\",\n    facet_row=\"Patient type\")\n    .update_yaxes(title_text=\"\")\n    .for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1], y=1.05))\n)",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#adding-in-the-trial",
    "href": "example_multiple_entity_types_similar_pathways.html#adding-in-the-trial",
    "title": "23  Example - Multiple Entity Types",
    "section": "23.5 Adding in the trial",
    "text": "23.5 Adding in the trial\nFinally, now we’re happy thaat this is working at the level of a single run, let’s see what changes we need to make to our trial class.\nBelow is the trial class in its existing form.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ##NEW\n        print(\"\") ##NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nLet’s see what happens when we run this now.\n\n# Create an i#| nstance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              131.0               3.78             140.14                0.79\n1              150.0               2.20             115.32               36.08\n2              162.0               2.40             159.47                0.00\n3              143.0               2.13             146.57                2.11\n4              145.0               2.10             124.95               22.42\nArrivals              146.20\nMean Q Time Recep       2.52\nMean Q Time Nurse     137.29\nMean Q Time Doctor     12.28\ndtype: float64\n\n\nThis is working fine if we just want to get an overall sense of the queues at each step in our model, regardless of our type.\nHowever, it doesn’t give us much insight into our different patient groups over the course of multiple runs.\nTo change this, we could go back through our model class and ensure we start recording the metrics separately for each class of patient.\nHowever, this is time-consuming and can be inefficient if we later want to add additional steps, metrics or patient types to our model.\nInstead, for each run, we will output the patient-level results we were working with earlier, and then use pandas dataframe functions to pull out different metrics.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    def  __init__(self):\n        self.patient_dataframes = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ##NEW\n        print(\"\") ##NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run_number=run)\n            patient_level_results = my_model.run()\n            patient_level_results.insert(\n                loc=0,\n                column=\"Run\",\n                value=run+1\n                )\n\n            self.patient_dataframes.append(patient_level_results)\n\n        # Once the trial (ie all runs) has completed, turn this into a single dataframe\n        # and return it\n        return pd.concat(self.patient_dataframes)\n\nLet’s run this code and view the first 10 rows of the trial-level output.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nall_results = my_trial.run_trial()\n\nall_results.head(10).round(2)\n\n1 receptionists, 1 nurses, 2 doctors\n\n\n\n\n\n\n\n\n\n\nRun\nPatient type\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n1\nambulance\n0.00\n1.36\n0.00\n3.40\nTrue\n0.00\n30.60\nTrue\n\n\n2\n1\nwalkin\n1.36\n2.04\n1.36\n6.80\nTrue\n0.00\n13.60\nTrue\n\n\n3\n1\ntelephone\n3.40\n0.04\n8.12\n5.44\nTrue\n8.16\n6.80\nTrue\n\n\n4\n1\ntelephone\n0.04\n0.00\n13.56\n8.16\nTrue\n6.80\n10.20\nTrue\n\n\n5\n1\ntelephone\n0.00\n1.10\n15.56\n0.16\nFalse\nNaN\nNaN\nTrue\n\n\n6\n1\ntelephone\n1.00\n3.26\n12.46\n0.02\nFalse\nNaN\nNaN\nTrue\n\n\n7\n1\ntelephone\n4.25\n1.35\n11.13\n4.40\nFalse\nNaN\nNaN\nTrue\n\n\n8\n1\nwalkin\n4.01\n1.51\n14.02\n10.20\nFalse\nNaN\nNaN\nTrue\n\n\n9\n1\ntelephone\n4.36\n5.63\n18.58\n13.04\nFalse\nNaN\nNaN\nTrue\n\n\n10\n1\nambulance\n4.35\n12.12\n19.50\n5.10\nTrue\n0.00\n45.88\nTrue\n\n\n\n\n\n\n\nNote the presence of the ‘run’ column. Now we’ll look at the last 10 rows of the dataframe - note that this instead shows the\n\nall_results.tail(10).round(2)\n\n\n\n\n\n\n\n\nRun\nPatient type\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n136\n5\nambulance\n2.78\n1.78\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n137\n5\nambulance\n3.40\n2.39\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n138\n5\ntelephone\n1.85\n6.96\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n139\n5\ntelephone\n0.00\n3.83\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n140\n5\nambulance\n2.69\n3.82\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n141\n5\nwalkin\n0.00\n1.28\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n142\n5\ntelephone\n0.00\n6.77\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n143\n5\nambulance\n4.79\n2.01\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n144\n5\nambulance\n6.53\n2.39\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n145\n5\ntelephone\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nNow we can write simple code to recreate the output we were getting from our trial class previously, as well as allowing us to return more detailed outputs.\n\n\n\n\n\n\nTip\n\n\n\nWe could turn these into functions as well to make it clearer what each does and make them easier to reuse and adapt.\n\n\n\n23.5.1 Return trial-level results\n\n(\n    all_results[['Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .mean()\n    .round(2)\n)\n\nQ Time Recep       2.50\nQ Time Nurse     135.72\nQ Time Doctor     13.55\ndtype: float64\n\n\n\n23.5.1.1 Segment this by type\n\n(\n    all_results[['Patient type', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Patient type')\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nPatient type\n\n\n\n\n\n\n\nambulance\n2.55\n131.94\n13.43\n\n\ntelephone\n2.39\n144.71\n16.18\n\n\nwalkin\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\n\n\n23.5.2 Return run-level results\n\n(\n    all_results[['Run', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Run')\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nRun\n\n\n\n\n\n\n\n1\n3.78\n140.14\n0.79\n\n\n2\n2.20\n115.32\n36.08\n\n\n3\n2.40\n159.47\n0.00\n\n\n4\n2.13\n146.57\n2.11\n\n\n5\n2.10\n124.95\n22.42\n\n\n\n\n\n\n\n\n23.5.2.1 Segment this by type\n\n(\n    all_results[['Run', 'Patient type', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby(['Run','Patient type'])\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nRun\nPatient type\n\n\n\n\n\n\n\n1\nambulance\n4.97\n115.24\n0.00\n\n\ntelephone\n3.46\n169.08\n2.49\n\n\nwalkin\n4.25\n67.08\n0.00\n\n\n2\nambulance\n2.15\n105.01\n32.65\n\n\ntelephone\n2.20\n125.79\n44.51\n\n\nwalkin\n2.24\n101.25\n32.12\n\n\n3\nambulance\n2.48\n171.34\n0.00\n\n\ntelephone\n2.29\n168.74\n0.00\n\n\nwalkin\n2.68\n131.08\n0.00\n\n\n4\nambulance\n1.59\n145.66\n2.76\n\n\ntelephone\n2.03\n145.09\n1.89\n\n\nwalkin\n2.90\n152.08\n1.39\n\n\n5\nambulance\n2.66\n155.01\n16.82\n\n\ntelephone\n2.00\n121.21\n20.51\n\n\nwalkin\n1.94\n110.25\n29.92",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "example_multiple_entity_types_similar_pathways.html#display-trial-results-visually",
    "href": "example_multiple_entity_types_similar_pathways.html#display-trial-results-visually",
    "title": "23  Example - Multiple Entity Types",
    "section": "23.6 Display trial results visually",
    "text": "23.6 Display trial results visually\n\n23.6.1 Bar chart summary\n\nresults_df = (\n    all_results[['Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .mean()\n    .round(2)\n    .reset_index()\n    )\n\nresults_df.columns = ['Metric', 'Value']\n\nresults_df\n\n\n\n\n\n\n\n\nMetric\nValue\n\n\n\n\n0\nQ Time Recep\n2.50\n\n\n1\nQ Time Nurse\n135.72\n\n\n2\nQ Time Doctor\n13.55\n\n\n\n\n\n\n\n\npx.bar(\n    results_df,\n    y=\"Metric\",\n    x=\"Value\",\n    orientation='h'\n    )\n\n                            \n                                            \n\n\nWe can see that while the queue times for the receptionist and the doctor are relatively short, the queue time for the nurse resource is very long, suggesting that the nurse is the bottleneck in our current simulated environment.\n\n\n23.6.2 Bar chart summary - by type\n\nresults_df = (\n    all_results[['Patient type', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Patient type')\n    .mean()\n    .round(2)\n)\n\nresults_df\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nPatient type\n\n\n\n\n\n\n\nambulance\n2.55\n131.94\n13.43\n\n\ntelephone\n2.39\n144.71\n16.18\n\n\nwalkin\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\nresults_df = results_df.reset_index()\n\nresults_df\n\n\n\n\n\n\n\n\nPatient type\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\n\n\n0\nambulance\n2.55\n131.94\n13.43\n\n\n1\ntelephone\n2.39\n144.71\n16.18\n\n\n2\nwalkin\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\nresults_df_long = results_df.melt(id_vars=\"Patient type\")\n\nresults_df_long\n\n\n\n\n\n\n\n\nPatient type\nvariable\nvalue\n\n\n\n\n0\nambulance\nQ Time Recep\n2.55\n\n\n1\ntelephone\nQ Time Recep\n2.39\n\n\n2\nwalkin\nQ Time Recep\n2.77\n\n\n3\nambulance\nQ Time Nurse\n131.94\n\n\n4\ntelephone\nQ Time Nurse\n144.71\n\n\n5\nwalkin\nQ Time Nurse\n112.46\n\n\n6\nambulance\nQ Time Doctor\n13.43\n\n\n7\ntelephone\nQ Time Doctor\n16.18\n\n\n8\nwalkin\nQ Time Doctor\n11.27\n\n\n\n\n\n\n\n\npx.bar(\n    results_df_long,\n    y=\"variable\",\n    x=\"value\",\n    color=\"Patient type\",\n    orientation='h',\n    barmode=\"group\"\n)\n\n                            \n                                            \n\n\nWe can see that the queue times for each group across the trial are similar - which makes sense because we haven’t introduced any sort of priority for the patients of different type.\nIf we were to introduce priority, this graph would make it easy to determine if that was working as expected.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Example - Multiple Entity Types</span>"
    ]
  },
  {
    "objectID": "scheduling_arrivals.html",
    "href": "scheduling_arrivals.html",
    "title": "24  (Coming Soon!) Scheduling Arrivals",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>(Coming Soon!) Scheduling Arrivals</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html",
    "href": "appointment_style_booking_models.html",
    "title": "25  Dealing With Appointment Bookings",
    "section": "",
    "text": "25.1 The appointment book\nIn many community-based services, it is important to model the process of booked appointments.\nThese are quite distinct from the processes we have modelled so far, where arrivals flow through the system immediately - or as quickly as possible, depending on the queues.\nThis works well for modelling a range of services, or smaller parts of more complex processes, such as:\nHowever, in many services there is a process by which clients are booked into an appointment at some point in the future. There is often a delay of several days or weeks - which allows patients to receive communication about their appointment and make plans to attend it.\nAppointment booking can take on additional layers of complexity, such as:\nIn this chapter, we will look at an implementation of a simple model of a mental health assessment service.\nIn this model, patients:\nThe key difference in this model is that we will feed in an additional object that represents the capacity of the clinic to see new clients.\nTo begin with, let’s assume that:\npd.read_csv(\"resources/shifts_simplest.csv\")\n\n\n\n\n\n\n\n\nclinic_1\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n5\n8\n\n\n6\n0\nHere, we have one row per day of the week. We will interpret an index of 0 as Monday and 6 as Sunday.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#the-appointment-book",
    "href": "appointment_style_booking_models.html#the-appointment-book",
    "title": "25  Dealing With Appointment Bookings",
    "section": "",
    "text": "There is a single clinic.\nAny client can be seen by any clinician.\nThey are open six days a week.\nAll appointments are the same length.\nClients do not express any preference about being seen at a particular time of day.\nEveryone attends their appointment.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#coding-the-model",
    "href": "appointment_style_booking_models.html#coding-the-model",
    "title": "25  Dealing With Appointment Bookings",
    "section": "25.2 Coding the model",
    "text": "25.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n25.2.1 g class\nRather than setting an interarrival time, we will instead set a value that represents the average annual demand for our clinic.\nWe will also pass in the dataframe of shifts.\nAnother new parameter is the minimum wait. To give patients time to receive their appointment letter and make a plan to attend, we don’t want to just book the next available appointment, as this could be the very next day, with no time for clients to find out they are meant to be attending!\nFinally, we return to parameters we have used before - the sim duration, which we have this time set as two years (365 days times 2). Note that compared to our previous model, where we interpreted each SimPy time unit as 1 minute, we are now interpreting a single time unit as one day. We do not change anything in SimPy itself to do this - but we just need to be careful that we remain consistent in our application of this throughout the rest of the model.\n\nshifts_df = pd.read_csv(\"resources/shifts_simplest.csv\")\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    annual_demand = 3500\n    shifts = shifts_df\n\n    min_wait = 7\n\n    sim_duration = 365 * 2\n    number_of_runs = 100\n\n\n\n25.2.2 Patient (entity) class\nIn our patient class, we will record an id as before.\nWe have a new attribute named ‘booker’ that we will create shortly.\nWe will also create a space to record the time patients arrive into the model, and the time they have to wait until their appointment.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, booker):\n        self.id = p_id\n        self.booker = booker  ##NEW\n\n        self.arrival_time = 0  ##NEW\n        self.waiting_time = 0  ##NEW\n\n\n\n25.2.3 Model class\n\n25.2.3.1 The __init__method\nWe now need to make some important changes to the __init__ method of the model, as well as create a few extra methods we can call on.\nOne of the key things we need to do is create two new dataframes based on our shift data (the dataframe of available daily slots). We have only provided the required information for a single week - our model will need to:\n\nExtrapolate this out into an array that covers the whole model (with a bit extra for appointments that are booked while the model is running, but are booked in for after the model has finished running) (create_slots()).\nCreate a second array with the same dimensions that will be used to track the number of patients that have been booked in on a given day, allowing us to calculate if there are any slots still available when (create_bookings()).\n\n\n\n\n\n\n\nTip\n\n\n\nNote that we are using numpy throughout for the operations relating to the bookings. This is just due to the speed advantage of numpy in this context.\n\n\nWhen setting up our model class, we also want to create a distribution object that can be used to sample the number of daily arrivals to our system, based on the average number of yearly arrivals passed in our g class (self.arrival_dist).\nFor more information on these functions, refer to Chapter 12 and Chapter 14.\nWe will be using the Poisson class from the sim-tools package written by Tom Monks , so first need to run the following line.\n\nfrom sim_tools.distributions import Poisson\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ##NEW\n        self.available_slots = None\n        self.bookings = None\n\n        ##NEW - run the new methods we have created below\n        self.create_slots() ##NEW\n        self.create_bookings() ##NEW\n\n        ##NEW\n1        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n2                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0 ##NEW\n        self.mean_yearly_arrivals = 0 ##NEW\n\n    #########\n    ##NEW\n    #########\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    #########\n    ##END NEW\n    #########\n\n\n1\n\nThe parameter we pass to the poisson distribution is the average number of daily arrivals; this will be the average number of yearly arrivals divided by the number of weeks in a year and the number of days in a week.\n\n2\n\nThis will ensure we have a different random pattern of arrivals per run, but that the number of arrivals is reproducible across trials.\n\n\n\n\nLet’s look at the outputs from this.\n\nmodel = Model(run_number=1)\n\nmodel.create_slots()\nmodel.available_slots\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n...\n...\n\n\n2186\n8\n\n\n2187\n10\n\n\n2188\n12\n\n\n2189\n8\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\nmodel.create_bookings()\nmodel.bookings\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n2\n0\n\n\n3\n0\n\n\n4\n0\n\n\n...\n...\n\n\n2186\n0\n\n\n2187\n0\n\n\n2188\n0\n\n\n2189\n0\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\n\n25.2.4 Booker class\nBefore we continue making changes to our model class, we want to introduce a new class that will deal with patient bookings.\n\n\n\n\n\n\nTip\n\n\n\nWhile at this stage these methods could easily be incorporated elsewhere - such as into the model class itself - separating it out into its own class will give us more flexibility in the future when we wish to add in features such as pooling of clinic resources or different booking protocols for high and low priority patients.\nIn this case, this is also the motivation for adding in a ‘clinic ID’ parameter that is passed in when making the booking. While we only have a single clinic in this version of the model, allowing for a situation where we have multiple clinics a client could attend, and can make a choice to send them to whichever of these potential clinics have the earliest available appointment.\n\n\n\n#########\n##NEW\n#########\nclass Booker():\n    '''\n    Booking class.\n    '''\n    def __init__(self, model):\n        self.priority = 1\n        self.model = model\n\n    def find_slot(self, t, clinic_id):\n        '''\n        Finds a slot in a diary of available slot\n\n        Params:\n        ------\n        t: int,\n            current simulation time in days\n            required to prevent booking an appointment\n            in the past\n\n        clinic_id: int,\n            index of clinic to look up slots for\n\n        Returns:\n        -------\n        (int, int)\n        (booking_t, best_clinic_idx)\n\n        '''\n        # to reduce runtime - drop down to numpy\n        available_slots_np = self.model.available_slots.to_numpy()\n\n        # get the clinic slots t + min_wait forward\n        clinic_slots = available_slots_np[t + g.min_wait: , clinic_id]\n\n        # get the earliest day number (its the name of the series)\n        best_t = np.where((clinic_slots.reshape(len(clinic_slots),1).sum(axis=1) &gt; 0))[0][0]\n\n        # Note that to get the index (day) of the actual booking, we\n        # need to add the simulation time (t) and the minimum wait to the\n        # index of the best time we found\n        booking_t = t + g.min_wait + best_t\n\n        return booking_t, clinic_id\n\n\n    def book_slot(self, booking_t, clinic_id):\n        '''\n        Book a slot on day t for clinic c\n\n        A slot is removed from args.available_slots\n        A appointment is recorded in args.bookings.iat\n\n        Params:\n        ------\n        booking_t: int\n            Day of booking\n\n        clinic_id: int\n            the clinic identifier\n        '''\n\n        # Reduce the number of available slots by one at the point of the booking\n        self.model.available_slots.iat[booking_t, clinic_id] -= 1\n\n        # Increase the number of bookings we have on that day\n        self.model.bookings.iat[booking_t, clinic_id] += 1\n#########\n##END NEW\n#########\n\nLet’s take a look at the output of these.\n\nsample_booker = Booker(model)\n\nbooking_t, clinic_id = sample_booker.find_slot(t=10, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nBooking t: 17\nClinic Index: 0\n\n\n\nbooking_t, clinic_id = sample_booker.find_slot(t=320, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nBooking t: 327\nClinic Index: 0\n\n\n\nbooking_t, clinic_id = sample_booker.find_slot(t=0, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nsample_booker.book_slot(booking_t=booking_t, clinic_id=clinic_id)\n\nmodel.available_slots\n\nBooking t: 7\nClinic Index: 0\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n...\n...\n\n\n2186\n8\n\n\n2187\n10\n\n\n2188\n12\n\n\n2189\n8\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\nmodel.bookings\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n2\n0\n\n\n3\n0\n\n\n4\n0\n\n\n...\n...\n\n\n2186\n0\n\n\n2187\n0\n\n\n2188\n0\n\n\n2189\n0\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\n25.2.5 Further changes to the model class\nNow we have our booker method, we can make the remaining changes required to the model class.\n\n25.2.5.1 The generator_patient_arrivals method\nThis method changes quite significantly from our existing models.\nInstead of generating a patient, calculating the length of time that elapses until the next patient arrives and then waiting for that time to elapse, we mode through the simulation one day at a time, performing the following steps:\n\nCalculating (sampling) the number of arrivals per day.\nLooping through each referral and creating a new patient object.\nCreating an instance of the booker class for each patient.\nStarting a referral process for that patient.\n\nWhen this is complete for every patient who is generated for that day, we can step forward to the next day by waiting for one time unit to elapse.\n\n#########\n##NEW\n#########\ndef generator_patient_arrivals(self):\n    for t in itertools.count():\n\n        #total number of referrals today\n        n_referrals = self.arrival_dist.sample()\n\n        #loop through all referrals recieved that day\n        for i in range(n_referrals):\n            self.patient_counter += 1\n\n            booker = Booker(model=self)\n\n            # Create instance of Patient\n            p = Patient(p_id=self.patient_counter, booker=booker)\n\n            # Start a referral assessment process for patient.\n            self.env.process(self.attend_clinic(p))\n\n        #timestep by one day\n        yield self.env.timeout(1)\n#########\n##END NEW\n#########\n\n\n\n25.2.5.2 The attend_clinic method\nThis method also needs to change quite significantly. Instead of waiting in queues for the receptionist/nurse, this method introduces slot booking. Patients book an appointment slot, and the time until their appointment is recorded as their waiting time.\n\n#########\n##NEW\n#########\ndef attend_clinic(self, patient):\n    patient.arrival_time = self.env.now\n\n    best_t, clinic_id = (\n            patient.booker.find_slot(\n1              t = patient.arrival_time,\n2              clinic_id = 0\n              )\n    )\n\n    #book slot at clinic = time of referral + waiting_time\n    #\n    patient.booker.book_slot(best_t, clinic_id)\n\n    # Wait for the time until the appointment to elapse\n    yield self.env.timeout(best_t - patient.arrival_time)\n\n    patient.waiting_time = self.env.now - patient.arrival_time\n\n    self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n               patient.waiting_time\n               )\n#########\n##END NEW\n#########\n\n\n1\n\nThe arrival time of the patient is passed in so that only appointments in the future are considered as eligible slots.\n\n2\n\nIn this example we are only looking at a single clinic. In later versions of this model, patients who arrive will also have a preferred ‘home’ clinic, which will mean that different clinic IDs can be passed in at this stage.\n\n\n\n\n\n\n25.2.5.3 The calculate_run_results method\nHere, we are just altering the column name we refer to when calculating our metric of interest.\n\n#########\n##NEW\n#########\ndef calculate_run_results(self):\n    # Take the mean of the queuing times for an appointment across this run of the model\n    self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n    # use our patient counter to track how many patients turn up on average during each\n    # year of the simulation.\n    self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n#########\n##END NEW\n#########\n\n\n\n25.2.5.4 The run method\nThe run method is unchanged.\n\n\n\n25.2.6 Trial class\nOur trial class is fundamentally unchanged - the main differences relate to the changes to the metrics we are interested in tracking.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment] ##NEW\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals] ##NEW\n\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n25.2.7 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nfrom sim_tools.distributions import Poisson\nimport pandas as pd\nimport numpy as np\nimport simpy\nimport itertools\n\nshifts_df = pd.read_csv(\"resources/shifts_simplest.csv\")\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    annual_demand = 3500\n    shifts = shifts_df\n\n    min_wait = 7\n\n    sim_duration = 365 * 2\n    number_of_runs = 10\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, booker):\n        self.id = p_id\n        self.booker = booker  ##NEW\n\n        self.arrival_time = 0  ##NEW\n        self.waiting_time = 0  ##NEW\n\n#########\n##NEW\n#########\nclass Booker():\n    '''\n    Booking class.\n    '''\n    def __init__(self, model):\n        self.priority = 1\n        self.model = model\n\n    def find_slot(self, t, clinic_id):\n        '''\n        Finds a slot in a diary of available slot\n\n        Params:\n        ------\n        t: int,\n            current simulation time in days\n            required to prevent booking an appointment\n            in the past\n\n        clinic_id: int,\n            index of clinic to look up slots for\n\n        Returns:\n        -------\n        (int, int)\n        (booking_t, best_clinic_idx)\n\n        '''\n        # to reduce runtime - drop down to numpy\n        available_slots_np = self.model.available_slots.to_numpy()\n\n        # get the clinic slots t + min_wait forward\n        clinic_slots = available_slots_np[t + g.min_wait: , clinic_id]\n\n        # get the earliest day number (its the name of the series)\n        best_t = np.where((clinic_slots.reshape(len(clinic_slots),1).sum(axis=1) &gt; 0))[0][0]\n\n        # Note that to get the index (day) of the actual booking, we\n        # need to add the simulation time (t) and the minimum wait to the\n        # index of the best time we found\n        booking_t = t + g.min_wait + best_t\n\n        return booking_t, clinic_id\n\n\n    def book_slot(self, booking_t, clinic_id):\n        '''\n        Book a slot on day t for clinic c\n\n        A slot is removed from args.available_slots\n        A appointment is recorded in args.bookings.iat\n\n        Params:\n        ------\n        booking_t: int\n            Day of booking\n\n        clinic_id: int\n            the clinic identifier\n        '''\n\n        # Reduce the number of available slots by one at the point of the booking\n        self.model.available_slots.iat[booking_t, clinic_id] -= 1\n\n        # Increase the number of bookings we have on that day\n        self.model.bookings.iat[booking_t, clinic_id] += 1\n#########\n##END NEW\n#########\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ##NEW\n        self.available_slots = None\n        self.bookings = None\n\n        ## Populate these two items\n        self.create_slots() ##NEW\n        self.create_bookings() ##NEW\n\n\n        ##NEW\n        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0 ##NEW\n        self.mean_yearly_arrivals = 0 ##NEW\n\n    #########\n    ##NEW\n    #########\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    def generator_patient_arrivals(self):\n        for t in itertools.count():\n\n            #total number of referrals today\n            n_referrals = self.arrival_dist.sample()\n\n            #loop through all referrals recieved that day\n            for i in range(n_referrals):\n                self.patient_counter += 1\n\n                booker = Booker(model=self)\n\n                # Create instance of Patient\n                p = Patient(p_id=self.patient_counter, booker=booker)\n\n                # Start a referral assessment process for patient.\n                self.env.process(self.attend_clinic(p))\n\n            #timestep by one day\n            yield self.env.timeout(1)\n\n    def attend_clinic(self, patient):\n        patient.arrival_time = self.env.now\n\n        best_t, clinic_id = (\n                patient.booker.find_slot(\n                  t = patient.arrival_time,\n                  clinic_id = 0\n                  )\n        )\n\n        #book slot at clinic = time of referral + waiting_time\n        patient.booker.book_slot(best_t, clinic_id)\n\n        # Wait for the time until the appointment to elapse\n        yield self.env.timeout(best_t - patient.arrival_time)\n\n        patient.waiting_time = self.env.now - patient.arrival_time\n\n        self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n                  patient.waiting_time\n                  )\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n        self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # Commented out for now\n        #print (f\"Run Number {self.run_number}\")\n        #print (self.results_df)\n\n    #########\n    ##END NEW\n    #########\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment] ##NEW\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n25.2.8 Evaluating the results\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Appointment Wait (Days)  Average Yearly Arrivals\nRun Number                                                       \n0                              17.009395                   3470.0\n1                              18.042281                   3488.0\n2                              25.047924                   3549.5\n3                              14.848336                   3435.0\n4                              27.680286                   3594.5\n5                              19.943840                   3547.5\n6                              29.153250                   3577.5\n7                              25.724776                   3603.5\n8                              22.593023                   3553.0\n9                              19.984317                   3504.0",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#tracking-additional-metrics",
    "href": "appointment_style_booking_models.html#tracking-additional-metrics",
    "title": "25  Dealing With Appointment Bookings",
    "section": "25.3 Tracking additional metrics",
    "text": "25.3 Tracking additional metrics\nWe may find it useful to understand how many of our available appointment slots are going unused in the simulation.\nTo do this, we can slice our available_slots and bookings objects to just include the period of interest.\nRemember that available_slots refers to the number of remaining slots after bookings have been made - not the total available theoretical slots per day, which is stored in our g class as shifts - but remember that the shifts object is only a template for a seven day period rather than encompassing the whole model duration.\nTherefore, to get the total number of possible slots, we must do available_slots + bookings.\nThis will add up the relevant values on a day-by-day basis.\nWe can then sum available_slots to get the total number of slots that weren’t utilised, and then sum the result of available_slots + bookings to get the total number of slots that were available. By dividing the first result by the second, we get an indication of what proportion of slots were actually used.\n\n\n\n\n\n\nNote\n\n\n\nChanges to the code are marked with ##NEW below\n\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        self.available_slots = None\n        self.bookings = None\n\n        ## Populate these two items\n        self.create_slots()\n        self.create_bookings()\n\n        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0\n        self.mean_yearly_arrivals = 0\n        self.percentage_slots_used = 0.0 ##NEW\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    def generator_patient_arrivals(self):\n        for t in itertools.count():\n\n            #total number of referrals today\n            n_referrals = self.arrival_dist.sample()\n\n            #loop through all referrals recieved that day\n            for i in range(n_referrals):\n                self.patient_counter += 1\n\n                booker = Booker(model=self)\n\n                # Create instance of Patient\n                p = Patient(p_id=self.patient_counter, booker=booker)\n\n                # Start a referral assessment process for patient.\n                self.env.process(self.attend_clinic(p))\n\n            #timestep by one day\n            yield self.env.timeout(1)\n\n    def attend_clinic(self, patient):\n        patient.arrival_time = self.env.now\n\n        best_t, clinic_id = (\n                patient.booker.find_slot(\n                  t = patient.arrival_time,\n                  clinic_id = 0\n                  )\n        )\n\n        #book slot at clinic = time of referral + waiting_time\n        patient.booker.book_slot(best_t, clinic_id)\n\n        # Wait for the time until the appointment to elapse\n        yield self.env.timeout(best_t - patient.arrival_time)\n\n        patient.waiting_time = self.env.now - patient.arrival_time\n\n        self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n                  patient.waiting_time\n                  )\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n        self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n        #########\n        ##NEW\n        #########\n\n        slots_unused = self.available_slots.clinic_1.values[ : g.sim_duration]\n\n        slots_used = self.bookings.clinic_1.values[ : g.sim_duration]\n\n        total_slots_available_daily = np.add(slots_unused, slots_used)\n\n        self.percentage_slots_used = (sum(slots_used) / sum(total_slots_available_daily))\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # Commented out for now\n        #print (f\"Run Number {self.run_number}\")\n        #print (self.results_df)\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results[\"Percentage of Slots Used\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment]\n\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals]\n\n            self.df_trial_results.loc[run, \"Percentage of Slots Used\"] = [my_model.percentage_slots_used] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n25.3.1 Evaluating the Results\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Appointment Wait (Days)  Average Yearly Arrivals  \\\nRun Number                                                          \n0                              17.009395                   3470.0   \n1                              18.042281                   3488.0   \n2                              25.047924                   3549.5   \n3                              14.848336                   3435.0   \n4                              27.680286                   3594.5   \n5                              19.943840                   3547.5   \n6                              29.153250                   3577.5   \n7                              25.724776                   3603.5   \n8                              22.593023                   3553.0   \n9                              19.984317                   3504.0   \n\n            Percentage of Slots Used  \nRun Number                            \n0                           0.988065  \n1                           0.989686  \n2                           0.989981  \n3                           0.987034  \n4                           0.988065  \n5                           0.989097  \n6                           0.988360  \n7                           0.987181  \n8                           0.988360  \n9                           0.986445  \n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that in this example we have not made use of a warm-up period.\nIn the early phases of the model, we would expect the utilisation of available slots to be lower, as there will be no booked appointments at the beginning of the model, and the first people to be booked in will be booked in a week ahead due to the mandatory delay period. Therefore the utilisation is likely to be an underestimate.\nTo learn more about setting warm-up periods, refer to Chapter 9.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#evaluating-the-impact-of-changing-the-number-of-yearly-attendances",
    "href": "appointment_style_booking_models.html#evaluating-the-impact-of-changing-the-number-of-yearly-attendances",
    "title": "25  Dealing With Appointment Bookings",
    "section": "25.4 Evaluating the impact of changing the number of yearly attendances",
    "text": "25.4 Evaluating the impact of changing the number of yearly attendances\nTo make it possible to see the impact of changing the number of attendances, we will modify our run_trial method to return the final dataframe instead of printing it.\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results[\"Percentage of Slots Used\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment]\n\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals]\n\n            self.df_trial_results.loc[run, \"Percentage of Slots Used\"] = [my_model.percentage_slots_used] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        return self.df_trial_results\n\nWe can then iterate through and store the results for a number of different average yearly demand.\n\nyearly_demand = [2500, 2750, 3000, 3250, 3500, 3750, 4000]\nresults_frames = []\n\n# We will also extend the duration of each run to 4 years\nsim_duration = 365 * 4\n\nfor demand in yearly_demand:\n    g.annual_demand = demand\n\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    results_df = my_trial.run_trial()\n\n    results_df['Demand'] = demand\n\n    results_frames.append(results_df)\n\nfinal_results_df = pd.concat(results_frames)\n\nWe can then visualise the results in bar charts.\nFirst, to make it easier to visualise multiple metrics at once, we will reshape our results dataframe from wide to long.\nThe original dataframe looks like this:\n\nfinal_results_df\n\n\n\n\n\n\n\n\nMean Appointment Wait (Days)\nAverage Yearly Arrivals\nPercentage of Slots Used\nDemand\n\n\nRun Number\n\n\n\n\n\n\n\n\n0\n7.267180\n2483.0\n0.726831\n2500\n\n\n1\n7.262172\n2478.0\n0.723295\n2500\n\n\n2\n7.260255\n2536.0\n0.739944\n2500\n\n\n3\n7.260905\n2469.0\n0.719464\n2500\n\n\n4\n7.297517\n2603.5\n0.759688\n2500\n\n\n...\n...\n...\n...\n...\n\n\n5\n64.057011\n4012.5\n0.989834\n4000\n\n\n6\n67.956994\n4087.0\n0.990128\n4000\n\n\n7\n62.453639\n4048.0\n0.989981\n4000\n\n\n8\n58.317168\n3910.5\n0.990423\n4000\n\n\n9\n55.426720\n3942.0\n0.989244\n4000\n\n\n\n\n70 rows × 4 columns\n\n\n\nAfter using the melt function of pandas, our dataframe now has one row per run.\n\nfinal_results_df_long = pd.melt(\n  final_results_df.reset_index(),\n  id_vars=[\"Demand\", \"Run Number\"]\n  )\n\nfinal_results_df_long\n\n\n\n\n\n\n\n\nDemand\nRun Number\nvariable\nvalue\n\n\n\n\n0\n2500\n0\nMean Appointment Wait (Days)\n7.267180\n\n\n1\n2500\n1\nMean Appointment Wait (Days)\n7.262172\n\n\n2\n2500\n2\nMean Appointment Wait (Days)\n7.260255\n\n\n3\n2500\n3\nMean Appointment Wait (Days)\n7.260905\n\n\n4\n2500\n4\nMean Appointment Wait (Days)\n7.297517\n\n\n...\n...\n...\n...\n...\n\n\n205\n4000\n5\nPercentage of Slots Used\n0.989834\n\n\n206\n4000\n6\nPercentage of Slots Used\n0.990128\n\n\n207\n4000\n7\nPercentage of Slots Used\n0.989981\n\n\n208\n4000\n8\nPercentage of Slots Used\n0.990423\n\n\n209\n4000\n9\nPercentage of Slots Used\n0.989244\n\n\n\n\n210 rows × 4 columns\n\n\n\nThis allows us to use the facet_rows argument in plotly express.\n\nimport plotly.express as px\n\nfig = px.box(\n  final_results_df_long,\n  x=\"Demand\",\n  y=\"value\",\n  facet_col=\"variable\",\n  facet_col_wrap=1,\n  height=1200\n)\n\nfig.update_yaxes(matches=None)\nfig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1]))\nfig.show()",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html",
    "href": "appointment_style_booking_models_advanced.html",
    "title": "26  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "",
    "text": "26.1 Adding in priority and carve-out",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#adding-in-priority-and-carve-out",
    "href": "appointment_style_booking_models_advanced.html#adding-in-priority-and-carve-out",
    "title": "26  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#adding-multiple-clinics",
    "href": "appointment_style_booking_models_advanced.html#adding-multiple-clinics",
    "title": "26  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "26.2 Adding multiple clinics",
    "text": "26.2 Adding multiple clinics\n\n\n\n\n\n\nNote\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#pooling-of-clinics",
    "href": "appointment_style_booking_models_advanced.html#pooling-of-clinics",
    "title": "26  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "26.3 Pooling of clinics",
    "text": "26.3 Pooling of clinics\n\n\n\n\n\n\nNote\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_multistep.html",
    "href": "appointment_style_booking_models_multistep.html",
    "title": "27  (Coming Soon!) Multi-step Appointment Booking Models",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>(Coming Soon!) Multi-step Appointment Booking Models</span>"
    ]
  },
  {
    "objectID": "example_models.html",
    "href": "example_models.html",
    "title": "28  Example Models from Other Modellers",
    "section": "",
    "text": "28.1 HSMA clinic model diagram\nLooking at the model code written by other people - even if it does not exactly match the kind of system you are trying to create - can be hugely beneficial for seeing new approaches. In this section are links to a range of additional SimPy models that you might wish to read through and adapt.\nTo aid understanding of different code structures, diagrams have been provided for each example. For comparison, we have generated a diagram of the code structure for the model from Chapter 14. In this model, patients see a patient, nurse and doctor.\nCode structure:",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "example_models.html#hsma-clinic-model-diagram",
    "href": "example_models.html#hsma-clinic-model-diagram",
    "title": "28  Example Models from Other Modellers",
    "section": "",
    "text": "Structure as of 7th February 2025. May not include every function/method, but tries to provide a general guide to how things interact. Click image to enlarge. Diagram created using draw.io.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "example_models.html#a-queueing-model",
    "href": "example_models.html#a-queueing-model",
    "title": "28  Example Models from Other Modellers",
    "section": "28.2 A queueing model",
    "text": "28.2 A queueing model\nA SimPy model of a queueing model for a nurse consultation.\n\nAmy Heather  Tom Monks  (2025) Python DES RAP Template. https://github.com/pythonhealthdatascience/rap_template_python_des.\n\n\nModel code (archive).\n\nThe repository includes a document docs/hsma_changes.md which explains how the model differs from those in this book, and why those changes were made.\nCode structure:\n\n\n\nStructure as of 7th February 2025. May not include every function/method, but tries to provide a general guide to how things interact. Click image to enlarge. Diagram created using draw.io.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "example_models.html#an-urgent-care-call-centre-model",
    "href": "example_models.html#an-urgent-care-call-centre-model",
    "title": "28  Example Models from Other Modellers",
    "section": "28.3 An urgent care call centre model",
    "text": "28.3 An urgent care call centre model\nA SimPy model of an urgent care call centre where patients speak to an operator, are triaged, and some required callback from a nurse.\n\nTom Monks  Alison Harper  Amy Heather  (2025) An introduction to Discrete-Event Simulation using Free and Open Source Software. https://github.com/pythonhealthdatascience/intro-open-sim.\n\n\nModel code (archive).\nInteractive coding environment via JupyterLite.\n\n\n\n\nStructure as of 10th February 2025. May not include every function/method, but tries to provide a general guide to how things interact. Click image to enlarge. Diagram created using draw.io.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "example_models.html#a-trauma-centre-model",
    "href": "example_models.html#a-trauma-centre-model",
    "title": "28  Example Models from Other Modellers",
    "section": "28.4 A trauma centre model",
    "text": "28.4 A trauma centre model\nA SimPy model of an urgent treatment centre with trauma and non-trauma arrivals.\n\nTom Monks  Alison Harper  Amy Heather  (2024) Towards Sharing Tools, and Artifacts, for Reusable Simulation: a minimal model example (v2.2.0). Zenodo. https://doi.org/10.5281//zenodo.10026326\n\n\nModel code (archive).\nModel documentation (GitHub, archive).\nWeb app (GitHub, archive).\n\nCode structure:\n\n\n\nStructure as of 7th February 2025. May not include every function/method, but tries to provide a general guide to how things interact. Click image to enlarge. Diagram created using draw.io.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "example_models.html#an-orthopaedic-ward",
    "href": "example_models.html#an-orthopaedic-ward",
    "title": "28  Example Models from Other Modellers",
    "section": "28.5 An orthopaedic ward",
    "text": "28.5 An orthopaedic ward\nA SimPy model used for orthopaedic elective planning, from the Hospital Efficiency Project (HEP).\n\nAlison Harper  Tom Monks  (2023) Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation. https://github.com/AliHarp/HEP.\n\n\nModel code (archive).\nModel documentation.\nWeb app.\nInteractive coding environment via Binder.\n\n\n\n\nStructure as of 10th February 2025. May not include every function/method, but tries to provide a general guide to how things interact. Click image to enlarge. Diagram created using draw.io.",
    "crumbs": [
      "Part 4 - Growing your Confidence as a Modeller",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Example Models from Other Modellers</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html",
    "href": "basic_debugging_tactics.html",
    "title": "29  Basic Debugging Tactics",
    "section": "",
    "text": "29.1 The model\nWhen working with your model, it can be hard to know whether it is working correctly. There are a range of different approaches we can take. These include:\nWhere code examples are provided, this chapter uses the model from the chapter “An Example SimPy Model”.\nIn each of these examples, we will just run the model once.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n1    number_of_runs = 1  ##NEW - single run\n\n\n1\n\nJust run the model once.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#the-model",
    "href": "basic_debugging_tactics.html#the-model",
    "title": "29  Basic Debugging Tactics",
    "section": "",
    "text": "Tip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#using-simple-print-statements",
    "href": "basic_debugging_tactics.html#using-simple-print-statements",
    "title": "29  Basic Debugging Tactics",
    "section": "29.2 Using simple print() statements",
    "text": "29.2 Using simple print() statements\nTo get a running record of what is happening in your model, you can add print() statements at key points.\nFor example, we can add:\n\nA print statement recording when each patient arrives.\nA print statement recording when each patient is seen by the nurse (including how long they waited, and how long their consultation then was).\n\n\n\n\n\n\n\nTip\n\n\n\nFor another example using print() statements, see the “Reneging, Balking and Jockeying” chapter where they are used, for example, to record:\n\nprint (f\"Patient {patient.id} reneged after waiting\",\n       f\"{patient.patience_nurse} minutes\")\n\n\n\n\n29.2.1 Coding the model\nWe will modify the Model class to add print statements within the generator_patient_arrivals() and attend_clinic() functions.\n\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n1        ##NEW - Print message stating patient ID and arrival time\n        print(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Print message with patient wait and consultation length\n        print(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n\n\n1\n\nAdd print messages with the patient arrival time, wait time, and time with the nurse.\n\n\n\n\n\n\n29.2.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Print message stating patient ID and arrival time\n            print(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Print message with patient wait and consultation length\n            print(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n29.2.3 Exploring the outputs\nRunning the model, we’ll see the following output…\n\ntrial = Trial()\ntrial.run_trial()\n\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 10.724.\nPatient 2 arrives at: 0.150.\nPatient 3 arrives at: 5.309.\nPatient 4 arrives at: 6.371.\nPatient 5 arrives at: 7.962.\nPatient 2 waits for 10.574 and is seen at 10.724016899760096. Consultation length: 0.200.\nPatient 3 waits for 5.615 and is seen at 10.923618999278593. Consultation length: 0.086.\nPatient 4 waits for 4.639 and is seen at 11.010046767046207. Consultation length: 8.038.\nPatient 5 waits for 11.086 and is seen at 19.04810698254277. Consultation length: 2.322.\nPatient 6 arrives at: 23.236.\nPatient 6 waits for 0.000 and is seen at 23.23637375971412. Consultation length: 2.582.\nPatient 7 arrives at: 24.742.\nPatient 7 waits for 1.076 and is seen at 25.818359178321167. Consultation length: 4.804.\nPatient 8 arrives at: 28.219.\nPatient 8 waits for 2.404 and is seen at 30.622399428034093. Consultation length: 0.806.\nPatient 9 arrives at: 31.606.\nPatient 9 waits for 0.000 and is seen at 31.6058048759237. Consultation length: 5.891.\nPatient 10 arrives at: 37.518.\nPatient 10 waits for 0.000 and is seen at 37.518138074459074. Consultation length: 4.926.\nPatient 11 arrives at: 43.757.\nPatient 11 waits for 0.000 and is seen at 43.75672280585052. Consultation length: 3.754.\nPatient 12 arrives at: 47.837.\nPatient 12 waits for 0.000 and is seen at 47.83716109080116. Consultation length: 7.447.\nPatient 13 arrives at: 51.575.\nPatient 13 waits for 3.709 and is seen at 55.283961262528265. Consultation length: 1.232.\nPatient 14 arrives at: 56.303.\nPatient 14 waits for 0.212 and is seen at 56.51591826312143. Consultation length: 10.233.\nPatient 15 arrives at: 57.747.\nPatient 16 arrives at: 60.308.\nPatient 17 arrives at: 61.744.\nPatient 15 waits for 9.002 and is seen at 66.74892482841393. Consultation length: 2.210.\nPatient 18 arrives at: 67.211.\nPatient 19 arrives at: 67.843.\nPatient 16 waits for 8.651 and is seen at 68.95866493071166. Consultation length: 0.340.\nPatient 17 waits for 7.555 and is seen at 69.2986542797349. Consultation length: 5.792.\nPatient 20 arrives at: 72.047.\nPatient 21 arrives at: 74.530.\nPatient 18 waits for 7.880 and is seen at 75.09038363936328. Consultation length: 11.580.\nPatient 22 arrives at: 76.224.\nPatient 23 arrives at: 76.378.\nPatient 24 arrives at: 78.546.\nPatient 25 arrives at: 84.580.\nPatient 19 waits for 18.827 and is seen at 86.66992435703258. Consultation length: 0.061.\nPatient 20 waits for 14.684 and is seen at 86.73073461746797. Consultation length: 3.013.\nPatient 21 waits for 15.213 and is seen at 89.74391099742128. Consultation length: 0.320.\nPatient 22 waits for 13.840 and is seen at 90.06408226252125. Consultation length: 3.324.\nPatient 23 waits for 17.010 and is seen at 93.38789010749436. Consultation length: 0.945.\nPatient 24 waits for 15.787 and is seen at 94.33269125218459. Consultation length: 7.140.\nPatient 25 waits for 16.893 and is seen at 101.47273147144615. Consultation length: 1.942.\nPatient 26 arrives at: 101.587.\nPatient 27 arrives at: 102.331.\nPatient 26 waits for 1.828 and is seen at 103.4147428371654. Consultation length: 2.334.\nPatient 28 arrives at: 104.156.\nPatient 27 waits for 3.418 and is seen at 105.74893838517372. Consultation length: 6.063.\nPatient 29 arrives at: 106.335.\nPatient 30 arrives at: 108.924.\nPatient 31 arrives at: 109.592.\nPatient 32 arrives at: 110.299.\nPatient 33 arrives at: 110.538.\nPatient 28 waits for 7.656 and is seen at 111.81212331183262. Consultation length: 0.322.\nPatient 29 waits for 5.799 and is seen at 112.13404701043532. Consultation length: 6.933.\nPatient 34 arrives at: 117.495.\nPatient 30 waits for 10.143 and is seen at 119.06730549093024. Consultation length: 0.289.\nPatient 31 waits for 9.764 and is seen at 119.35603766629579. Consultation length: 2.345.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000        10.724017\n2              10.574291         0.199602\n3               5.614699         0.086428\n4               4.638661         8.038060\n5              11.086170         2.321768\n6               0.000000         2.581985\n7               1.076460         4.804040\n8               2.403821         0.806189\n9               0.000000         5.891071\n10              0.000000         4.926228\n11              0.000000         3.754320\n12              0.000000         7.446800\n13              3.709055         1.231957\n14              0.212443        10.233007\n15              9.001625         2.209740\n16              8.651064         0.339989\n17              7.554838         5.791729\n18              7.879701        11.579541\n19             18.826528         0.060810\n20             14.684001         3.013176\n21             15.213417         0.320171\n22             13.839593         3.323808\n23             17.009595         0.944801\n24             15.786730         7.140040\n25             16.892926         1.942011\n26              1.827984         2.334196\n27              3.417988         6.063185\n28              7.656284         0.321924\n29              5.799302         6.933258\n30             10.142826         0.288732\n31              9.764481         2.344893\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                     7.20208",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#using-trace-to-control-the-print-statements",
    "href": "basic_debugging_tactics.html#using-trace-to-control-the-print-statements",
    "title": "29  Basic Debugging Tactics",
    "section": "29.3 Using trace() to control the print() statements",
    "text": "29.3 Using trace() to control the print() statements\nThis output is helpful when debugging a single run of the model, but the behaviour is undesirable when running multiple replications.\nWe can write a function which will toggle whether to run the print() statements or not.\n\n29.3.1 Coding the model\nIn our parameter class, we add a parameter trace which will control whether the print() statements are executed or not.\n\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n1    number_of_runs = 1  ##NEW - single run\n2    trace = True  ##NEW - controls whether the print statements are executed\n\n\n1\n\nJust run the model once.\n\n2\n\nAdd trace parameter which will determine whether the print statements are executed.\n\n\n\n\nWe then define a new function trace() which will only run if g.trace is true.\n\n1##NEW\ndef trace(msg):\n    \"\"\" \n    If TRUE will return all patient-level message outputs.\n\n    Arguments:\n      msg (string):\n        Message output.\n    \"\"\"\n    if g.trace:\n        print(msg)\n\n\n1\n\nDefine a new function trace() which will print messages if g.trace is true.\n\n\n\n\nThen, in our model, we alter our print() statements so that the message is input to the trace() function.\n\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n1        ##NEW - Print message stating patient ID and arrival time\n        trace(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Print message with patient wait and consultation length\n        trace(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n\n\n1\n\nChange our print() statements to trace().\n\n\n\n\n\n\n29.3.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n    trace = True  ##NEW - controls whether the print statements are executed\n\n\n##NEW\ndef trace(msg):\n    \"\"\" \n    If TRUE will return all patient-level message outputs.\n\n    Arguments:\n      msg (string):\n        Message output.\n    \"\"\"\n    if g.trace:\n        print(msg)\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Print message stating patient ID and arrival time\n            trace(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Print message with patient wait and consultation length\n            trace(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n29.3.3 Exploring the outputs\nIf we set g.trace = False, we will see none of the patient messages are printed (and only our results from print_trial_results() are).\n\ng.trace = False\ntrial = Trial()\ntrial.run_trial()\n\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.515033\n2               0.000000        16.105676\n3              13.725436         6.471818\n4              16.432416         1.761055\n5              15.016513         8.896223\n6               3.109157         0.881718\n7               0.000000         8.643518\n8               8.225063         9.053969\n9              12.012615         6.340599\n10             14.435000         2.933931\n11             17.155207         0.689076\n12             13.000332         0.799066\n13              8.791537         0.923040\n14              0.000000         4.718291\n15              4.311246         9.033027\n16              9.024959         1.792199\n17              8.051979         2.034575\n18              0.000000         4.907508\n19              0.501197         2.779236\n20              0.000000         4.841451\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                    7.189633\n\n\nMeanwhile, if g.trace = True…\n\ng.trace = True\ntrial = Trial()\ntrial.run_trial()\n\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 0.949.\nPatient 2 arrives at: 2.523.\nPatient 2 waits for 0.000 and is seen at 2.5228663887406113. Consultation length: 0.583.\nPatient 3 arrives at: 4.029.\nPatient 3 waits for 0.000 and is seen at 4.028668137656526. Consultation length: 3.192.\nPatient 4 arrives at: 9.921.\nPatient 4 waits for 0.000 and is seen at 9.921203417940536. Consultation length: 0.018.\nPatient 5 arrives at: 12.577.\nPatient 5 waits for 0.000 and is seen at 12.577134658714382. Consultation length: 2.112.\nPatient 6 arrives at: 13.534.\nPatient 7 arrives at: 14.184.\nPatient 6 waits for 1.156 and is seen at 14.689547869979073. Consultation length: 3.523.\nPatient 7 waits for 4.029 and is seen at 18.212652512617925. Consultation length: 4.645.\nPatient 8 arrives at: 18.886.\nPatient 8 waits for 3.972 and is seen at 22.8581446432479. Consultation length: 7.315.\nPatient 9 arrives at: 32.497.\nPatient 9 waits for 0.000 and is seen at 32.49747626810915. Consultation length: 1.357.\nPatient 10 arrives at: 34.010.\nPatient 10 waits for 0.000 and is seen at 34.0102442456301. Consultation length: 2.387.\nPatient 11 arrives at: 37.645.\nPatient 11 waits for 0.000 and is seen at 37.64471969428669. Consultation length: 0.221.\nPatient 12 arrives at: 41.007.\nPatient 12 waits for 0.000 and is seen at 41.00722601865192. Consultation length: 16.012.\nPatient 13 arrives at: 41.038.\nPatient 13 waits for 15.981 and is seen at 57.01906588571015. Consultation length: 29.464.\nPatient 14 arrives at: 68.510.\nPatient 15 arrives at: 74.225.\nPatient 14 waits for 17.974 and is seen at 86.48342300181554. Consultation length: 5.123.\nPatient 16 arrives at: 87.589.\nPatient 15 waits for 17.382 and is seen at 91.6067331429726. Consultation length: 0.934.\nPatient 16 waits for 4.951 and is seen at 92.54060165275669. Consultation length: 7.241.\nPatient 17 arrives at: 92.939.\nPatient 18 arrives at: 94.248.\nPatient 17 waits for 6.842 and is seen at 99.78143093758239. Consultation length: 6.249.\nPatient 19 arrives at: 100.160.\nPatient 18 waits for 11.782 and is seen at 106.03032597390029. Consultation length: 5.033.\nPatient 20 arrives at: 110.124.\nPatient 19 waits for 10.904 and is seen at 111.06378953900895. Consultation length: 6.669.\nPatient 21 arrives at: 114.464.\nPatient 20 waits for 7.609 and is seen at 117.73288671184125. Consultation length: 2.026.\nPatient 21 waits for 5.295 and is seen at 119.75916138885063. Consultation length: 8.047.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.949483\n2               0.000000         0.583333\n3               0.000000         3.191868\n4               0.000000         0.018307\n5               0.000000         2.112413\n6               1.155695         3.523105\n7               4.028798         4.645492\n8               3.971928         7.315200\n9               0.000000         1.356641\n10              0.000000         2.387203\n11              0.000000         0.221378\n12              0.000000        16.011840\n13             15.981472        29.464357\n14             17.973793         5.123310\n15             17.381797         0.933869\n16              4.951300         7.240829\n17              6.842006         6.248895\n18             11.782468         5.033464\n19             10.903800         6.669097\n20              7.608666         2.026275\n21              5.295051         8.047447\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                    5.136989",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#using-the-logging-module",
    "href": "basic_debugging_tactics.html#using-the-logging-module",
    "title": "29  Basic Debugging Tactics",
    "section": "29.4 Using the logging module",
    "text": "29.4 Using the logging module\nThe logging module is a step up from the use of print() statements.\nIt enables us to choose between printing the messages or saving them to a .log file.\nIt can also be extended with different types of log message (e.g. INFO, WARNING, ERROR), customised with different colours, and more. Here, we just demonstrate a simple implementation.\n\n29.4.1 Coding the model\n\n29.4.1.1 Imports\nFirst, we need to update our imports.\n\n1import logging  ##NEW\n2import sys  ##NEW\n3import time  ##NEW\n\nimport simpy\nimport random\nimport pandas as pd\n\n\n1\n\nAdd logging which we will use to create logs.\n\n2\n\nAdd sys which is required when setting up the handler for logging to the console.\n\n3\n\nAdd time which we will use is it is desired to save logs to a file with the current date and time.\n\n\n\n\n\n\n29.4.1.2 SimLogger class\nNext, we will create a new class called SimLogger. This accepts three inputs when setting up:\n\nlog_to_console - which determines whether to print log messages.\nlog_to_file - which determines whether to save the log to a file.\nfile_path - if saving to file, the path to use.\n\nThe class configures handlers for logging (_configure_logging()), and then has a log() method which will be used to save messages to the log in our model.\n\n##NEW\nclass SimLogger:\n    \"\"\"\n    Provides log of events as the simulation runs.\n    \"\"\"\n    def __init__(self, log_to_console=False, log_to_file=False,\n                file_path=(\"../outputs/logs/\" +\n                            f\"{time.strftime('%Y-%m-%d_%H-%M-%S')}.log\")\n1      ):\n        \"\"\"\n        Initialise the Logger class.\n\n        Arguments:\n            log_to_console (boolean):\n                Whether to print log messages to the console.\n            log_to_file (boolean):\n                Whether to save log to a file.\n            file_path (str):\n                Path to save log to file. Note, if you use an existing .log\n                file name, it will append to that log. Defaults to filename\n                based on current date and time, and folder '../outputs/log/'.\n        \"\"\"\n        self.log_to_console = log_to_console\n        self.log_to_file = log_to_file\n        self.file_path = file_path\n        self.logger = None\n\n        # If logging enabled (either printing to console, file or both), then\n        # create logger and configure settings\n        if self.log_to_console or self.log_to_file:\n            self.logger = logging.getLogger(__name__)\n            self._configure_logging()\n\n2    def _configure_logging(self):\n        \"\"\"\n        Configure the logger.\n        \"\"\"\n        # Ensure any existing handlers are removed to avoid duplication\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        # Add handlers for saving messages to file and/or printing to console\n        handlers = []\n        if self.log_to_file:\n            # In write mode, meaning will overwrite existing log of same name\n            # (append mode 'a' would add to the end of the log)\n            handlers.append(logging.FileHandler(self.file_path, mode='w'))\n        if self.log_to_console:\n            handlers.append(logging.StreamHandler(sys.stdout))\n\n        # Add handlers directly to the logger\n        for handler in handlers:\n            self.logger.addHandler(handler)\n\n        # Set logging level and format. If don't set level info, it would\n        # only show log messages which are warning, error or critical.\n        self.logger.setLevel(logging.INFO)\n        formatter = logging.Formatter(\"%(message)s\")\n        for handler in handlers:\n            handler.setFormatter(formatter)\n\n3    def log(self, msg):\n        \"\"\"\n        Log a message if logging is enabled.\n\n        Arguments:\n            msg (str):\n                Message to log.\n        \"\"\"\n        if self.log_to_console or self.log_to_file:\n            self.logger.info(msg)\n\n\n1\n\nSet up for the SimLogger class which accepts three inputs, and will call the _configure_logging() method\n\n2\n\nThis method configures the loggers, setting up appropriate handlers depending on whether we are printing logs to the console, saving them to the file, or both.\n\n3\n\nThis is the equivalent to print() or trace() above.\n\n\n\n\n\n\n29.4.1.3 g class\nIn our g class, we will add an instance of the logging class.\n\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n1    number_of_runs = 1  ##NEW - single run\n2    ##NEW - instance of the SimLogger class\n    logger = SimLogger(log_to_console = True,\n                       log_to_file = True,\n                       file_path = \"./outputs/example_log.log\")\n\n\n1\n\nJust run the model once.\n\n2\n\nSet up SimLogger instance.\n\n\n\n\n\n\n29.4.1.4 Model class\nFor our messages in Model, we now change print() or trace() instead to g.logger.log().\n\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n1        ##NEW - Log message stating patient ID and arrival time\n        g.logger.log(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Log message with patient wait and consultation length\n        g.logger.log(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n\n\n1\n\nChange print()/trace() to log().\n\n\n\n\n\n\n\n29.4.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport logging  ##NEW\nimport sys  ##NEW\nimport time  ##NEW\n\nimport simpy\nimport random\nimport pandas as pd\n\n\n##NEW\nclass SimLogger:\n    \"\"\"\n    Provides log of events as the simulation runs.\n    \"\"\"\n    def __init__(self, log_to_console=False, log_to_file=False,\n                file_path=(\"../outputs/logs/\" +\n                            f\"{time.strftime('%Y-%m-%d_%H-%M-%S')}.log\")\n      ):\n        \"\"\"\n        Initialise the Logger class.\n\n        Arguments:\n            log_to_console (boolean):\n                Whether to print log messages to the console.\n            log_to_file (boolean):\n                Whether to save log to a file.\n            file_path (str):\n                Path to save log to file. Note, if you use an existing .log\n                file name, it will append to that log. Defaults to filename\n                based on current date and time, and folder '../outputs/log/'.\n        \"\"\"\n        self.log_to_console = log_to_console\n        self.log_to_file = log_to_file\n        self.file_path = file_path\n        self.logger = None\n\n        # If logging enabled (either printing to console, file or both), then\n        # create logger and configure settings\n        if self.log_to_console or self.log_to_file:\n            self.logger = logging.getLogger(__name__)\n            self._configure_logging()\n\n    def _configure_logging(self):\n        \"\"\"\n        Configure the logger.\n        \"\"\"\n        # Ensure any existing handlers are removed to avoid duplication\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        # Add handlers for saving messages to file and/or printing to console\n        handlers = []\n        if self.log_to_file:\n            # In write mode, meaning will overwrite existing log of same name\n            # (append mode 'a' would add to the end of the log)\n            handlers.append(logging.FileHandler(self.file_path, mode='w'))\n        if self.log_to_console:\n            handlers.append(logging.StreamHandler(sys.stdout))\n\n        # Add handlers directly to the logger\n        for handler in handlers:\n            self.logger.addHandler(handler)\n\n        # Set logging level and format. If don't set level info, it would\n        # only show log messages which are warning, error or critical.\n        self.logger.setLevel(logging.INFO)\n        formatter = logging.Formatter(\"%(message)s\")\n        for handler in handlers:\n            handler.setFormatter(formatter)\n\n    def log(self, msg):\n        \"\"\"\n        Log a message if logging is enabled.\n\n        Arguments:\n            msg (str):\n                Message to log.\n        \"\"\"\n        if self.log_to_console or self.log_to_file:\n            self.logger.info(msg)\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n    ##NEW - instance of the SimLogger class\n    logger = SimLogger(log_to_console = True,\n                       log_to_file = True,\n                       file_path = \"./outputs/example_log.log\")\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Log message stating patient ID and arrival time\n            g.logger.log(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Log message with patient wait and consultation length\n            g.logger.log(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n29.4.3 Exploring the outputs\nWe will run the model with log_to_console and log_to_file both enabled.\nYou’ll see that the logs are printed as before…\n\ntrial = Trial()\ntrial.run_trial()\n\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 20.445.\nPatient 2 arrives at: 3.228.\nPatient 3 arrives at: 4.778.\nPatient 4 arrives at: 11.542.\nPatient 5 arrives at: 17.416.\nPatient 6 arrives at: 18.391.\nPatient 2 waits for 17.217 and is seen at 20.444720365535566. Consultation length: 1.084.\nPatient 3 waits for 16.751 and is seen at 21.528518818320162. Consultation length: 14.875.\nPatient 7 arrives at: 27.049.\nPatient 8 arrives at: 28.655.\nPatient 4 waits for 24.862 and is seen at 36.40390758388942. Consultation length: 4.679.\nPatient 5 waits for 23.667 and is seen at 41.082495475966006. Consultation length: 2.006.\nPatient 6 waits for 24.698 and is seen at 43.08886529597139. Consultation length: 7.335.\nPatient 7 waits for 23.376 and is seen at 50.42416096680088. Consultation length: 5.859.\nPatient 9 arrives at: 53.623.\nPatient 10 arrives at: 55.255.\nPatient 8 waits for 27.629 and is seen at 56.283553427328705. Consultation length: 12.748.\nPatient 11 arrives at: 60.851.\nPatient 12 arrives at: 63.044.\nPatient 13 arrives at: 65.438.\nPatient 14 arrives at: 67.370.\nPatient 9 waits for 15.409 and is seen at 69.03203453539484. Consultation length: 2.009.\nPatient 10 waits for 15.786 and is seen at 71.04113540869592. Consultation length: 4.370.\nPatient 15 arrives at: 72.523.\nPatient 16 arrives at: 73.250.\nPatient 11 waits for 14.560 and is seen at 75.41091250233481. Consultation length: 3.733.\nPatient 12 waits for 16.100 and is seen at 79.14375033636888. Consultation length: 3.217.\nPatient 17 arrives at: 79.729.\nPatient 18 arrives at: 82.031.\nPatient 19 arrives at: 82.323.\nPatient 13 waits for 16.923 and is seen at 82.36092079540045. Consultation length: 11.472.\nPatient 20 arrives at: 90.199.\nPatient 14 waits for 26.463 and is seen at 93.83269016595533. Consultation length: 1.226.\nPatient 15 waits for 22.536 and is seen at 95.05869993983505. Consultation length: 9.555.\nPatient 21 arrives at: 98.437.\nPatient 22 arrives at: 99.959.\nPatient 23 arrives at: 102.641.\nPatient 16 waits for 31.363 and is seen at 104.61344903851816. Consultation length: 1.378.\nPatient 17 waits for 26.263 and is seen at 105.99147015629434. Consultation length: 16.713.\nPatient 24 arrives at: 113.694.\nPatient 25 arrives at: 118.770.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000        20.444720\n2              17.217182         1.083798\n3              16.750729        14.875389\n4              24.862249         4.678588\n5              23.666877         2.006370\n6              24.698140         7.335296\n7              23.375503         5.859392\n8              27.629033        12.748481\n9              15.409151         2.009101\n10             15.785961         4.369777\n11             14.560386         3.732838\n12             16.099564         3.217170\n13             16.922809        11.471769\n14             26.462548         1.226010\n15             22.535522         9.554749\n16             31.363139         1.378021\n17             26.262731        16.713489\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                   20.211854\n\n\n…but also, a .log file has been generated containing the logs:\n\nwith open(\"outputs/example_log.log\") as f:\n    print(f.read())\n\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 20.445.\nPatient 2 arrives at: 3.228.\nPatient 3 arrives at: 4.778.\nPatient 4 arrives at: 11.542.\nPatient 5 arrives at: 17.416.\nPatient 6 arrives at: 18.391.\nPatient 2 waits for 17.217 and is seen at 20.444720365535566. Consultation length: 1.084.\nPatient 3 waits for 16.751 and is seen at 21.528518818320162. Consultation length: 14.875.\nPatient 7 arrives at: 27.049.\nPatient 8 arrives at: 28.655.\nPatient 4 waits for 24.862 and is seen at 36.40390758388942. Consultation length: 4.679.\nPatient 5 waits for 23.667 and is seen at 41.082495475966006. Consultation length: 2.006.\nPatient 6 waits for 24.698 and is seen at 43.08886529597139. Consultation length: 7.335.\nPatient 7 waits for 23.376 and is seen at 50.42416096680088. Consultation length: 5.859.\nPatient 9 arrives at: 53.623.\nPatient 10 arrives at: 55.255.\nPatient 8 waits for 27.629 and is seen at 56.283553427328705. Consultation length: 12.748.\nPatient 11 arrives at: 60.851.\nPatient 12 arrives at: 63.044.\nPatient 13 arrives at: 65.438.\nPatient 14 arrives at: 67.370.\nPatient 9 waits for 15.409 and is seen at 69.03203453539484. Consultation length: 2.009.\nPatient 10 waits for 15.786 and is seen at 71.04113540869592. Consultation length: 4.370.\nPatient 15 arrives at: 72.523.\nPatient 16 arrives at: 73.250.\nPatient 11 waits for 14.560 and is seen at 75.41091250233481. Consultation length: 3.733.\nPatient 12 waits for 16.100 and is seen at 79.14375033636888. Consultation length: 3.217.\nPatient 17 arrives at: 79.729.\nPatient 18 arrives at: 82.031.\nPatient 19 arrives at: 82.323.\nPatient 13 waits for 16.923 and is seen at 82.36092079540045. Consultation length: 11.472.\nPatient 20 arrives at: 90.199.\nPatient 14 waits for 26.463 and is seen at 93.83269016595533. Consultation length: 1.226.\nPatient 15 waits for 22.536 and is seen at 95.05869993983505. Consultation length: 9.555.\nPatient 21 arrives at: 98.437.\nPatient 22 arrives at: 99.959.\nPatient 23 arrives at: 102.641.\nPatient 16 waits for 31.363 and is seen at 104.61344903851816. Consultation length: 1.378.\nPatient 17 waits for 26.263 and is seen at 105.99147015629434. Consultation length: 16.713.\nPatient 24 arrives at: 113.694.\nPatient 25 arrives at: 118.770.\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor a more detailed logging implementation, see the Python DES RAP Template - the file notebooks/logs.ipynb is a good place to start.\nThat implementation includes:\n\nLog of the model state at initialisation and parameters used.\nA sanitise_object function which removes object references when logging things like a simpy.Resource.\nSimulation time at the start of every log message.\nDifferent emojis for different patient types and activities (including distinguishing warm-up and non-warm-up patients).\nA nicely formatted output including colours thanks to the rich module.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#tests",
    "href": "basic_debugging_tactics.html#tests",
    "title": "29  Basic Debugging Tactics",
    "section": "29.5 Tests",
    "text": "29.5 Tests\nTesting is the process of evaluating a model to ensure it works as expected, gives reliable results, and can handle different conditions.\nBy checking for errors and unexpected results, it helps improve the quality of the model, catch errors and prevent future issues.\nTesting is explored in more detail in its own chapter: Chapter 30.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#event-logging",
    "href": "basic_debugging_tactics.html#event-logging",
    "title": "29  Basic Debugging Tactics",
    "section": "29.6 Event logging",
    "text": "29.6 Event logging\nBuilding up our own event logs give us a very clear picture of what is happening to every entity throughout our model.\nThey are a valuable debugging technique, and by structuring them correctly, we can start to build up a bank of code that can be used to debug very different models with no or minimal changes to our code that processes the event logs. They can also then be used for building animated visuals of the flow of entities through our model.\nAs this is a more involved approach, it has been placed in its own chapter here.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "30  Tests",
    "section": "",
    "text": "30.1 Pytest\nTesting is the process of evaluating a model to ensure it works as expected, gives reliable results, and can handle different conditions. By systematically checking for errors, inconsistencies, or unexpected behaviors, testing helps improve the quality of a model, catch errors and prevent future issues.\nWhen you create a model, you will naturally carry out tests, with simple manual checks where you observe outputs and ensure they look right. These checks can be formalised and automated so that you can run them after any changes, and catch any issues that arise.\nA popular framework for testing in python is pytest.\nimport pytest",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Tests</span>"
    ]
  },
  {
    "objectID": "tests.html#pytest",
    "href": "tests.html#pytest",
    "title": "30  Tests",
    "section": "",
    "text": "Pytest. Holger Krekel, CC BY 2.5 https://creativecommons.org/licenses/by/2.5, via Wikimedia Commons.\n\n\n\n30.1.1 Simple pytest example\nEach test in pytest is a function that contains an assertion statement to check a condition (e.g. number &gt; 0). If the condition fails, pytest will return an error message (e.g. “The number should be positive”).\nTests are typically stored in a folder called tests, with filenames starting with the prefix test_. This naming convention allows pytest to automatically discover and run all the tests in the folder.\nHere’s an example of a simple test using pytest:\n\ndef test_positive():\n    \"\"\"\n    Confirm that the number is positive.\n    \"\"\"\n    number = 5\n    assert number &gt; 0, \"The number should be positive\"\n\n\n\n30.1.2 Running the tests\nTests are typically run from the terminal. Commands include:\n\npytest - runs all tests.\npytest tests/test_example_simple.py - runs tests from a specific file.\n\nWhen you run a test, you’ll see an output like this in the terminal:\n\n\n\n\n\n\nTest output:\n\n\n\n\n\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /mnt/c/hsma6_des_book\nplugins: anyio-4.3.0\ncollected 1 item\n\ntests/test_example_simple.py .                                           [100%]\n\n============================== 1 passed in 0.60s ===============================\n\n\n&lt;ExitCode.OK: 0&gt;\n\n\n\n\n\n\n30.1.3 Parametrise\nWe can execute the same test on different parameters using pytest.mark.parametrize.\nHere’s an example:\n\n@pytest.mark.parametrize(\"number\", [1, 2, 3, -1])\ndef test_positive_param(number):\n    \"\"\"\n    Confirm that the number is positive.\n\n    Arguments:\n        number (float):\n            Number to check.\n    \"\"\"\n    assert number &gt; 0, f\"The number {number} is not positive.\"\n\nIn this example, we’re testing the same logic with four different values: 1, 2, 3, and -1. The last value, -1, will cause the test to fail. The error message includes the failed value for easy debugging.\n\n\n\n\n\n\nTest output:\n\n\n\n\n\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /mnt/c/hsma6_des_book\nplugins: anyio-4.3.0\ncollected 4 items\n\ntests/test_example_param.py ...F                                         [100%]\n\n=================================== FAILURES ===================================\n___________________________ test_positive_param[-1] ____________________________\n\nnumber = -1\n\n    @pytest.mark.parametrize(\"number\", [1, 2, 3, -1])\n    def test_positive_param(number):\n        \"\"\"\n        Confirm that the number is positive.\n    \n        Arguments:\n            number (float):\n                Number to check.\n        \"\"\"\n&gt;       assert number &gt; 0, f\"The number {number} is not positive.\"\nE       AssertionError: The number -1 is not positive.\nE       assert -1 &gt; 0\n\ntests/test_example_param.py:13: AssertionError\n=========================== short test summary info ============================\nFAILED tests/test_example_param.py::test_positive_param[-1] - AssertionError: The number -1 is not positive.\n========================= 1 failed, 3 passed in 8.47s ==========================\n\n\n&lt;ExitCode.TESTS_FAILED: 1&gt;",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Tests</span>"
    ]
  },
  {
    "objectID": "tests.html#coding-the-model",
    "href": "tests.html#coding-the-model",
    "title": "30  Tests",
    "section": "30.2 Coding the model",
    "text": "30.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\nWe will design tests for the model from Chapter 14. However, we will modify the model so that, instead of modifying a global class of parameter values, we create instances of this class and use it in our model.\nBy using class instances, each test has isolated parameters, preventing interference and ensuring consistency. This improves flexibility for independent test scenarios, simplifies debugging, and supports parallel execution by avoiding shared state, making the model more robust.\n\n30.2.1 Param class\nAs these are no longer “global” parameters, we will rename g to Param.\n\n# Class to store parameter values.\n1class Param:  ##NEW\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 100\n\n\n1\n\nRenamed g to Param.\n\n\n\n\n\n\n30.2.2 Patient class\nThis remains unchanged.\n\n\n30.2.3 Model class\nSet parameters as an input to the class. Each instance of g is changed to param (which refers to the parameter instance provided to the class).\n\nclass Model:\n1    def __init__(self, param, run_number):  ##NEW\n        self.param = param  ##NEW\n        self.env = simpy.Environment()\n        self.patient_counter = 0\n        self.receptionist = simpy.Resource(\n2            self.env, capacity=self.param.number_of_receptionists)  ##NEW\n        self.nurse = simpy.Resource(\n            self.env, capacity=self.param.number_of_nurses)  ##NEW\n        self.doctor = simpy.Resource(\n            self.env, capacity=self.param.number_of_doctors)  ##NEW\n\n        ...\n\n        self.patient_inter_arrival_dist = Exponential(\n            mean = self.param.patient_inter,  ##NEW\n            random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(\n            mean = self.param.mean_reception_time,  ##NEW\n            random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(\n            mean = self.param.mean_n_consult_time,  ##NEW\n            random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(\n            mean = self.param.mean_d_consult_time,  ##NEW\n            random_seed = self.run_number*5)\n\n   ...\n\n    def attend_clinic(self, patient):\n\n        ...\n\n        if random.uniform(0,1) &lt; self.param.prob_seeing_doctor:  ##NEW\n\n    ...\n\n    def run(self):\n        self.env.process(self.generator_patient_arrivals())\n        self.env.run(until=self.param.sim_duration)  ##NEW\n\n        ...\n\n\n1\n\nSet param as an input to the Model, and made a model attribute.\n\n2\n\nReplaced all g with self.param.\n\n\n\n\n\n\n30.2.4 Trial class\nSet parameters as an input to the class, and renamed g to param. Also, disabled printing sections.\n\nclass Trial:\n1    def  __init__(self, param):  ##NEW\n        self.param = param  ##NEW\n\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    def run_trial(self):\n        # print(f\"{self.param.number_of_receptionists} receptionists, \" +\n        #      f\"{self.param.number_of_nurses} nurses, \" +\n2        #       f\"{self.param.number_of_doctors} doctors\")  ##NEW - no printing\n        # print(\"\")\n\n3        for run in range(self.param.number_of_runs):  ##NEW\n            random.seed(run)\n\n            my_model = Model(param=self.param, run_number=run)  ##NEW\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        ##NEW - no printing\n4        # self.print_trial_results()\n\n\n1\n\nSet param as an input to the Trial, and made a trial attribute.\n\n2\n\nDisabled printing.\n\n3\n\nReplaced all g with self.param.\n\n4\n\nDisabled printing.\n\n\n\n\n\n\n30.2.5 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential\n\n# Class to store parameter values.\nclass Param:  ##NEW\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number and\n    # instance of the parameter class when we create a new model.\n    def __init__(self, param, run_number):  ##NEW\n        # Store the passed in parameters\n        self.param = param  ##NEW\n\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=self.param.number_of_receptionists)  ##NEW\n        self.nurse = simpy.Resource(\n            self.env, capacity=self.param.number_of_nurses)  ##NEW\n        self.doctor = simpy.Resource(\n            self.env, capacity=self.param.number_of_doctors)  ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        self.patient_inter_arrival_dist = Exponential(\n            mean = self.param.patient_inter,  ##NEW\n            random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(\n            mean = self.param.mean_reception_time,  ##NEW\n            random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(\n            mean = self.param.mean_n_consult_time,  ##NEW\n            random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(\n            mean = self.param.mean_d_consult_time,  ##NEW\n            random_seed = self.run_number*5)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample()\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; self.param.prob_seeing_doctor:  ##NEW\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.nurse_consult_time_dist.sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=self.param.sim_duration)  ##NEW\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        return (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self, param):  ##NEW\n        # Store the model parameters\n        self.param = param  ##NEW\n\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        # print(f\"{self.param.number_of_receptionists} receptionists, \" +\n        #      f\"{self.param.number_of_nurses} nurses, \" +\n        #       f\"{self.param.number_of_doctors} doctors\")  ##NEW - no printing\n        # print(\"\")\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(self.param.number_of_runs):  ##NEW\n            random.seed(run)\n\n            my_model = Model(param=self.param, run_number=run)  ##NEW\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        ##NEW - no printing\n        # Once the trial (ie all runs) has completed, print the final results\n        # self.print_trial_results()",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Tests</span>"
    ]
  },
  {
    "objectID": "tests.html#testing-our-model",
    "href": "tests.html#testing-our-model",
    "title": "30  Tests",
    "section": "30.3 Testing our model",
    "text": "30.3 Testing our model\nThere are many different ways of categorising tests. We will focus on three types:\n\nFunctional testing\nUnit testing\nBack testing\n\n\n30.3.1 Functional tests\nFunctional tests verify that the system or components perform their intended functionality.\nFor example, we expect that the mean wait time for a nurse should decrease if:\n\nThe number of nurses increases.\nThe patient inter-arrival time increases (so there are fewer arrivals).\nThe length of the nurse consultation decreases.\n\nFor simplicity, this test just focuses the nurse waiting times, but this idea can be expanded to other resources and metrics in the model as well.\n\nimport pytest\nfrom full_model import Param, Trial\n\n\n@pytest.mark.parametrize('param_name, initial_value, adjusted_value', [\n    ('number_of_nurses', 3, 9),\n    ('patient_inter', 2, 15),\n    ('mean_n_consult_time', 30, 3),\n])\ndef test_waiting_time_utilisation(param_name, initial_value, adjusted_value):\n    \"\"\"\n    Test that adjusting parameters decreases the waiting time and utilisation.\n\n    Arguments:\n        param_name (string):\n            Name of parameter to change in the Param() class.\n        initial_value (float|int):\n            Value with which we expect longer waiting times.\n        adjusted_value (float|int):\n            Value with which we expect shorter waiting time.\n    \"\"\"\n    # Define helper function for the test\n    def helper_param(param_name, value):\n        \"\"\"\n        Helper function to set a specific parameter value, run the model for\n        a single replication and return the results of that run.\n\n        Arguments:\n            param_name (string):\n                Name of the parameter to modify.\n            value (float|int):\n                Value to assign to the parameter.\n\n        Returns:\n            dataframe:\n                Dataframe with the trial-level results.\n        \"\"\"\n        # Create instance of parameter class with default values but one run\n        param = Param()\n        param.number_of_runs = 1\n\n        # Modify specific parameter\n        setattr(param, param_name, value)\n\n        # Run replications and return the results from the run as a series\n        trial = Trial(param)\n        trial.run_trial()\n        return trial.df_trial_results.iloc[0]\n\n    # Run model with initial and adjusted values\n    initial_results = helper_param(param_name, initial_value)\n    adjusted_results = helper_param(param_name, adjusted_value)\n\n    # Check that nurse waiting times from adjusted model are lower\n    initial_wait = initial_results[\"Mean Q Time Nurse\"]\n    adjusted_wait = adjusted_results[\"Mean Q Time Nurse\"]\n    assert initial_wait &gt; adjusted_wait, (\n        f\"Changing '{param_name}' from {initial_value} to {adjusted_value} \" +\n        \"did not decrease waiting time for the nurse as expected: observed \" +\n        f\"waiting times of {initial_wait} and {adjusted_wait}, respectively.\"\n    )\n\nThese tests pass.\n\n\n\n\n\n\nTest output:\n\n\n\n\n\n\n\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /mnt/c/hsma6_des_book\nplugins: anyio-4.3.0\ncollected 3 items\n\ntests/test_functionaltest.py ...                                         [100%]\n\n============================== 3 passed in 0.89s ===============================\n\n\n&lt;ExitCode.OK: 0&gt;\n\n\n\n\n\n\n\n30.3.2 Unit tests\nUnit tests are a type of functional testing that focuses on individual components (e.g. methods, classes) and tests them in isolation to ensure they work as intended.\nFor example, we expect that our model should fail if the number of doctors or the patient inter-arrival time were set to 0. This is tested using test_zero_inputs.\n\nimport pytest\nfrom full_model import Param, Trial\n\n\n@pytest.mark.parametrize(\"param_name, value\", [\n    (\"number_of_doctors\", 0),\n    (\"patient_inter\", 0)\n])\ndef test_zero_inputs(param_name, value):\n    \"\"\"\n    Check that the model fails when inputs that are zero are used.\n\n    Arguments:\n        param_name (string):\n            Name of parameter to change in the Param() class.\n        value (float|int):\n            Invalid value for parameter.\n    \"\"\"\n    # Create parameter class with an invalid value\n    param = Param()\n    setattr(param, param_name, value)\n\n    # Verify that initialising the model raises an error\n    with pytest.raises(ValueError):\n        Trial(param)\n\nWhen we run the test, we see that both fail.\n\n\n\n\n\n\nTest output:\n\n\n\n\n\n\n\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /mnt/c/hsma6_des_book\nplugins: anyio-4.3.0\ncollected 2 items\n\ntests/test_unittest.py FF                                                [100%]\n\n=================================== FAILURES ===================================\n____________________ test_zero_inputs[number_of_doctors-0] _____________________\n\nparam_name = 'number_of_doctors', value = 0\n\n    @pytest.mark.parametrize(\"param_name, value\", [\n        (\"number_of_doctors\", 0),\n        (\"patient_inter\", 0)\n    ])\n    def test_zero_inputs(param_name, value):\n        \"\"\"\n        Check that the model fails when inputs that are zero are used.\n    \n        Arguments:\n            param_name (string):\n                Name of parameter to change in the Param() class.\n            value (float|int):\n                Invalid value for parameter.\n        \"\"\"\n        # Create parameter class with an invalid value\n        param = Param()\n        setattr(param, param_name, value)\n    \n        # Verify that initialising the model raises an error\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;\n\ntests/test_unittest.py:24: Failed\n______________________ test_zero_inputs[patient_inter-0] _______________________\n\nparam_name = 'patient_inter', value = 0\n\n    @pytest.mark.parametrize(\"param_name, value\", [\n        (\"number_of_doctors\", 0),\n        (\"patient_inter\", 0)\n    ])\n    def test_zero_inputs(param_name, value):\n        \"\"\"\n        Check that the model fails when inputs that are zero are used.\n    \n        Arguments:\n            param_name (string):\n                Name of parameter to change in the Param() class.\n            value (float|int):\n                Invalid value for parameter.\n        \"\"\"\n        # Create parameter class with an invalid value\n        param = Param()\n        setattr(param, param_name, value)\n    \n        # Verify that initialising the model raises an error\n&gt;       with pytest.raises(ValueError):\nE       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;\n\ntests/test_unittest.py:24: Failed\n=========================== short test summary info ============================\nFAILED tests/test_unittest.py::test_zero_inputs[number_of_doctors-0] - Failed: DID NOT RAISE &lt;class 'ValueError'&gt;\nFAILED tests/test_unittest.py::test_zero_inputs[patient_inter-0] - Failed: DID NOT RAISE &lt;class 'ValueError'&gt;\n============================== 2 failed in 7.96s ===============================\n\n\n&lt;ExitCode.TESTS_FAILED: 1&gt;\n\n\n\n\n\nThese tests fail as we do not have an error handling for these values. If we had proceeded to run_trial()…\n\nNumber of doctors = 0: The model would’ve stopped, as SimPy has built in functionality requiring that the capacity of resources must be greater than 0, and so it raises a ValueError and stops execution.\nPatient inter-arrival time = 0: The model would have run infinitely, as it would just constantly generating new patients.\n\nTo address this, we could add error handling which raises an error for users if they try to input a value of 0. For example, we could add the following code to our Model __init__ method:\n\n# Loop through the specified parameters\nfor param_name in [\"sim_duration\", \"patient_inter\"]:\n\n    # Get the value of that parameter by its name\n    param_value = getattr(self.param, param_name)\n\n    # Raise an error if it is 0 or less\n    if param_value &lt;= 0:\n        raise ValueError(\n            f\"Parameter '{param_name}' must be greater than 0, but has been\" +\n            f\"set to {param_value:.3f}.)\n\n\n\n30.3.3 Back tests\nBack tests check that the model code produces results consistent with those generated historically/from prior code.\nFirst, we’ll generate a set of expected results, with a specific set of parameters. Although this may seem unnecessary in this case, as they match our default parameters in our Param class, these are still specified to ensure that we are testing on the same parameters, even if defaults change in Param class.\n\nparam = Param()\nparam.patient_inter = 5\nparam.mean_reception_time = 2\nparam.mean_n_consult_time = 6\nparam.mean_d_consult_time = 20\nparam.number_of_receptionists = 1\nparam.number_of_nurses = 1\nparam.number_of_doctors = 2\nparam.prob_seeing_doctor = 0.6\nparam.sim_duration = 600\nparam.number_of_runs = 100\n\nWe’ll then run the model and save the results to .csv files.\n\n# Run trial\ntrial = Trial(param)\ntrial.run_trial()\n\n# Preview and save results to csv\nprint(trial.df_trial_results.head())\ntrial.df_trial_results.to_csv(\"tests/exp_results/trial.csv\")\n\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0           0.000000          57.193168            1.146714\n1              125.0           1.842723         144.688786            0.018501\n2              112.0           0.845851          15.299135            1.131864\n3              120.0           1.082325          82.669429            0.037010\n4              132.0           1.943043         107.474373            0.506261\n\n\nIn the test, we’ll run the same model parameters, then import and compare against the saved .csv file to check for any differences.\n\nfrom pathlib import Path\nimport pandas as pd\nfrom full_model import Param, Trial\n\n\ndef test_reproduction():\n    \"\"\"\n    Check that results from particular run of the model match those previously\n    generated using the code.\n    \"\"\"\n    # Define model parameters\n    param = Param()\n    param.patient_inter = 5\n    param.mean_reception_time = 2\n    param.mean_n_consult_time = 6\n    param.mean_d_consult_time = 20\n    param.number_of_receptionists = 1\n    param.number_of_nurses = 1\n    param.number_of_doctors = 2\n    param.prob_seeing_doctor = 0.6\n    param.sim_duration = 600\n    param.number_of_runs = 100\n\n    # Run trial\n    trial = Trial(param)\n    trial.run_trial()\n\n    # Compare the trial results\n    exp_trial = pd.read_csv(\n        Path(__file__).parent.joinpath(\"exp_results/trial.csv\"), index_col=0)\n    pd.testing.assert_frame_equal(trial.df_trial_results, exp_trial)\n\nThis test passes.\n\n\n\n\n\n\nTest output:\n\n\n\n\n\n\n\n============================= test session starts ==============================\nplatform linux -- Python 3.10.12, pytest-8.3.4, pluggy-1.5.0\nrootdir: /mnt/c/hsma6_des_book\nplugins: anyio-4.3.0\ncollected 1 item\n\ntests/test_backtest.py .                                                 [100%]\n\n============================== 1 passed in 4.63s ===============================\n\n\n&lt;ExitCode.OK: 0&gt;\n\n\n\n\n\nWe generate the expected results for our backtest in a seperate Python file or Jupyter notebook, rather than within the test itself. We then would generally run tests using the same pre-generated .csv files, without regenerating them. However, the test will fail if the model logic is intentionally changed, leading to different results from the same parameters. In that case, if we are certain that these changes are the reason for differing results, we should re-run the Python file or notebook to regenerate the .csv. It is crucial to exercise caution when doing this, to avoid unintentionally overwriting correct expected results.\n\n\n30.3.4 Further testing examples\nFor more inspiration, check out the Python DES RAP Template. Examples of other tests it includes are:\n\nFunctional tests for the impact of high demand on utilisation.\nFunctional tests checking for expected decreases in the number of arrivals.\nFunctional tests for an interval auditor.\nFunctional tests for parallel execution.\nFunctional tests for a warm-up period.\nUnit tests for the exponential class.\nUnit tests for a logging class.\nUnit tests for a modified parameter class which has functionality designed to prevent the addition of new attributes.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Tests</span>"
    ]
  },
  {
    "objectID": "event_logging.html",
    "href": "event_logging.html",
    "title": "31  Event Logging",
    "section": "",
    "text": "31.1 A sample event log\nIn this chapter and beyond, we will be using the term ‘event logging’ to describe the process of generating a step-by-step log of what happens to each entity as they pass through our system. The resulting file will be an ‘event log’.\nBut why bother with event logging? In previous chapters, we have managed to record a range of useful metrics from our simulation, and used these to display the performance of our model with different sets of parameters. In the debugging chapters, we have explored how to track down issues in our simulation with a combination of print statements and the logging module. So what else is there left to do?\nEvent logging can be a way to tackle both of the above in a robust, efficient and reusable way - while also opening up the use of a wide range of reusable boilerplate code for visualising, animating and formally testing our simulation outputs.\nFirst, it may be helpful to see what an event log looks like.\nA sample log is displayed below:\nimport pandas as pd\nevent_log = pd.read_csv(\"resources/sample_event_log.csv\")\n\nevent_log\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\nLet’s break down the key components.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#a-sample-event-log",
    "href": "event_logging.html#a-sample-event-log",
    "title": "31  Event Logging",
    "section": "",
    "text": "31.1.1 Mandatory Columns\nWe have several mandatory columns:\n\nentity_id\nevent_type\nevent\ntime\n\nentity_id: a unique identifider to allow us to follow a given entity through their journey\nevent_type: this column is used to distinguish between three key kinds of events:\n\narrival_departure: an entity first entering the system, or the entity leaving the system\nqueue: an entity beginning to queue for a resource\n\nthis can also be used to just generally record the movement of someone through points of a system that don’t necessarily have a traditional ‘queue’\n\nresource_use: this relates to anything where someone starts or ends their time with a resource in the system\n\nevent: this column further breaks down what is happening during each event type, such as what stage of the system people are waiting to interact with\ntime: this can be an absolute timestamp in the form of a datetime (e.g. 2027-01-01 23:01:47), or a relative timestamp in time units from the start of the simulation.\n\n\n31.1.2 Recommended Columns\nIn addition, the following columns are highly recommended to include:\nrun: this separates out results across multiple simulations, allowing for easy grouping of results by run\n\n\n31.1.3 Optional Columns\nThere are a few more recommended but optional columns:\n\nresource_id\npathway\n\nresource_id: While a traditional simpy resource does not have a concept of a resource ID, there are various ways we can tackle adding one into our system. Let’s assume we have 5 nurses - it’s very helpful to know which of these 5 nurses are in use at any given time for visualisation and auditing purposes. A discussion of approaches to this will be found in a later chapter (coming soon), or you can take a look at the populate_store function from vidigi for a discussion on one approach to this: click here",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#exploring-our-log",
    "href": "event_logging.html#exploring-our-log",
    "title": "31  Event Logging",
    "section": "31.2 Exploring our log",
    "text": "31.2 Exploring our log\nLet’s explore what we can find out even from this small sample of logs.\n\n31.2.1 Tracking the journey of a single entity/patient\nWe can easily filter down by entity ID to see how the journey of an individual looks\n\nevent_log[event_log[\"entity_id\"] == 1]\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n\n\n\n\n\nWe can see that this person arrived and was seen immediately.\n\n\n31.2.2 Calculating waits\nIn this event log, patients who wait for treatment (an event of ‘treatment_wait_begins’) will have the next event of ‘treatment_wait’. We’ll start by just pulling out those instances.\n\ntreatment_waits_df = event_log[event_log[\"event\"].isin([\"treatment_wait_begins\",\"treatment_begins\"])]\n\ntreatment_waits_df\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n\n\n\n\n\nNext, we’ll pivot these to a wide format.\n\ntreatment_waits_df_wide = treatment_waits_df.pivot(index=\"entity_id\", columns=\"event\", values=\"time\")\n\ntreatment_waits_df_wide = treatment_waits_df_wide[['treatment_wait_begins', 'treatment_begins']]\n\ntreatment_waits_df_wide\n\n\n\n\n\n\n\nevent\ntreatment_wait_begins\ntreatment_begins\n\n\nentity_id\n\n\n\n\n\n\n1\n0.000000\n0.000000\n\n\n2\n3.399660\n3.399660\n\n\n3\n8.497645\n8.497645\n\n\n4\n8.596678\n8.596678\n\n\n5\n8.608025\n40.317385\n\n\n6\n11.359739\n42.443230\n\n\n7\n19.509442\n48.809628\n\n\n8\n22.877356\n51.483457\n\n\n9\n26.653863\n77.447488\n\n\n10\n40.737793\n83.962251\n\n\n11\n71.026558\nNaN\n\n\n12\n87.458700\nNaN\n\n\n13\n87.465138\nNaN\n\n\n\n\n\n\n\nFinally, let’s work out the average wait for only those patients who were seen by someone before our simulation finished. We first need to calculate the difference between the two stamps, which in this simulation, represents a number of minutes\n\ntreatment_waits_df_wide[\"treatment_wait\"] = treatment_waits_df_wide[\"treatment_begins\"] - treatment_waits_df_wide[\"treatment_wait_begins\"]\n\ntreatment_waits_df_wide\n\n\n\n\n\n\n\nevent\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\nentity_id\n\n\n\n\n\n\n\n1\n0.000000\n0.000000\n0.000000\n\n\n2\n3.399660\n3.399660\n0.000000\n\n\n3\n8.497645\n8.497645\n0.000000\n\n\n4\n8.596678\n8.596678\n0.000000\n\n\n5\n8.608025\n40.317385\n31.709360\n\n\n6\n11.359739\n42.443230\n31.083491\n\n\n7\n19.509442\n48.809628\n29.300186\n\n\n8\n22.877356\n51.483457\n28.606101\n\n\n9\n26.653863\n77.447488\n50.793625\n\n\n10\n40.737793\n83.962251\n43.224458\n\n\n11\n71.026558\nNaN\nNaN\n\n\n12\n87.458700\nNaN\nNaN\n\n\n13\n87.465138\nNaN\nNaN\n\n\n\n\n\n\n\nNow we can calculate the mean of that column:\n\ntreatment_waits_df_wide[\"treatment_wait\"].mean()\n\nnp.float64(21.4717221)\n\n\nOr the median:\n\ntreatment_waits_df_wide[\"treatment_wait\"].median()\n\nnp.float64(28.9531435)\n\n\nOr the max and min waits:\n\ntreatment_waits_df_wide[\"treatment_wait\"].agg(['min', 'max'])\n\nmin     0.000000\nmax    50.793625\nName: treatment_wait, dtype: float64\n\n\nOr plot the distribution of waits:\n\nimport plotly.express as px\n\npx.histogram(treatment_waits_df_wide, x=\"treatment_wait\")\n\n                                                \n\n\nOr a boxplot:\n\npx.box(treatment_waits_df_wide, x=\"treatment_wait\")",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#exploring-a-bigger-event-log",
    "href": "event_logging.html#exploring-a-bigger-event-log",
    "title": "31  Event Logging",
    "section": "31.3 Exploring a bigger event log",
    "text": "31.3 Exploring a bigger event log\nThis would be a lot more powerful if we weren’t just working with a small sample of 50 rows of an event log. Let’s instead load in the full event log from this model, which runs for a lot longer and includes multiple runs. All our existing code can be reused.\n\nevent_log = pd.read_csv(\"resources/sample_event_log_10_day_10_run.csv\")\n\n# We'll limit this to the first 24 hours of our clinic\n\nevent_log = event_log[event_log[\"time\"] &lt;= 60 * 24]\n\nevent_log.sample(10)\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n40922\n238\nSimplest\nqueue\ntreatment_wait_begins\n1082.291238\nNaN\n4\n\n\n70708\n165\nSimplest\narrival_departure\narrival\n782.125020\nNaN\n7\n\n\n70407\n73\nSimplest\narrival_departure\narrival\n389.943492\nNaN\n7\n\n\n50236\n15\nSimplest\nresource_use\ntreatment_begins\n132.662770\n3.0\n5\n\n\n468\n69\nSimplest\narrival_departure\ndepart\n716.403642\nNaN\n0\n\n\n913\n139\nSimplest\narrival_departure\ndepart\n1404.088281\nNaN\n0\n\n\n60922\n105\nSimplest\narrival_departure\ndepart\n1109.931131\nNaN\n6\n\n\n20023\n5\nSimplest\nqueue\ntreatment_wait_begins\n42.496097\nNaN\n2\n\n\n41064\n278\nSimplest\narrival_departure\narrival\n1287.351088\nNaN\n4\n\n\n879\n242\nSimplest\narrival_departure\narrival\n1342.820571\nNaN\n0\n\n\n\n\n\n\n\nLet’s recalculate our waits. In fact - let’s write a function that could be used to make a wait table for any pair of events!\nWe’ll also make sure it takes account of the ‘run’ column.\n\ndef generate_difference_df(event_log, event_1, event_2, output_col_name):\n  difference_df = event_log[event_log[\"event\"].isin([event_1,event_2])]\n\n  difference_df_wide = difference_df.pivot(index=[\"entity_id\", \"run\"], columns=\"event\", values=\"time\")\n\n  difference_df_wide = difference_df_wide[[event_1,event_2]]\n\n  difference_df_wide[output_col_name] = difference_df_wide[event_2] - difference_df_wide[event_1]\n\n  return difference_df_wide.reset_index()\n\nLet’s run this and view the first 20 rows.\n\ntreatment_wait_df = generate_difference_df(event_log=event_log, event_1=\"treatment_wait_begins\", event_2=\"treatment_begins\", output_col_name=\"treatment_wait\")\n\ntreatment_wait_df.head(20)\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\n\n\n0\n1\n0\n0.000000\n0.000000\n0.0\n\n\n1\n1\n1\n0.000000\n0.000000\n0.0\n\n\n2\n1\n2\n0.000000\n0.000000\n0.0\n\n\n3\n1\n3\n0.000000\n0.000000\n0.0\n\n\n4\n1\n4\n0.000000\n0.000000\n0.0\n\n\n5\n1\n5\n0.000000\n0.000000\n0.0\n\n\n6\n1\n6\n0.000000\n0.000000\n0.0\n\n\n7\n1\n7\n0.000000\n0.000000\n0.0\n\n\n8\n1\n8\n0.000000\n0.000000\n0.0\n\n\n9\n1\n9\n0.000000\n0.000000\n0.0\n\n\n10\n2\n0\n3.399660\n3.399660\n0.0\n\n\n11\n2\n1\n12.021043\n12.021043\n0.0\n\n\n12\n2\n2\n8.965271\n8.965271\n0.0\n\n\n13\n2\n3\n0.033294\n0.033294\n0.0\n\n\n14\n2\n4\n10.399752\n10.399752\n0.0\n\n\n15\n2\n5\n2.645552\n2.645552\n0.0\n\n\n16\n2\n6\n11.489413\n11.489413\n0.0\n\n\n17\n2\n7\n4.011208\n4.011208\n0.0\n\n\n18\n2\n8\n17.040648\n17.040648\n0.0\n\n\n19\n2\n9\n2.861402\n2.861402\n0.0\n\n\n\n\n\n\n\nHere, we never have a wait because these people are entering an empty system.\nLet’s instead look at a different patient.\n\ntreatment_wait_df[treatment_wait_df[\"entity_id\"] == 40]\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\n\n\n390\n40\n0\n225.946145\n374.475154\n148.529008\n\n\n391\n40\n1\n166.195041\n396.502222\n230.307181\n\n\n392\n40\n2\n229.388022\n384.693144\n155.305122\n\n\n393\n40\n3\n198.590107\n376.281301\n177.691195\n\n\n394\n40\n4\n209.135743\n370.569622\n161.433878\n\n\n395\n40\n5\n227.132040\n376.794591\n149.662551\n\n\n396\n40\n6\n173.002070\n383.515632\n210.513562\n\n\n397\n40\n7\n223.578745\n378.418622\n154.839878\n\n\n398\n40\n8\n228.714086\n385.852087\n157.138001\n\n\n399\n40\n9\n176.753615\n370.958861\n194.205245\n\n\n\n\n\n\n\nLet’s sample a range of other quick visualisations we can make.\n\n31.3.1 Cumulative arrivals\nLet’s first just take a look at the arrivals for a single run, with each dot representing a single person arriving in our system.\n\npx.scatter(\n  event_log[\n    (event_log[\"run\"]==1) &\n    (event_log[\"event\"]==\"arrival\")],\n    x=\"time\",\n    y=\"entity_id\"\n    )\n\n                                                \n\n\nHere, we can see how cumulative arrivals varied by run.\n\npx.line(\n  event_log[event_log[\"event\"]==\"arrival\"],\n  x=\"time\",\n  y=\"entity_id\",\n  color=\"run\"\n  )\n\n                                                \n\n\n\n\n31.3.2 Event scatterplot\n\npx.scatter(\n  event_log[event_log[\"run\"]==1],\n  y=\"time\",\n  color=\"event\",\n  x=\"entity_id\"\n  )\n\n                                                \n\n\nWe can tell that the treatment wait very quickly gets out of hand for our individuals as the simulation progresses.\n\n\n31.3.3 Treatment duration\n\ntreatment_duration_df = generate_difference_df(\n  event_log=event_log,\n  event_1=\"treatment_begins\",\n  event_2=\"treatment_complete\",\n  output_col_name=\"treatment_duration\")\n\ntreatment_duration_df.head(20)\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_begins\ntreatment_complete\ntreatment_duration\n\n\n\n\n0\n1\n0\n0.000000\n40.317385\n40.317385\n\n\n1\n1\n1\n0.000000\n41.226014\n41.226014\n\n\n2\n1\n2\n0.000000\n32.732000\n32.732000\n\n\n3\n1\n3\n0.000000\n40.023184\n40.023184\n\n\n4\n1\n4\n0.000000\n37.026630\n37.026630\n\n\n5\n1\n5\n0.000000\n34.941718\n34.941718\n\n\n6\n1\n6\n0.000000\n36.785746\n36.785746\n\n\n7\n1\n7\n0.000000\n41.752122\n41.752122\n\n\n8\n1\n8\n0.000000\n38.779312\n38.779312\n\n\n9\n1\n9\n0.000000\n42.284465\n42.284465\n\n\n10\n2\n0\n3.399660\n42.443230\n39.043571\n\n\n11\n2\n1\n12.021043\n46.891254\n34.870211\n\n\n12\n2\n2\n8.965271\n46.903314\n37.938043\n\n\n13\n2\n3\n0.033294\n40.296613\n40.263318\n\n\n14\n2\n4\n10.399752\n53.054173\n42.654422\n\n\n15\n2\n5\n2.645552\n39.743828\n37.098276\n\n\n16\n2\n6\n11.489413\n49.827460\n38.338047\n\n\n17\n2\n7\n4.011208\n41.798441\n37.787233\n\n\n18\n2\n8\n17.040648\n51.984157\n34.943509\n\n\n19\n2\n9\n2.861402\n42.211944\n39.350541\n\n\n\n\n\n\n\n\npx.box(\n  treatment_duration_df,\n  x=\"treatment_duration\",\n  title=\"Variation in treatment duration\"\n  )\n\n                                                \n\n\n\npx.box(\n  treatment_duration_df, x=\"treatment_duration\", color=\"run\",\n  range_x=[\n          0,\n          max(treatment_duration_df[\"treatment_duration\"]) * 1.1\n          ],\n  title=\"Variation in treatment duration by run\"\n        )\n\n                                                \n\n\n\n\n31.3.4 Throughput\n\npatients_entering_system = event_log[event_log[\"event\"] == \"arrival\"]\n\npatients_entering_system = (\n  patients_entering_system\n  .groupby('run')[['entity_id']]\n  .count()\n  .rename(columns={\"entity_id\": \"entering_system\"})\n  )\n\npatients_entering_system\n\n\n\n\n\n\n\n\nentering_system\n\n\nrun\n\n\n\n\n\n0\n259\n\n\n1\n303\n\n\n2\n276\n\n\n3\n285\n\n\n4\n302\n\n\n5\n270\n\n\n6\n292\n\n\n7\n294\n\n\n8\n258\n\n\n9\n286\n\n\n\n\n\n\n\n\npatients_leaving_system = event_log[event_log[\"event\"] == \"depart\"]\n\npatients_leaving_system = (\n  patients_leaving_system.groupby('run')[['entity_id']]\n  .count()\n  .rename(columns={\"entity_id\": \"leaving_system\"})\n  )\n\npatients_leaving_system\n\n\n\n\n\n\n\n\nleaving_system\n\n\nrun\n\n\n\n\n\n0\n140\n\n\n1\n142\n\n\n2\n141\n\n\n3\n141\n\n\n4\n142\n\n\n5\n143\n\n\n6\n140\n\n\n7\n142\n\n\n8\n143\n\n\n9\n142\n\n\n\n\n\n\n\n\npatient_throughput_df = patients_entering_system.merge(\n  patients_leaving_system,\n  left_index=True,\n  right_index=True\n  )\n\npatient_throughput_df[\"throughput\"] = patient_throughput_df[\"leaving_system\"] / patient_throughput_df[\"entering_system\"]\n\npatient_throughput_df[\"throughput_display\"] = patient_throughput_df[\"throughput\"].apply(lambda x: f\"{x:.1%}\")\n\npatient_throughput_df\n\n\n\n\n\n\n\n\nentering_system\nleaving_system\nthroughput\nthroughput_display\n\n\nrun\n\n\n\n\n\n\n\n\n0\n259\n140\n0.540541\n54.1%\n\n\n1\n303\n142\n0.468647\n46.9%\n\n\n2\n276\n141\n0.510870\n51.1%\n\n\n3\n285\n141\n0.494737\n49.5%\n\n\n4\n302\n142\n0.470199\n47.0%\n\n\n5\n270\n143\n0.529630\n53.0%\n\n\n6\n292\n140\n0.479452\n47.9%\n\n\n7\n294\n142\n0.482993\n48.3%\n\n\n8\n258\n143\n0.554264\n55.4%\n\n\n9\n286\n142\n0.496503\n49.7%\n\n\n\n\n\n\n\n\n\n31.3.5 Animation\nUsing the vidigi package, we can take our event log and - with only minor adjustments and additions - create a full animation of our system.\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.n_cubicles = 4 # In this case, I know that there were four resources available.\n\nparams = model_params()\n\nprint(f\"Number of nurses: {params.n_cubicles}\")\n\nNumber of nurses: 4\n\n\n\nfrom vidigi.animation import animate_activity_log\n\nanimate_activity_log(\n        # We need to ensure we only pass in a single run of the model\n        # We also need to ensure that the column 'entity_id' is renamed to 'patient' to match\n        # vidigi's expectations - though this will be made more flexible in a future version\n        # of the package\n        event_log=event_log[event_log['run']==1].rename(columns={\"entity_id\":\"patient\"}),\n        event_position_df=event_position_df,\n        scenario=params,\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=event_log[\"time\"].max().astype('int'),\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 17:38:12\nIteration through minute-by-minute logs complete 17:38:13\nSnapshot df concatenation complete at 17:38:13\nReshaped animation dataframe finished construction at 17:38:14\nPlacement dataframe finished construction at 17:38:14\n\n\nC:\\Users\\Sammi\\anaconda3\\envs\\des\\Lib\\site-packages\\vidigi\\animation.py:119: FutureWarning:\n\nThe 'unit' keyword in TimedeltaIndex construction is deprecated and will be removed in a future version. Use pd.to_timedelta instead.\n\n\n\nOutput animation generation complete at 17:38:15\nTotal Time Elapsed: 2.19 seconds",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#adding-event-logging-to-your-own-model",
    "href": "event_logging.html#adding-event-logging-to-your-own-model",
    "title": "31  Event Logging",
    "section": "31.4 Adding event logging to your own model",
    "text": "31.4 Adding event logging to your own model\nHere, we’re going to work with the very basic model from the chapter ‘An Example SimPy Model’.\n\n\n\n\n\n\nTip\n\n\n\nChanged code will be highlighted in the right-hand column, with unchanged column displayed less brightly.\n\n\n\n31.4.1 the g Class\nOur g class is unchanged.\n\n\n31.4.2 the Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\n31.4.3 the Model Class\n\n31.4.3.1 The init method\nTo our init method for the Model class, we add an empty list that will store event logs throughout the model run for each patient.\n\n\n\n31.4.3.1.1 Original\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\n31.4.3.1.2 With Event Logging Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Add an empty list to store our event logs in \n    self.event_log = [] \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index)\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\n31.4.3.2 the generator_patient_arrivals method\nThis method is unchanged.\n\n\n31.4.3.3 the attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\n\n\n\n\n\n\nTip\n\n\n\nAppending rows to a dataframe is a very slow and memory-intensive operation and could negatively affect our simulation runtime.\nA more efficient approach is to add dictionaries to a list. Each dictionary corresponds to one row of our eventual event log dataframe, and contains the keys that will form our column names, and the values that will be the values in each row.\nAt the end of the process, we will pass these dictionaries to pandas and it will convert them into a dataframe - so the end result is the same, but this approach is much faster overall.\n\n\nEvent logging takes the format below:\n\nself.event_log.append(\n        {'patient': entity_identifier,\n            'pathway': 'My_Pathway_Name',\n            'event_type': 'arrival_departure', # or 'queue', 'resource_use', or 'resource_use_end'\n            'event': 'arrival', # or 'depart', or for 'queue' and 'resource_use' or 'resource_use_end' you can determine your own event name\n            'time': self.env.now}\n    )\n\n\n\n\n\n\n\nTip\n\n\n\nWhile these columns are the bare minimum, you can take this opportunity to add as many additional fields as you see fit!\nBear in mind that the event log files can get quite unwieldy, and it may not be very efficient if you are adding in extra columns where the values are not always present.\nThis is another benefit of using dictionaries, however - you don’t always have to pass the same number of key-value pairs; the resulting dataframe will just deal with this and leave any missing ‘columns’ empty for that row.\n\n\nHere, we will begin to add our logs.\nIn this case, we are adding logging at 5 points\n\narriving\nbeginning to queue (in this case, this will be the same as the arrival time)\nbeginning treatment\nending treatment\ndeparting\n\n\n\n\n31.4.3.3.1 Original\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n\n\n\n\n\n\n31.4.3.3.2 With Event Logging Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append( \n            {'patient': patient.identifier, \n                'pathway': 'Simplest', \n                'event': 'treatment_begins', \n                # for a resource_use, you can define your chosen event name\n                'event_type': 'resource_use', \n                'time': self.env.now \n                } \n        ) \n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append( \n            {'patient': patient.identifier, \n                'pathway': 'Simplest', \n                # for a resource_use_end, you can define your chosen event name\n                'event': 'treatment_complete', \n                'event_type': 'resource_use_end', \n                'time': self.env.now \n                } \n        ) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    ) \n\n\n\n\n\n\n31.4.3.4 the calculate_run_results method\nThis method is unchanged.\n\n\n31.4.3.5 the run method\nOur concern in the run method is adding a way to extract the event log.\nIt will also be important to augment the event log with a run number - we already pass a run number attribute when initialising our Model class, so we can just access that.\nFinally, we change our model to output a dictionary of our results_df and our event log. You could approach this in different ways, like returning a list, or only returning the event log and calculating all results from the event log instead.\n\n\n\n31.4.3.5.1 Original\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\n31.4.3.5.2 With Event Logging Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    self.event_log = pd.DataFrame(self.event_log) \n\n    self.event_log[\"run\"] = self.run_number \n\n    return {'results': self.results_df, 'event_log': self.event_log}  \n\n\n\n\n\n\n\n31.4.4 the Trial Class\n\n31.4.4.1 the init method\nIn this, we just need to add an empty list which will hold all the event log dataframes from the individual runs.\n\n\n\n31.4.4.1.1 Original\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\n31.4.4.1.2 With Event Logging Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n\n\n\n\n\n\n31.4.4.2 the run_trial method\nFinally, in every iteration, we split out the results from our model (the dictionary) into two objects - one of which is our event log.\nWe can then add this event log - remembering that it also has a column added identifying which run the event log relates to - into our list.\nOnce we have finished the for loop - i.e. we have completed every run of the model - we can join our event log into one large dataframe.\nFinally, to make it easier to experiment with building visualisations, metrics, animations and more without having to rerun the model each time, we will save the resulting dataframe as a csv.\n\n\n\n\n\n\nTip\n\n\n\nYou may wish to explore a datatype-preserving format like pickle, arrow or parquet for this export so that you don’t run into issues with dates - but csv has the benefit of being cross-plaform, human readable and machine readable.\nIf you are using version control (Git/GitHub), it’s recommended to add this file to your .gitignore - it’s quite large and will change frequently!\n\n\n\n\n\n31.4.4.2.1 Original\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\n31.4.4.2.2 With Event Logging Modifications\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        model_outputs = my_model.run()\n        patient_level_results = model_outputs[\"results\"] \n        event_log = model_outputs[\"event_log\"] \n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n        self.all_event_logs.append(event_log) \n\n    self.all_event_logs = pd.concat(self.all_event_logs) \n\n    self.all_event_logs.to_csv(\"event_logs.csv\")",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#logging-resource-ids",
    "href": "event_logging.html#logging-resource-ids",
    "title": "31  Event Logging",
    "section": "31.5 Logging resource IDs",
    "text": "31.5 Logging resource IDs\nIf we want to make use of our full ability to monitor resource utilisation at a detailed level, and to create animations with the vidigi package, we also need to change the way we request resources to account for the fact we are now using a simpy store instead of directly interacting with our simpy resources.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\n# Seize a treatment resource when available\ntreatment_resource = yield self.treatment_cubicles.get()\n\n# ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n# Resource is no longer in use, so put it back in the store\nself.treatment_cubicles.put(treatment_resource)\n\n\n31.5.1 Imports\nWe will need to add the following to our imports:\n\nfrom vidigi.utils import populate_store\n\n\n\n31.5.2 The Model Class\n\n31.5.2.1 the init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to do two things: - create a simpy Store that we will store our resources in - use the vidigi helper function populate_store() to generate a store full of special resources that each have a unique ID we can track when doing our event logging\nOverall, the use of stores won’t generally change your code too much - and we cover exactly what needs to change a little later in this document.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others.\n\n\n\n31.5.2.1.1 Original\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\n31.5.2.1.2 With Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Store(self.env) \n\n    populate_store(  \n        num_resources=g.n_cubicles, \n        simpy_store=self.treatment_cubicles, \n        sim_env=self.env\n        ) \n\n\n\n\n\n\n31.5.2.2 the attend_clinic method\nWe will return to our attend_clinic method, where we previously added in event logging, and now\n\nmake use of this new resource ID attribute\nmake the required changes to how resources are requested and released for the next user\n\n\n\n\n31.5.2.2.1 Original\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append(\n        {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event_type': 'arrival_departure',\n            # you must use this event name for arrival events\n            'event': 'arrival',\n            'time': self.env.now}\n    )\n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append(\n        {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins',\n            'event_type': 'queue',\n            'time': self.env.now}\n    )\n\n    # Seize a treatment resource when available\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                # for a resource_use, you can define your chosen event name\n                'event_type': 'resource_use',\n                'time': self.env.now\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                # for a resource_use_end, you can define your chosen event name\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now\n                }\n        )\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append(\n        {'patient': patient.identifier,\n        'pathway': 'Simplest',\n        'event': 'depart', # you must use this event name for departure events\n        'event_type': 'arrival_departure',\n        'time': self.env.now}\n    )\n\n\n\n\n\n\n31.5.2.2.2 With Custom Resource Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    treatment_resource = yield self.treatment_cubicles.get() \n\n    # record the waiting time for registration\n    self.wait_treat = self.env.now - start_wait\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event': 'treatment_begins', \n            # for a resource_use, you can define your chosen event name\n            'event_type': 'resource_use', \n            'time': self.env.now, \n            # grab the resource id from the treatment_resource requested\n            'resource_id': treatment_resource.id_attribute \n            } \n    ) \n\n    # sample treatment duration\n    self.treat_duration = self.treat_dist.sample()\n    yield self.env.timeout(self.treat_duration)\n\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a resource_use_end, you can define your chosen event name\n            'event': 'treatment_complete', \n            'event_type': 'resource_use_end', \n            'time': self.env.now, \n            'resource_id': treatment_resource.id_attribute} \n    ) \n\n    # Resource is no longer in use, so put it back in the store \n    self.treatment_cubicles.put(treatment_resource) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    )",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#summary",
    "href": "event_logging.html#summary",
    "title": "31  Event Logging",
    "section": "31.6 Summary",
    "text": "31.6 Summary\nIn this chapter, we have demonstrated just a few of the things you can do with event logs, and how you can efficiently add them to an existing model.\nIn the rest of this section, we will dive deeper into some reproducible snippets and patterns to help you generate useful outputs from event logs, as well as a deeper dive into turning these into process maps with bupaR and animations with vidigi.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "process_logs_with_bupar.html",
    "href": "process_logs_with_bupar.html",
    "title": "32  Reshaping our event logs for bupaR",
    "section": "",
    "text": "32.1 Exploring bupaR Outputs\nbupaR is an R package for process mining.\nNow - while we’ve primarly worked in Python throughout, sometimes we come across an R package that suits our needs better than the Python equivalent. While the excellent pm4py process mining package exists too, bupaR’s visuals are top notch.\nThere are a few different ways we could get our Python event logs to work with bupaR:\nIn this chapter, we will use option 4.\nThe first thing we are going to do is add some extra bits that bupar requires.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Reshaping our event logs for bupaR</span>"
    ]
  },
  {
    "objectID": "process_logs_with_bupar.html#exploring-bupar-outputs",
    "href": "process_logs_with_bupar.html#exploring-bupar-outputs",
    "title": "32  Reshaping our event logs for bupaR",
    "section": "",
    "text": "32.1.1 bupaR Static Outputs\n\n32.1.1.1 Frequency Maps\n\n32.1.1.1.1 Absolute (counts)\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute\"))\n\nWarning in process_map.eventlog(., frequency(\"absolute\")): Some of the\ntimestamps in the supplied event log are missing (NA values). This may result\nin a invalid process map!\n\n\n\n\n\n\n\n\n32.1.1.1.2 Absolute case\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute-case\"))\n\nWarning in process_map.eventlog(., frequency(\"absolute-case\")): Some of the\ntimestamps in the supplied event log are missing (NA values). This may result\nin a invalid process map!\n\n\n\n\n\n\n\n\n32.1.1.1.3 Relative\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative\"))\n\nWarning in process_map.eventlog(., frequency(\"relative\")): Some of the\ntimestamps in the supplied event log are missing (NA values). This may result\nin a invalid process map!\n\n\n\n\n\n\n\n\n\n32.1.1.2 Performance maps\n\n32.1.1.2.1 Mean Times\n\nactivity_log %&gt;%\n    process_map(performance())\n\nWarning in process_map.eventlog(., performance()): Some of the timestamps in\nthe supplied event log are missing (NA values). This may result in a invalid\nprocess map!\n\n\n\n\n\n\n\n\n32.1.1.2.2 Max Times\n\nactivity_log %&gt;%\n    process_map(performance(FUN = max))\n\nWarning in process_map.eventlog(., performance(FUN = max)): Some of the\ntimestamps in the supplied event log are missing (NA values). This may result\nin a invalid process map!\n\n\nWarning: There was 1 warning in `summarize()`.\nℹ In argument: `label = do.call(...)`.\nℹ In group 5: `ACTIVITY_CLASSIFIER_ = NA` and `from_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\n\n\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `value = do.call(...)`.\nℹ In group 1: `ACTIVITY_CLASSIFIER_ = \"ARTIFICIAL_END\"`, `next_act = NA`,\n  `from_id = 1`, `to_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\n\n\n\n\n\n32.1.1.3 Common Routes\n\nactivity_log %&gt;%\n    trace_explorer(n_traces = 10)\n\nWarning: Fewer traces (2) found than specified `n_traces` (10).\n\n\n\n\n\n\n\n\n\n\n\n32.1.1.4 Activity Presence\n\nactivity_log %&gt;%\n    activity_presence() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n32.1.1.5 Processing Time\n\nactivity_log %&gt;%\n    processing_time(\"resource-activity\", units = \"mins\") %&gt;%\n    plot()\n\nWarning: Removed 3 rows containing non-finite values (`stat_boxplot()`).\n\n\nWarning: The following aesthetics were dropped during statistical transformation: colour\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"activity\", units = \"mins\") %&gt;%\n    plot()\n\nWarning: Removed 3 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n32.1.1.6 Idle Time\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\n32.1.2 bupaR Animated Outputs\n\nactivity_log %&gt;%\n    animate_process()\n\nWarning in process_map.eventlog(eventlog, render = F, ...): Some of the\ntimestamps in the supplied event log are missing (NA values). This may result\nin a invalid process map!",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Reshaping our event logs for bupaR</span>"
    ]
  },
  {
    "objectID": "process_logs_with_bupar.html#working-with-a-more-advanced-simulation-log",
    "href": "process_logs_with_bupar.html#working-with-a-more-advanced-simulation-log",
    "title": "32  Reshaping our event logs for bupaR",
    "section": "32.2 Working with a more advanced simulation log",
    "text": "32.2 Working with a more advanced simulation log\n\n32.2.1 Generating a flexible python function for moving from event logs to process logs\nLet’s turn our code for processing our event log into its own reusable function.\nTo help our visualisations distinguish between different resources better, we’ll also adjust the resource IDs to reflect which process they are being used with.\n\ndef process_event_log_for_bupar(event_log_path):\n    event_log = pd.read_csv(event_log_path)\n\n    df = event_log[(event_log[\"event_type\"]==\"queue\") |\n                (event_log[\"event_type\"]==\"resource_use\")].copy()\n\n    df[\"activity_id\"] = df.groupby(\"run\").cumcount() + 1\n\n    # Duplicate rows and modify them\n    df_start = df.copy()\n    df_start[\"lifecycle_id\"] = \"start\"\n\n    df_end = df.copy()\n    df_end[\"lifecycle_id\"] = \"complete\"\n\n    # Shift timestamps for 'end' rows\n    df_end[\"time\"] = df_end[\"time\"].shift(-1)\n\n    # Combine and sort\n    df_combined = pd.concat([df_start, df_end]).sort_index(kind=\"stable\")\n\n    # Drop last 'end' row (since there’s no next row to get a timestamp from)\n    df_combined = df_combined[:-1]\n\n    df_combined[\"resource_id\"] = df_combined.apply(lambda x: f\"{x['event']}_{x['resource_id']:.0f}\", axis=1)\n\n    df_combined.to_csv(f\"{event_log_path.replace('.csv', '')}_bupar_log.csv\", index=False)\n\n    return df_combined\n\nbupar_log_complex = process_event_log_for_bupar(\"resources/complex_event_log.csv\")\n\nbupar_log_complex.head(30)\n\n    entity_id     pathway  ... activity_id lifecycle_id\n1           1  Non-Trauma  ...           1        start\n1           1  Non-Trauma  ...           1     complete\n2           1  Non-Trauma  ...           2        start\n2           1  Non-Trauma  ...           2     complete\n4           2  Non-Trauma  ...           3        start\n4           2  Non-Trauma  ...           3     complete\n5           2  Non-Trauma  ...           4        start\n5           2  Non-Trauma  ...           4     complete\n7           1  Non-Trauma  ...           5        start\n7           1  Non-Trauma  ...           5     complete\n8           1  Non-Trauma  ...           6        start\n8           1  Non-Trauma  ...           6     complete\n10          2  Non-Trauma  ...           7        start\n10          2  Non-Trauma  ...           7     complete\n11          2  Non-Trauma  ...           8        start\n11          2  Non-Trauma  ...           8     complete\n13          1  Non-Trauma  ...           9        start\n13          1  Non-Trauma  ...           9     complete\n14          1  Non-Trauma  ...          10        start\n14          1  Non-Trauma  ...          10     complete\n16          2  Non-Trauma  ...          11        start\n16          2  Non-Trauma  ...          11     complete\n17          2  Non-Trauma  ...          12        start\n17          2  Non-Trauma  ...          12     complete\n22          2  Non-Trauma  ...          13        start\n22          2  Non-Trauma  ...          13     complete\n23          2  Non-Trauma  ...          14        start\n23          2  Non-Trauma  ...          14     complete\n25          3  Non-Trauma  ...          15        start\n25          3  Non-Trauma  ...          15     complete\n\n[30 rows x 9 columns]\n\n\n\n\n32.2.2 Generating a flexible R function for generating a bupaR activity log\nLet’s also take this opportunity to turn our conversion of the logs into a function.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(bupaverse)\nlibrary(rlang)\n\n\nAttaching package: 'rlang'\n\n\nThe following object is masked from 'package:edeaR':\n\n    trace_length\n\nlibrary(glue)\n\ncreate_activity_log &lt;- function(filepath,\n                                run_id = 1,\n                                simulation_start = ymd_hms(\"2025-01-01 00:00:00\"),\n                                case_id = \"entity_id\",\n                                activity_id = \"event\",\n                                activity_instance_id = \"activity_id\",\n                                lifecycle_id = \"lifecycle_id\",\n                                resource_id = \"resource_id\",\n                                time_column = \"time\",\n                                run_column = \"run\") {\n  # Read the data\n  data &lt;- readr::read_csv(filepath)\n\n  # Validate that all required columns exist\n  required_cols &lt;- c(case_id, activity_id, activity_instance_id, lifecycle_id,\n                     resource_id, time_column, run_column)\n  missing_cols &lt;- setdiff(required_cols, names(data))\n  if (length(missing_cols) &gt; 0) {\n    stop(glue::glue(\"Missing required columns: {paste(missing_cols, collapse=', ')}\"))\n  }\n\n  # Tidy evaluation symbols\n  time_col_sym &lt;- rlang::sym(time_column)\n  run_col_sym &lt;- rlang::sym(run_column)\n\n  # Validate that the requested run_id exists\n  available_runs &lt;- unique(dplyr::pull(data, !!run_col_sym))\n  if (!run_id %in% available_runs) {\n    stop(glue::glue(\"Run ID {run_id} not found. Available run IDs: {paste(available_runs, collapse=', ')}\"))\n  }\n\n  # Filter, create timestamp, and build event log\n  activity_log &lt;- data |&gt;\n    dplyr::filter(!!run_col_sym == run_id) |&gt;\n    dplyr::mutate(timestamp_dt = simulation_start + lubridate::dminutes(!!time_col_sym)) |&gt;\n    bupaR::eventlog(\n      case_id = case_id,\n      activity_id = activity_id,\n      activity_instance_id = activity_instance_id,\n      lifecycle_id = lifecycle_id,\n      timestamp = \"timestamp_dt\",\n      resource_id = resource_id\n    )\n\n  return(activity_log)\n}\n\n\n\n\n\n# Example usage:\nactivity_log &lt;- create_activity_log(\"resources/complex_event_log_bupar_log.csv\")\n\nRows: 163533 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): pathway, event, event_type, resource_id, lifecycle_id\ndbl (4): entity_id, time, run, activity_id\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# View a few entries\nhead(activity_log, 20)\n\n# Log of 20 events consisting of:\n2 traces \n2 cases \n10 instances of 6 activities \n8 resources \nEvents occurred from 2025-01-01 00:37:35 until 2025-01-01 01:12:25 \n \n# Variables were mapped as follows:\nCase identifier:        entity_id \nActivity identifier:        event \nResource identifier:        resource_id \nActivity instance identifier:   activity_id \nTimestamp:          timestamp_dt \nLifecycle transition:       lifecycle_id \n\n# A tibble: 20 × 11\n   entity_id pathway    event     event_type  time resource_id   run activity_id\n       &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1         1 Non-Trauma triage_w… queue       37.6 triage_wai…     1           1\n 2         1 Non-Trauma triage_w… queue       37.6 triage_wai…     1           1\n 3         1 Non-Trauma triage_b… resource_…  37.6 triage_beg…     1           2\n 4         1 Non-Trauma triage_b… resource_…  51.8 triage_beg…     1           2\n 5         2 Non-Trauma triage_w… queue       51.8 triage_wai…     1           3\n 6         2 Non-Trauma triage_w… queue       51.8 triage_wai…     1           3\n 7         2 Non-Trauma triage_b… resource_…  51.8 triage_beg…     1           4\n 8         2 Non-Trauma triage_b… resource_…  52.0 triage_beg…     1           4\n 9         1 Non-Trauma MINORS_r… queue       52.0 MINORS_reg…     1           5\n10         1 Non-Trauma MINORS_r… queue       52.0 MINORS_reg…     1           5\n11         1 Non-Trauma MINORS_r… resource_…  52.0 MINORS_reg…     1           6\n12         1 Non-Trauma MINORS_r… resource_…  60.3 MINORS_reg…     1           6\n13         1 Non-Trauma MINORS_e… queue       60.3 MINORS_exa…     1           7\n14         1 Non-Trauma MINORS_e… queue       60.3 MINORS_exa…     1           7\n15         1 Non-Trauma MINORS_e… resource_…  60.3 MINORS_exa…     1           8\n16         1 Non-Trauma MINORS_e… resource_…  65.9 MINORS_exa…     1           8\n17         2 Non-Trauma MINORS_r… queue       65.9 MINORS_reg…     1           9\n18         2 Non-Trauma MINORS_r… queue       65.9 MINORS_reg…     1           9\n19         2 Non-Trauma MINORS_r… resource_…  65.9 MINORS_reg…     1          10\n20         2 Non-Trauma MINORS_r… resource_…  72.4 MINORS_reg…     1          10\n# ℹ 3 more variables: lifecycle_id &lt;chr&gt;, timestamp_dt &lt;dttm&gt;, .order &lt;int&gt;\n\n\n\n\n32.2.3 bupaR Static Outputs\n\n32.2.3.1 Frequency Maps\n\n32.2.3.1.1 Absolute (counts)\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute\"))\n\n\n\n\n\n\n\n32.2.3.1.2 Absolute case\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute-case\"))\n\n\n\n\n\n\n\n32.2.3.1.3 Relative\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative\"))\n\n\n\n\n\n\n\n\n32.2.3.2 Performance maps\n\n32.2.3.2.1 Mean Times\n\nactivity_log %&gt;%\n    process_map(performance())\n\n\n\n\n\n\n\n32.2.3.2.2 Max Times\n\nactivity_log %&gt;%\n    process_map(performance(FUN = max))\n\nWarning: There was 1 warning in `summarize()`.\nℹ In argument: `label = do.call(...)`.\nℹ In group 15: `ACTIVITY_CLASSIFIER_ = NA` and `from_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\n\n\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `value = do.call(...)`.\nℹ In group 1: `ACTIVITY_CLASSIFIER_ = \"ARTIFICIAL_END\"`, `next_act = NA`,\n  `from_id = 1`, `to_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\n\n\n\n\n\n32.2.3.3 Common Routes\n\nactivity_log %&gt;%\n    trace_explorer(n_traces = 10)\n\nWarning: Fewer traces (9) found than specified `n_traces` (10).\n\n\n\n\n\n\n\n\n\n\n\n32.2.3.4 Activity Presence\n\nactivity_log %&gt;%\n    activity_presence() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n32.2.3.5 Processing Time\n\nactivity_log %&gt;%\n    processing_time(\"resource-activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n32.2.3.6 Idle Time\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\n32.2.4 bupaR Animated Outputs\n\nactivity_log %&gt;%\n    animate_process(style = \"background-color: white;\")",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Reshaping our event logs for bupaR</span>"
    ]
  },
  {
    "objectID": "visualising_des_models.html",
    "href": "visualising_des_models.html",
    "title": "33  (Coming Soon!) Visualising Entity Flow",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>(Coming Soon!) Visualising Entity Flow</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html",
    "href": "tracking_resource_utilisation.html",
    "title": "34  Tracking Resource Utilisation",
    "section": "",
    "text": "34.1 Looking at average resource utilisation across a run\nWhen running a model, it’s useful to be able to track a few things about your resources.\nFor example, it would be useful to know that your nurse resources are being utilised 89% of the time.\nHowever, it may also be useful to know that due to fluctuations in demand throughout the day, at 4pm the average utilisation across several runs is 60%, but at 8pm the average utilisation is at 95%.\nMonitoring utilisation of resources in both of these ways can be helpful to show the performance of your model.\nTo calculate the percentage of time a resource was being utilised overall, we need to start tracking how long each entity in our model spent using a resource.\nWhat we can then do is:\nWe can track this by adding an additional attribute to our patient class.\nLet’s return to the very simplest version of the model for this.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html#looking-at-average-resource-utilisation-across-a-run",
    "href": "tracking_resource_utilisation.html#looking-at-average-resource-utilisation-across-a-run",
    "title": "34  Tracking Resource Utilisation",
    "section": "",
    "text": "Add this up across every entity who passes through our model.\nDivide it by the total amount of time that has elapsed in the model, multiplied by the number of resources in the model.\n\n\n\n\n34.1.1 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n34.1.1.1 g class\nThe g class is unchanged.\n\n\n34.1.1.2 Patient class\nFirst, we add an attribute to the patient class.\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.time_with_nurse = 0 ##NEW\n\n\n\n34.1.1.3 Model class\n\n34.1.1.3.1 The init method\nHere we’re just going to add an empty list to store our patient objects.\nWe’re also going to add a space to store the utilisation in that run.\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n        self.patient_objects = [] ##NEW\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n        self.nurse_utilisation = 0.0 ##NEW\n\n\n\n34.1.1.3.2 The generate_patient_arrivals method\nHere we just want to add a line to add the patient objects to our patient_objects list when they are created.\nDon’t worry that we haven’t yet set the attributes of the patient throughout their journeys - when we access the patient list at the very end of the model runs, we will get the most up-to-date version of the attribute for each patient.\n\ndef generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\n34.1.1.3.3 The attend_clinic method\nIn here, we will add in a step to set the value of the time_with_nurse attribute of the patient class.\n\ndef attend_clinic(self, patient):\n    # Record the time the patient started queuing for a nurse\n    start_q_nurse = self.env.now\n\n    # This code says request a nurse resource, and do all of the following\n    # block of code with that nurse resource held in place (and therefore\n    # not usable by another patient)\n    with self.nurse.request() as req:\n        # Freeze the function until the request for a nurse can be met.\n        # The patient is currently queuing.\n        yield req\n\n        # When we get to this bit of code, control has been passed back to\n        # the generator function, and therefore the request for a nurse has\n        # been met.  We now have the nurse, and have stopped queuing, so we\n        # can record the current time as the time we finished queuing.\n        end_q_nurse = self.env.now\n\n        # Calculate the time this patient was queuing for the nurse, and\n        # record it in the patient's attribute for this.\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        # Now we'll randomly sample the time this patient with the nurse.\n        # Here, we use an Exponential distribution for simplicity, but you\n        # would typically use a Log Normal distribution for a real model\n        # (we'll come back to that).  As with sampling the inter-arrival\n        # times, we grab the mean from the g class, and pass in 1 / mean\n        # as the lambda value.\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        # Here we'll store the queuing time for the nurse and the sampled\n        # time to spend with the nurse in the results DataFrame against the\n        # ID for this patient.  In real world models, you may not want to\n        # bother storing the sampled activity times - but as this is a\n        # simple model, we'll do it here.\n        # We use a handy property of pandas called .at, which works a bit\n        # like .loc.  .at allows us to access (and therefore change) a\n        # particular cell in our DataFrame by providing the row and column.\n        # Here, we specify the row as the patient ID (the index), and the\n        # column for the value we want to update for that patient.\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n\n        patient.time_with_nurse = sampled_nurse_act_time ##NEW\n\n        # Freeze this function in place for the activity time we sampled\n        # above.  This is the patient spending time with the nurse.\n        yield self.env.timeout(sampled_nurse_act_time)\n\n        # When the time above elapses, the generator function will return\n        # here.  As there's nothing more that we've written, the function\n        # will simply end.  This is a sink.  We could choose to add\n        # something here if we wanted to record something - e.g. a counter\n        # for number of patients that left, recording something about the\n        # patients that left at a particular sink etc.\n\n\n\n34.1.1.3.4 A new method: audit_utilisation\nIn our model class, we can now create a new method.\nRemember that thanks to the additional attribute we added to the model class, we have now stored the time_with_nurse for each patient and can easily access it.\nAs we are only tracking a single resource in this model, we could write our function like this:\n\ndef audit_utilisation(self):\n    activity_durations = [i.time_with_nurse for i in self.patient_objects]\n\n    return (sum(activity_durations) / (g.number_of_nurses * g.sim_duration))\n\n\n\n\n\n\n\nTip\n\n\n\nA more generalisable form of this function is given below.\n\ndef audit_utilisation(self, activity_attribute, resource_attribute):\n    activity_durations = [i.getattr(activity_attribute) for i in self.patient_objects]\n\n    return (sum(activity_durations) / (g.getattr(resource_attribute) * g.sim_duration))\n\nThis will then be called like this.\n\nself.audit_utilisation(\"time_with_nurse\", \"number_of_nurses\")\n\nIf we were also recording time with a doctor, we might call that as\n\nself.audit_utilisation(\"time_with_doctor\", \"number_of_doctors\")\n\n\n\n\n\n34.1.1.3.5 The calculate_run_results method\nNow we are going to use this new method to add the utilisation metric to our results dataframe.\n\ndef calculate_run_results(self):\n    # Take the mean of the queuing times for the nurse across patients in\n    # this run of the model.\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # This assumes we're not using the generalised version of the function\n    # which doesn't take any arguments\n    self.nurse_utilisation = self.audit_utilisation() ##NEW\n\nFinally, we can put this all together when we run the model.\n\n\n\n34.1.1.4 Trial class\n\n34.1.1.4.1 The init method\nFirst we add a column to record the average nurse utilisation.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Average Nurse Utilisation\"] = [0.0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n34.1.1.4.2 The run_trial method\nFinally, we add this to the output dataframe.\nNote that we have had to tweak the step for adding results to our dataframe as there are now two possible columns for the result to go in - previously we could get away with just specifying the row in loc, but now we have to pass the column name too.\n\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run, \"Mean Q Time Nurse\"] = [my_model.mean_q_time_nurse] ##NEW\n        self.df_trial_results.loc[run, \"Average Nurse Utilisation\"] = [my_model.nurse_utilisation] ##NEW\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.print_trial_results()\n\n\n\n\n\n\n\nImportant\n\n\n\nThis method may slightly overestimate the utilisation.\nWhy?\nBecause we record the time spent with the resource prior to that time elapsing.\nIf we have a model run time of 600 time units, and someone reaches the nurse at unit 595 but has an activity time of 30, we will record that and use it in our calculations - even though only 5 minutes of that time actually took place during our model run.\nYou could adapt the code above to account for that - for example, you could check whether the time remaining in the model run (g.sim_duration - self.env.now) is greater than the activity time that is sampled, and record whichever is the smaller of the two as the patient attribute.\n\n\n\n\n\n\n34.1.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 2\n    sim_duration = 1200\n    number_of_runs = 5\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.time_with_nurse = 0 ##NEW\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n        self.patient_objects = [] ##NEW\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n        self.nurse_utilisation = 0.0 ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            patient.time_with_nurse = sampled_nurse_act_time ##NEW\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    def audit_utilisation(self):\n        activity_durations = [i.time_with_nurse for i in self.patient_objects]\n\n        return (sum(activity_durations) / (g.number_of_nurses * g.sim_duration))\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n        self.nurse_utilisation = self.audit_utilisation() ##NEW\n\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # We are not printing the patient-level results in this case\n        # so this code has been removed\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Average Nurse Utilisation\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Q Time Nurse\"] = [my_model.mean_q_time_nurse] ##NEW\n            self.df_trial_results.loc[run, \"Average Nurse Utilisation\"] = [my_model.nurse_utilisation] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n34.1.3 Evaluating the output\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Q Time Nurse  Average Nurse Utilisation\nRun Number                                              \n0                    4.514809                   0.600812\n1                    1.828576                   0.590853\n2                    2.787816                   0.611039\n3                    3.016570                   0.597069\n4                    1.739088                   0.556199\n\n\n\n\n\n\n\n\nTip\n\n\n\nA nice enhancement to this output would be to format the average nurse utilisation column as a percentage rather than keeping it in decimal format.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html#interval-audits",
    "href": "tracking_resource_utilisation.html#interval-audits",
    "title": "34  Tracking Resource Utilisation",
    "section": "34.2 Interval Audits",
    "text": "34.2 Interval Audits\nAnother option for monitoring resource usage is to set up a new interval audit process.\nWe create a new interval_audit_utilisation() function that we pass:\n\nA list of resources we want to monitor.\nA time interval at which to snapshot the utilisation in the process.\n\n\n34.2.1 A code example\n\n34.2.1.1 g class\nWe add a parameter to the g class which will tell us how often to record the current utilisation.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 35\n    number_of_nurses = 9\n    sim_duration = 600\n    number_of_runs = 5\n    audit_interval = 5 ##NEW\n\n\n\n34.2.1.2 Model Class\n\n34.2.1.2.1 The init method\nFirst, we create an empty list to hold our utilisation audit in our Model class.\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create a SimPy resource to represent a nurse, that will live in the\n    # environment created above.  The number of this resource we have is\n    # specified by the capacity, and we grab this value from our g class.\n    self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results against\n    # the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Q Time Nurse\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing time for the nurse\n    # across this run of the model\n    self.mean_q_time_nurse = 0\n\n    self.utilisation_audit = [] ##NEW\n\n\n\n34.2.1.2.2 A new method - interval_audit_utilisation\nThen we add the interval_audit_utilisation function to our Model class.\nWe set it up so either a list of resources can be passed as a dictionary, or just a single simpy resource object.\n\n#########\n##NEW\n#########\ndef interval_audit_utilisation(self, resources, interval=1):\n    '''\n    Record utilisation at defined intervals.\n\n    Needs to be passed to env.process when running model.\n\n    Parameters:\n    ------\n    resource: SimPy resource object\n        The resource to monitor\n        OR\n        a list of dictionaries containing simpy resource objects in the format\n        [{'resource_name':'my_resource', 'resource_object': resource},\n        {'resource_name':'my_second_resource', 'resource_object': resource_2}\n        ]\n        where resource and resource_2 in the examples above are simpy resources.\n\n    interval: int:\n        Time between audits.\n        In simpy time units\n        Default: 1\n    '''\n\n    # Keep doing the below as long as the simulation is running\n    while True:\n\n        # Code for what to do if we pass in a list of resources\n        if isinstance(resources, list):\n            for i in range(len(resources)):\n                self.utilisation_audit.append({\n                    'resource_name': resources[i]['resource_name'], # The provided name for the resource\n                    'simulation_time': self.env.now,  # The current simulation time\n                    'number_utilised': len(resources[i]['resource_object'].count), # The number of users\n                    'number_available': resources[i]['resource_object'].capacity, # The total resource available,\n                    'queue_length': len(resources[i]['resource_object'].queue)\n                })\n\n        else:\n\n            # Code for what to do if we just pass in a single resource to monitor\n            self.utilisation_audit.append({\n                'simulation_time': self.env.now,  # The current simulation time\n                'number_utilised': resources.count,  # The number of users\n                'number_available': resources.capacity, # The total resource available\n                'queue_length': len(resources.queue)\n            })\n\n\n        # Trigger next audit after desired interval has passed.\n        yield self.env.timeout(interval)\n#########\n##END NEW\n#########\n\n\n\n\n\n\n\nTip\n\n\n\nIf you are using a simpy PriorityResource instead of a standard resource, the code should work the same.\nIf you are using a simpy store instead of a simpy resource, it’s possibly to adapt by using len(resources.items) to get the number of resources currently being utilised, and resources.capacity will still return the total number of resources that are in the system.\n\n\n\n\n34.2.1.2.3 The run method\nWe now add the interval audit process to our run.\nRemember - this will update the self.utilisation_audit in our method class.\nHere we have passed in the nurse resource that gets created during the init method of the model class.\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n        def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(\n          self.generator_patient_arrivals()\n        )\n\n        self.env.process(\n          self.interval_audit_utilisation(resources=self.nurse,interval=g.audit_interval) ##NEW\n        )\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # EDIT: We've skipped printing the individual-level results here\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n\n\n\n\n\n\nTip\n\n\n\nIf we wanted to conduct an interval audit of multiple resources, we could do it like this:\n\nself.env.process(\n    self.interval_audit_utilisation(\n      resources= [\n        {'resource_name':'receptionists', 'resource_object': self.receptionist},\n        {'resource_name':'nurses', 'resource_object': self.nurse},\n        {'resource_name':'doctors', 'resource_object': self.doctor}\n        ],\n      interval=g.audit_interval) ##NEW\n  )\n\nThis assumes our additional resources were set up in the init method of the model class like so:\n\n  self.receptionist = simpy.Resource(\n      self.env, capacity=g.number_of_receptionists\n  )\n\n  self.nurse = simpy.Resource(\n    self.env, capacity=g.number_of_nurses\n    )\n\n  self.doctor = simpy.Resource(\n      self.env, capacity=g.number_of_doctors\n  )\n\n\n\n\n\n\n34.2.1.3 Trial class\n\n34.2.1.3.1 The init method\nWe can add an empty list where we will store all of the interval audits\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.interval_audit_list = [] ##NEW\n\n\n\n34.2.1.3.2 The run_trial method\nSave the interval audit results in a dataframe.\n\n# Method to run a trial\ndef run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run() ##NEW\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            interval_audit_df = pd.DataFrame(my_model.utilisation_audit) ##NEW\n            interval_audit_df[\"run\"] = run ##NEW\n            interval_audit_df[\"perc_utilisation\"] = (\n              interval_audit_df[\"number_utilised\"]/interval_audit_df[\"number_available\"]\n            ) ##NEW\n\n            self.interval_audit_list.append(interval_audit_df) ##NEW\n\n        # For now, we're going to skip printing the trial results, so the line\n        # below has been commented out\n        # self.print_trial_results()\n\n\n\n34.2.1.3.3 New method - get_interval_audits\nFinally we are going to create a new method that just joins all of the interval audit dataframes together and returns them as a single dataframe.\n\n##NEW\ndef get_interval_audits(self):\n  return pd.concat(self.interval_audit_list)\n\n\n\n\n\n34.2.2 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 35\n    number_of_nurses = 9\n    sim_duration = 600\n    number_of_runs = 5\n    audit_interval = 5 ##NEW\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n        self.utilisation_audit = [] ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    #########\n    ##NEW\n    #########\n    def interval_audit_utilisation(self, resources, interval=1):\n        '''\n        Record utilisation at defined intervals.\n\n        Needs to be passed to env.process when running model.\n\n        Parameters:\n        ------\n        resource: SimPy resource object\n            The resource to monitor\n            OR\n            a list of dictionaries containing simpy resource objects in the format\n            [{'resource_name':'my_resource', 'resource_object': resource},\n            {'resource_name':'my_second_resource', 'resource_object': resource_2}\n            ]\n            where resource and resource_2 in the examples above are simpy resources.\n\n        interval: int:\n            Time between audits.\n            In simpy time units\n            Default: 1\n        '''\n\n        # Keep doing the below as long as the simulation is running\n        while True:\n\n            # Code for what to do if we pass in a list of resources\n            if isinstance(resources, list):\n                for i in range(len(resources)):\n                    self.utilisation_audit.append({\n                        'resource_name': resources[i]['resource_name'], # The provided name for the resource\n                        'simulation_time': self.env.now,  # The current simulation time\n                        'number_utilised': len(resources[i]['resource_object'].count), # The number of users\n                        'number_available': resources[i]['resource_object'].capacity, # The total resource available,\n                        'queue_length': len(resources[i]['resource_object'].queue)\n                    })\n\n            else:\n\n                # Code for what to do if we just pass in a single resource to monitor\n                self.utilisation_audit.append({\n                    'simulation_time': self.env.now,  # The current simulation time\n                    'number_utilised': resources.count,  # The number of users\n                    'number_available': resources.capacity, # The total resource available\n                    'queue_length': len(resources.queue)\n                })\n\n\n            # Trigger next audit after desired interval has passed.\n            yield self.env.timeout(interval)\n    #########\n    ##END NEW\n    #########\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(\n          self.generator_patient_arrivals()\n        )\n\n        self.env.process(\n          self.interval_audit_utilisation(resources=self.nurse,interval=g.audit_interval) ##NEW\n        )\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # EDIT: We've skipped printing the individual-level results here\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.interval_audit_list = [] ##NEW\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run() ##NEW\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            interval_audit_df = pd.DataFrame(my_model.utilisation_audit) ##NEW\n            interval_audit_df[\"run\"] = run ##NEW\n            interval_audit_df[\"perc_utilisation\"] = (\n              interval_audit_df[\"number_utilised\"]/interval_audit_df[\"number_available\"]\n            ) ##NEW\n\n            self.interval_audit_list.append(interval_audit_df) ##NEW\n\n        # For now, we're going to skip printing the trial results, so the line\n        # below has been commented out\n        # self.print_trial_results()\n\n    ##NEW\n    def get_interval_audits(self):\n      return pd.concat(self.interval_audit_list)\n\n\n\n\n\n\n34.2.3 Evaluating the outputs\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\ninterval_audits = my_trial.get_interval_audits()\n\ninterval_audits\n\n\n\n\n\n\n\n\nsimulation_time\nnumber_utilised\nnumber_available\nqueue_length\nrun\nperc_utilisation\n\n\n\n\n0\n0\n0\n9\n0\n0\n0.000000\n\n\n1\n5\n1\n9\n0\n0\n0.111111\n\n\n2\n10\n2\n9\n0\n0\n0.222222\n\n\n3\n15\n2\n9\n0\n0\n0.222222\n\n\n4\n20\n3\n9\n0\n0\n0.333333\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n115\n575\n6\n9\n0\n4\n0.666667\n\n\n116\n580\n6\n9\n0\n4\n0.666667\n\n\n117\n585\n6\n9\n0\n4\n0.666667\n\n\n118\n590\n6\n9\n0\n4\n0.666667\n\n\n119\n595\n5\n9\n0\n4\n0.555556\n\n\n\n\n600 rows × 6 columns\n\n\n\nWe can explore this output as a graph, with the vertical axis showing the % utilisation over time and the horizontal axis showing the progression of simulation time. Each coloured line represents a different run. We can see that the % utilisation is different at a given time point across different runs, which we would expect due to the randomness.\n\nimport plotly.express as px\n\nfig = px.line(interval_audits, x=\"simulation_time\", y=\"perc_utilisation\", color=\"run\")\n\nfig.show()\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nWe could look at the median utilisation across different runs.\nIf we get to a high enough number of runs, we may expect the average utilisation to become quite consistent over time.\n\n\n\n\n\n\nTip\n\n\n\nThis may be of more use when running a model with variable arrival rates at different times of day - as we would then expect to see some variation.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis can also form part of your strategy for working out how long the warm-up period of a model should be.\n\n\n\ng.number_of_runs = 1000\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\ninterval_audits = my_trial.get_interval_audits()\n\ninterval_audits_median = interval_audits.groupby(\"simulation_time\").median().reset_index()\n\ninterval_audits_median\n\n\n\n\n\n\n\n\nsimulation_time\nnumber_utilised\nnumber_available\nqueue_length\nrun\nperc_utilisation\n\n\n\n\n0\n0\n0.0\n9.0\n0.0\n499.5\n0.000000\n\n\n1\n5\n2.0\n9.0\n0.0\n499.5\n0.222222\n\n\n2\n10\n2.0\n9.0\n0.0\n499.5\n0.222222\n\n\n3\n15\n3.0\n9.0\n0.0\n499.5\n0.333333\n\n\n4\n20\n3.0\n9.0\n0.0\n499.5\n0.333333\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n115\n575\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n116\n580\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n117\n585\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n118\n590\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n119\n595\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n\n\n120 rows × 6 columns\n\n\n\n\nimport plotly.express as px\n\nfig = px.line(interval_audits_median, x=\"simulation_time\", y=\"perc_utilisation\")\n\nfig.show()",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html",
    "href": "other_model_metrics.html",
    "title": "35  Other Model Metrics",
    "section": "",
    "text": "35.1 Arrivals\nThere are some other things it can be useful to measure in our model.\nMonitoring the number of arrivals can be useful to see how much variation we may expect in our system.\nThis can also be helpful to ensure the model is running as expected - we already did this in the Reproducibility section (Chapter 14).",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html#of-entities-meeting-a-target",
    "href": "other_model_metrics.html#of-entities-meeting-a-target",
    "title": "35  Other Model Metrics",
    "section": "35.2 % of entities meeting a target",
    "text": "35.2 % of entities meeting a target\nWhile there is a lot of controversy around the value of targets like the 4 hour wait from arrival to admission, transfer or discharge for A&E departments, they do have some value and can be a useful metric to consider as part of a wider package of metrics.\nOther examples of this may relate to length of stay - for example, mental health wards may have a target for the maximum length of stay.\n\n\n\n\n\n\nWarning\n\n\n\nConsider whether there may be anything in the historical data patterns that may be due to trying to meet targets.\nFor example, this article from the PSC refers to some NHS England analysis that shows “17% of all admissions to Type 1 A&Es between January and December 2018 occurred between 3 hours 50 minutes and 4 hours, prompting criticism that the 4-hour target has encouraged the NHS to ‘treat the target rather than the patient’. Evidence suggests that hospital processes, rather than clinical judgement, are responsible for this spike in admissions or discharge in the immediate period before a patient breaches the standard.”\n Source: NHS England analysis of Secondary Uses Services (SUS) data, via The PSC\nIf the target was removed, would this result in a change in behaviour? How might the predictions of our model be affected by this?",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html#throughput",
    "href": "other_model_metrics.html#throughput",
    "title": "35  Other Model Metrics",
    "section": "35.3 Throughput",
    "text": "35.3 Throughput\nThroughput refers to the % of people entering our system who have left by the time our model stops running.\nA very low throughput suggests a severe bottleneck somewhere in the system.\nThis can be a useful measure to track as a quick way of assessing whether different scenarios are leading to severe bottlenecks, but it is not that useful as a standalone measure.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "visualising_model_metrics.html",
    "href": "visualising_model_metrics.html",
    "title": "36  (Coming Soon!) Visualising Model Metrics",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>(Coming Soon!) Visualising Model Metrics</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html",
    "href": "intro_creating_web_apps.html",
    "title": "37  Creating Web Apps",
    "section": "",
    "text": "37.1 Video guide: creating a streamlit web app interface for a DES model\nAs part of the HSMA programme, we teach how to use the Streamlit web application framework to produce a front-end for a discrete event simulation model.\nThis can be a hugely powerful way of distributing your model. By creating a web application, stakeholders can interact with the model and adjust parameters themselves, seeing the impact this has. A carefully designed web app can guide them through the process of understanding the impact of different changes to the system.\nIt is beyond the scope of this book to give a full treatment of this topic at this time, though it may be expanded on in the future.\nIn the meantime, there are several resources available to you.\nThis video is the masterclass on Streamlit interfaces from the fifth round of the HSMA programme. This is delivered by Tom Monks , another member of the PenCHORD team.\nThe classes and structure used for the model are very slightly different to the style used in this book, but overall the techniques are very applicable.",
    "crumbs": [
      "Part 6 - Model Interfaces and Outputs",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html#video-guide-creating-a-streamlit-web-app-interface-for-a-des-model",
    "href": "intro_creating_web_apps.html#video-guide-creating-a-streamlit-web-app-interface-for-a-des-model",
    "title": "37  Creating Web Apps",
    "section": "",
    "text": "37.1.1 Book\nA book has also been written to accompany the above tutorial.\nThe book can be accessed here.",
    "crumbs": [
      "Part 6 - Model Interfaces and Outputs",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html#example-apps",
    "href": "intro_creating_web_apps.html#example-apps",
    "title": "37  Creating Web Apps",
    "section": "37.2 Example apps",
    "text": "37.2 Example apps\n\n37.2.1 The DES playground\nThe following app contains a range of pages that allow users to explore a DES model of growing complexity.\nYou can see the range of sliders and inputs that you can make available to your end users.\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that this link will not work if you are viewing this book in Firefox. All other major browsers should work, including mobile browsers.\n\n\nThe full code can be seen here.\nLook at the code within the pages subfolder to see how different features are implemented.\nOther features that may be useful to adapt for your own use include - the ability to save and compare the results from multiple scenarios - a range of interactive visualisations of simulation metrics\n\n\n37.2.2 The HSMA SimPy example library\nAs part of the SimPy visualisation library project, a range of different SimPy models have been created with a Streamlit frontend.\n\nThe code for all of these examples can be explored in this Github Repository.\nIn each case, the code for the model classes, simulation execution and simulation summary functions can be found inside a subfolder within the examples folder.\nNote that again the classes and format used for these models differs slightly from the examples given in this book, but are fundamentally very similar so should be possible to adapt.",
    "crumbs": [
      "Part 6 - Model Interfaces and Outputs",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "stress_des.html",
    "href": "stress_des.html",
    "title": "38  STRESS-DES Reporting",
    "section": "",
    "text": "38.1 Reporting guidelines\nReporting guidelines are structured sets of recommendations designed to improve the clarity and completeness of published research. They provide list of information that authors should ensure they include in their report/manuscript.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>STRESS-DES Reporting</span>"
    ]
  },
  {
    "objectID": "stress_des.html#stress-des",
    "href": "stress_des.html#stress-des",
    "title": "38  STRESS-DES Reporting",
    "section": "38.2 STRESS-DES",
    "text": "38.2 STRESS-DES\nAn example of relevant guidelines for DES models are the The Strengthening The Reporting of Empirical Simulation Studies (STRESS) Discrete Event Simulation (DES) guidelines.\nSTRESS-DES is 20-item checklist. It was designed to improve the reporting of DES models, ensuring that your report includes enough information for others to understand, evaluate and replicate the findings of your work.. It was published in:\n\nMonks, T., Currie, C. S. M., Onggo, B. S., Robinson, S., Kunc, M., & Taylor, S. J. E. (2018). Strengthening the reporting of empirical simulation studies: Introducing the STRESS guidelines. Journal of Simulation, 13(1), 55–67. https://doi.org/10.1080/17477778.2018.1442155.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>STRESS-DES Reporting</span>"
    ]
  },
  {
    "objectID": "stress_des.html#how-to-use-the-guidelines",
    "href": "stress_des.html#how-to-use-the-guidelines",
    "title": "38  STRESS-DES Reporting",
    "section": "38.3 How to use the guidelines?",
    "text": "38.3 How to use the guidelines?\nYou can refer to the guidelines when writing your report, making sure to cover all the required points from the checklist. This will help ensure your model is clear, complete and replicable.\nIt can be helpful to create a column in the checklist where you mark whether you have addressed each item. You can also note the relevant section in your report and even copy or paraphrase key sections into the checklist itself. This makes it easier to track your progress and ensure that nothing is overlooked.\nIncluding the completed checklist as supporting/supplementary material with your report allows readers and reviewers to more easily identify these relevant details about your model, and verify that they are present in the report.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>STRESS-DES Reporting</span>"
    ]
  },
  {
    "objectID": "stress_des.html#view-and-download-the-guidelines",
    "href": "stress_des.html#view-and-download-the-guidelines",
    "title": "38  STRESS-DES Reporting",
    "section": "38.4 View and download the guidelines",
    "text": "38.4 View and download the guidelines\n Download STRESS-DES markdown file \n Download STRESS-DES word document \nView on the equator network.\nSTRESS-DES guidelines:\n\n\n\n\n\n\n\n\nSection/Subsection\nItem\nRecommendation\n\n\n\n\n1. Objectives\n\n\n\n\nPurpose of the model\n1.1\nExplain the background and objectives for the model.\n\n\nModel outputs\n1.2\nDefine all quantitative performance measures that are reported, using equations where necessary. Specify how and when they are calculated during the model run along with how any measures of error such as confidence intervals are calculated.\n\n\nExperimentation aims\n1.3\nIf the model has been used for experimentation, state the objectives that it was used to investigate.(A) Scenario based analysis – Provide a name and description for each scenario, providing a rationale for the choice of scenarios and ensure that item 2.3 (below) is completed.(B) Design of experiments – Provide details of the overall design of the experiments with reference to performance measures and their parameters (provide further details in data below).(C) Simulation Optimisation – (if appropriate) Provide full details of what is to be optimised, the parameters that were included and the algorithm(s) that was be used. Where possible provide a citation of the algorithm(s).\n\n\n2. Logic\n\n\n\n\nBase model overview diagram\n2.1\nDescribe the base model using appropriate diagrams and description. This could include one or more process flow, activity cycle or equivalent diagrams sufficient to describe the model to readers. Avoid complicated diagrams in the main text. The goal is to describe the breadth and depth of the model with respect to the system being studied.\n\n\nBase model logic\n2.2\nGive details of the base model logic. Give additional model logic details sufficient to communicate to the reader how the model works.\n\n\nScenario logic\n2.3\nGive details of the logical difference between the base case model and scenarios (if any). This could be incorporated as text or where differences are substantial could be incorporated in the same manner as 2.2.\n\n\nAlgorithms\n2.4\nProvide further detail on any algorithms in the model that (for example) mimic complex or manual processes in the real world (i.e. scheduling of arrivals/ appointments/ operations/ maintenance, operation of a conveyor system, machine breakdowns, etc.). Sufficient detail should be included (or referred to in other published work) for the algorithms to be reproducible. Pseudo-code may be used to describe an algorithm.\n\n\nComponents - entities\n2.5.1\nGive details of all entities within the simulation including a description of their role in the model and a description of all their attributes.\n\n\nComponents - activities\n2.5.2\nDescribe the activities that entities engage in within the model. Provide details of entity routing into and out of the activity.\n\n\nComponents - resources\n2.5.3\nList all the resources included within the model and which activities make use of them.\n\n\nComponents - queues\n2.5.4\nGive details of the assumed queuing discipline used in the model (e.g. First in First Out, Last in First Out, prioritisation, etc.). Where one or more queues have a different discipline from the rest, provide a list of queues, indicating the queuing discipline used for each. If reneging, balking or jockeying occur, etc., provide details of the rules. Detail any delays or capacity constraints on the queues.\n\n\nComponents - entry/exit points\n2.5.5\nGive details of the model boundaries i.e. all arrival and exit points of entities. Detail the arrival mechanism (e.g. ‘thinning’ to mimic a non-homogenous Poisson process or balking).\n\n\n3. Data\n\n\n\n\nData sources\n3.1\nList and detail all data sources. Sources may include:• Interviews with stakeholders,• Samples of routinely collected data,• Prospectively collected samples for the purpose of the simulation study,• Public domain data published in either academic or organisational literature. Provide, where possible, the link and DOI to the data or reference to published literature.All data source descriptions should include details of the sample size, sample date ranges and use within the study.\n\n\nPre-processing\n3.2\nProvide details of any data manipulation that has taken place before its use in the simulation, e.g. interpolation to account for missing data or the removal of outliers.\n\n\nInput parameters\n3.3\nList all input variables in the model. Provide a description of their use and include parameter values. For stochastic inputs provide details of any continuous, discrete or empirical distributions used along with all associated parameters. Give details of all time dependent parameters and correlation.Clearly state:• Base case data• Data use in experimentation, where different from the base case.• Where optimisation or design of experiments has been used, state the range of values that parameters can take.• Where theoretical distributions are used, state how these were selected and prioritised above other candidate distributions.\n\n\nAssumptions\n3.4\nWhere data or knowledge of the real system is unavailable what assumptions are included in the model? This might include parameter values, distributions or routing logic within the model.\n\n\n4. Experimentation\n\n\n\n\nInitialisation\n4.1\nReport if the system modelled is terminating or non-terminating. State if a warm-up period has been used, its length and the analysis method used to select it. For terminating systems state the stopping condition.State what if any initial model conditions have been included, e.g., pre-loaded queues and activities. Report whether initialisation of these variables is deterministic or stochastic.\n\n\nRun length\n4.2\nDetail the run length of the simulation model and time units.\n\n\nEstimation approach\n4.3\nState the method used to account for the stochasticity: For example, two common methods are multiple replications or batch means. Where multiple replications have been used, state the number of replications and for batch means, indicate the batch length and whether the batch means procedure is standard, spaced or overlapping. For both procedures provide a justification for the methods used and the number of replications/size of batches.\n\n\n5. Implementation\n\n\n\n\nSoftware or programming language\n5.1\nState the operating system and version and build number.State the name, version and build number of commercial or open source DES software that the model is implemented in.State the name and version of general-purpose programming languages used (e.g. Python 3.5).Where frameworks and libraries have been used provide all details including version numbers.\n\n\nRandom sampling\n5.2\nState the algorithm used to generate random samples in the software/programming language used e.g. Mersenne Twister.If common random numbers are used, state how seeds (or random number streams) are distributed among sampling processes.\n\n\nModel execution\n5.3\nState the event processing mechanism used e.g. three phase, event, activity, process interaction.Note that in some commercial software the event processing mechanism may not be published. In these cases authors should adhere to item 5.1 software recommendations.State all priority rules included if entities/activities compete for resources.If the model is parallel, distributed and/or use grid or cloud computing, etc., state and preferably reference the technology used. For parallel and distributed simulations the time management algorithms used. If the HLA is used then state the version of the standard, which run-time infrastructure (and version), and any supporting documents (FOMs, etc.)\n\n\nSystem specification\n5.4\nState the model run time and specification of hardware used. This is particularly important for large scale models that require substantial computing power. For parallel, distributed and/or use grid or cloud computing, etc. state the details of all systems used in the implementation (processors, network, etc.).\n\n\n6. Code access\n\n\n\n\nComputer model sharing statement\n6.1\nDescribe how someone could obtain the model described in the paper, the simulation software and any other associated software (or hardware) needed to reproduce the results. Provide, where possible, the link and DOIs to these.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>STRESS-DES Reporting</span>"
    ]
  },
  {
    "objectID": "stress_des.html#other-relevant-guidelines",
    "href": "stress_des.html#other-relevant-guidelines",
    "title": "38  STRESS-DES Reporting",
    "section": "38.5 Other relevant guidelines",
    "text": "38.5 Other relevant guidelines\nAn example of another guideline specifically designed for DES models is the generic reporting checklist described in:\n\nZhang, Xiange, Stefan K. Lhachimi, and Wolf H. Rogowski. 2020. “Reporting Quality of Discrete Event Simulations in Healthcare—Results From a Generic Reporting Checklist.” Value in Health 23 (4): 506–14. https://doi.org/10.1016/j.jval.2020.01.005.\n\nThis checklist is focused on model quality, and was derived from the International Society for Pharmacoeconomics and Outcomes Research (ISPOR)–Society for Medical Decision Making (SMDM) Modelling Good Research Practices Task Force reports.\nSeveral other guidelines have been developed for different modeling and research fields. Examples include:\n\nOverview, Design Concepts, and Details (ODD) protocol - a widely used framework for reporting agent-based models, https://www.comses.net/resources/standards/.\nConsolidated Health Economic Evaluation Reporting Standards (CHEERS) - designed for health economic modeling, https://www.equator-network.org/reporting-guidelines/cheers/.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>STRESS-DES Reporting</span>"
    ]
  },
  {
    "objectID": "stars.html",
    "href": "stars.html",
    "title": "39  The STARS Framework",
    "section": "",
    "text": "39.1 STARS: Sharing Tools and Artefacts for Reusable Simulation\nThe STARS framework is a set of practical guidelines to help modellers share their simulation models in a way that makes them:\nYou can use the framework to guide how you share your DES model.\nThe framework is described in:\nIt is divided into essential and optional components.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>The STARS Framework</span>"
    ]
  },
  {
    "objectID": "stars.html#stars-sharing-tools-and-artefacts-for-reusable-simulation",
    "href": "stars.html#stars-sharing-tools-and-artefacts-for-reusable-simulation",
    "title": "39  The STARS Framework",
    "section": "",
    "text": "✅ Accessible – so others can easily find and access your model.\n✅ Reusable - so people can use and adapt the model for their own work.\n✅ Understandable and well-documented - so others can engage with and understand your model better.\n\n\n\n\nMonks, T., Harper, A., & Mustafee, N. (2024). Towards sharing tools and artefacts for reusable simulations in healthcare. Journal of Simulation, 1–20. https://doi.org/10.1080/17477778.2024.2347882.\n\n\n\nEssential components - the minimum steps needed to share models that are citable, functional, well-licensed and available long-term.\nOptional components - a step further, enhancing accessibility, understanding and clarity of the model.\n\n\n\n\nOverview of the STARS Framework from Monks et al. (2024) (CC BY 4.0).",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>The STARS Framework</span>"
    ]
  },
  {
    "objectID": "stars.html#essential-components",
    "href": "stars.html#essential-components",
    "title": "39  The STARS Framework",
    "section": "39.2 Essential components",
    "text": "39.2 Essential components\n\n\n\n\n\n\nSTARS essential components checklist\n\n\n\n\nOpen licence\nDependency management\nUse FOSS languages\nMinimum documentation\nORCID\nCitation information\nRemote code repository\nOpen science archive\n\n\n\n\n39.2.1 Open licence\nBefore sharing code, it’s important to choose an appropriate open-source licence. A licence tells others how they can use, modify or share your work. Without a licence, you retain exclusive copyright, and others would not be able to legally reuse the model.\nA common approach in data science is to use a permissive licence like an MIT licence. Other options are available, with more restrictive licences like GPL licences requiring anyone who modifies your work to share it under the same terms. The website https://choosealicense.com/ can be helpful in choosing a licence that suits you.\nA licence is simply a file (often just LICENCE) add to the root of your repository. It is easy to add - check out these handy instructions from GitHub.\n\n\n\n\n\n\n\n39.2.2 Dependency management\nTo make sure your code runs correctly for others (or for yourself in the future), you need to list the required software and versions. Without this, users may face errors due to missing dependencies.\nIn Python, common tools for managing this are:\n\nPip virtual environments with a requirements.txt file.\nConda environments with a environment.yaml/yml file.\nPoetry with a pyproject.toml file.\n\nThe HSMA - Programming in Python ebook has a chapter on “Creating Environments with Python” which guides you on how to set up an pip virtual environment.\n\n\n\n\n\n\n\n39.2.3 Use Free and Open-Source Software (FOSS) languages\nWe already meet this recommendation! 😊🎉 Python is an example of a FOSS language. FOSS provides freedom: it grants users the rights to adapt and share copies of their model however they choose.\n\n\n\n39.2.4 Minimum documentation\nAt a minimum, you should include some documentation alongside your model that describes:\n\nWhat the model does.\nHow to install and run the model to obtain results.\nHow to vary parameters to run new experiments.\n\nThis can be done easily using a README.md file. This is a markdown file stored in the root of your repository.\n\n\n\n\n\n\n\n39.2.5 Open Researcher and Contributor Identifier (ORCID)\nAn ORCID is a free, unique, persistent ID that identifies and links authors to their research. It ensures that any outputs and publications are correctly attributed to you.\nIt is recommended to include your ORCID in the README.md. For example:\nJane Doe ORCID: https://orcid.org/0000-0000-0000-0000.\nOr as a markdown badge…\n[![](https://img.shields.io/badge/Dane_Doe_ORCID-0000--0000--0000--0000-brightgreen)](https://orcid.org/0000-0000-0000-0000)\n\n\n\n\n\n\n\n\n39.2.6 Citation information\nIncluding citation instructions makes it easier for others to reference and give credit to your model. Platforms like GitHub support CITATION.cff, which are files that contain details like author names, version, and links to the original work. These can be created using cff-init.\n\n\n\n\n\n\n\n39.2.7 Remote code repository\nRemote code repositories like GitHub, GitLab, and Bitbucket help manage and share code.\n\nThey provide version control, allowing developers to track changes, revert to previous versions, and collaborate through branching.\nUsers can clone a repository to use a model and pull updates as improvements are made.\nFeatures like issues (for discussion and bug tracking) and releases (for tagging stable versions) make collaboration easier.\n\n\n\n\n\n\n\n\n39.2.8 Open science archive\nTo ensure simulation models remain accessible over time, they should be stored in open science archives like Zenodo, Figshare, and the Open Science Framework. These platforms provide DOIs (Digital Object Identifiers) for citation and follow principles that guarantee long-term storage and discoverability. Unlike GitHub, which can change or be deleted, archives preserve models permanently.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>The STARS Framework</span>"
    ]
  },
  {
    "objectID": "stars.html#optional-components",
    "href": "stars.html#optional-components",
    "title": "39  The STARS Framework",
    "section": "39.3 Optional components",
    "text": "39.3 Optional components\n\n\n\n\n\n\nSTARS optional components checklist\n\n\n\n\nEnhanced documentation.\nDocumentation hosting.\nOnline coding environment.\nModel interface.\nWeb app hosting.\n\n\n\n\n39.3.1 Enhanced documentation\nGoing beyond the minimum documentation requirements, good documentation should include:\n\nA plain-language summary of the project context and model.\nLicence and citation details.\nContribution instructions.\nInstallation instructions.\nA structured code walk through of the model.\nDocumentation of the modelling cycle using TRAnsparent and Comprehensive model Evaluation (TRACE) (Ayllón et al. (2021)).\nAnnotated simulation reporting guidelines (e.g. STRESS-DES).\nClear description of model validation including its intended purpose.\n\nGreat tools for creating your documentation include:\n\nQuarto markdown (.qmd) and Jupyter notebook (.ipynb) files, which allow you to combine code and text in an interactive format.\nQuarto and Jupyter Book, which allow you to turn these files into structured websites.\n\n\n\n\n\n\n\n\n39.3.2 Documentation hosting\nServices like GitHub Pages, GitLab Pages, BitBucket Cloud, and Quarto Pub can host documentation websites for free.\n\n\n\n\n\n\nFun fact!\n\n\n\nThis book is created from quarto markdown files (.qmd) which have been structured into a book (via a _quarto.yml file), and hosted using GitHub pages.\n\n\n\n\n\n\n\n\n\n39.3.3 Online coding environment\nThere are tools which enable users to run code online without any installation or downloads. A FOSS example for jupyter notebooks is BinderHub (https://mybinder.org) which creates an online Jupyter environment from a public GitHub or GitLab repository. It packages the code and any dependencies into a container, from which the notebooks can be run.\n\n\n\n\n\n\n\n39.3.4 Model interface\nTurning your model into an application will make it more accessible to non-technical users who may be unfamiliar with codings. Python options include:\n\nStreamlit (https://streamlit.io/).\nShiny for Python (https://shiny.posit.co/py/).\nPlotly Dash (https://dash.plotly.com/).\n\nCheck out Chapter 37 for more information on how to create a streamlit web application for your DES model.\n\n\n\n39.3.5 Web app hosting\nServices like Streamlit Community Cloud and ShinyApps offer free hosting tiers which can be used to deploy your web app, making it freely accessible via a website link.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>The STARS Framework</span>"
    ]
  },
  {
    "objectID": "stars.html#example-des-models-implementing-the-stars-framework",
    "href": "stars.html#example-des-models-implementing-the-stars-framework",
    "title": "39  The STARS Framework",
    "section": "39.4 Example DES models implementing the STARS framework",
    "text": "39.4 Example DES models implementing the STARS framework\nFor inspiration, check out these three examples of healthcare DES models which implement the framework, as linked in the paper describing the framework (Monks et al. (2024)).\n\n39.4.1 Example 1: SimPy\nCode: https://github.com/pythonhealthdatascience/stars-treat-sim.\nArchived code: https://doi.org/10.5281/zenodo.10026327.\nSTARS components:\n\n✅ MIT licence.\n✅ Conda environment.\n✅ SimPy python model.\n✅ Shared on GitHub.\n✅ CITATION.cff and ORCID meta-data.\n✅ README.md.\n✅ Archived on Zenodo.\n✅ Online coding environment via Binder.\n✅ Enhanced documentation using electronic notebook.\n\n\n\n39.4.2 Example 2: SimPy\nCode: https://github.com/pythonhealthdatascience/stars-streamlit-example and https://github.com/pythonhealthdatascience/stars-simpy-example-docs.\nWeb app: https://stars-simpy-example.streamlit.app/.\nDocumentation: https://pythonhealthdatascience.github.io/stars-simpy-example-docs.\nArchived code: https://doi.org/10.5281/zenodo.10055169 and https://doi.org/10.5281/zenodo.10054063.\nSTARS components:\n\n✅ MIT licence.\n✅ Conda environment.\n✅ SimPy python model.\n✅ Shared on GitHub.\n✅ CITATION.cff and ORCID meta-data.\n✅ README.md.\n✅ Archived on Zenodo.\n✅ Online coding environment via Binder.\n✅ Enhanced documentation using Jupyter Book and STRESS-DES.\n✅ Documentation hosted on GitHub pages.\n✅ Web app using streamlit.\n✅ Web app hosted using streamlit community cloud.\n\n\n\n39.4.3 Example 3: CIW\nCode: https://github.com/pythonhealthdatascience/stars-ciw-example.\nWeb app: https://pythonhealthdatascience.shinyapps.io/stars-ciw-examplar.\nDocumentation: https://pythonhealthdatascience.github.io/stars-ciw-example.\nArchived code: https://doi.org/10.5281/zenodo.10051495.\nSTARS components:\n\n✅ GNU Public Licence 3.\n✅ Conda environment.\n✅ ciw python model.\n✅ Shared on GitHub.\n✅ CITATION.cff and ORCID meta-data.\n✅ README.md.\n✅ Archived on Zenodo.\n✅ Online coding environment via Binder.\n✅ Enhanced documentation using Quarto and STRESS-DES.\n✅ Documentation hosted on GitHub pages.\n✅ Web app using shiny for python.\n✅ Web app hosted on shinyapps.io.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>The STARS Framework</span>"
    ]
  },
  {
    "objectID": "sharing_reproducible_models.html",
    "href": "sharing_reproducible_models.html",
    "title": "40  Sharing reproducible models",
    "section": "",
    "text": "40.1 Making your work reproducible\nReproducibility refers to the ability to get the same results (e.g. those described in a report) using the same code and data. You may have come across the related concept of a reproducible analytical pipeline (RAP), which is when an analytical process (in this case, running and analysing our DES model) is automated and reproducible - from getting the parameters through to generating tables and figures.\nMaking your work reproducible is important because it:\nIn Chapter 14, we explored how to add seeds to our model, allowing us to control randomness and reproduce the same results between runs. However, the requirements for making your work reproducible actually extend beyond that…\nThere are various recommendations of best practice, that will help make your work reproducible. We will turn to two relevant examples:\nHeather, A. Monks, T. Harper, A. (2025). Mustafee, N. Mayne, A. On the reproducibility of discrete-event simulation studies in health research: an empirical study using open models. arXiv pre-print. https://doi.org/10.48550/arXiv.2501.13137.\nThe NHS RAP Community of Practice. Levels of RAP Framework. https://nhsdigital.github.io/rap-community-of-practice/introduction_to_RAP/levels_of_RAP/.",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Sharing reproducible models</span>"
    ]
  },
  {
    "objectID": "sharing_reproducible_models.html#making-your-work-reproducible",
    "href": "sharing_reproducible_models.html#making-your-work-reproducible",
    "title": "40  Sharing reproducible models",
    "section": "",
    "text": "View recommendations\n\n\n\n\n\nThese recommendations were developed following attempts to reproduce results from healthcare discrete-event simulation models in eight published articles, using the provided code.\nThe recommendations marked with a star (⭐) were identified as having the greatest impact in Heather et al. 2025.\nFor further explanation of each recommendation, check out the paper: https://doi.org/10.48550/arXiv.2501.13137.\nRecommendations to support reproduction.\nSet-up\n\nShare code with an open licence (⭐).\nLink publication to a specific version of the code.\nList dependencies and versions.\n\nRunning the model\n\nProvide code for all scenarios and sensitivity analyses (⭐).\nEnsure model parameters are correct (⭐).\nControl randomness.\n\nOutputs\n\nInclude code to calculate all required model outputs (⭐).\nInclude code to generate the tables, figures, and other reported results (⭐).\n\nRecommendations to support troubleshooting and reuse.\nDesign\n\nSeparate model code from applications.\nAvoid hard-coded parameters.\nMinimise code duplication.\n\nClarity\n\nComment sufficiently.\nEnsure clarity and consistency in the model results tables.\nInclude run instructions.\nState run times and machine specifications.\n\nFunctionality\n\nOptimise model run time.\nSave outputs to a file.\nAvoid excessive output files.\nAddress large file sizes.\n\n\n\n\n\n\n\n\n\n\n\nView recommendations\n\n\n\n\n\nThe following framework has been directly copied from the RAP Community of Practice repository/website: NHS RAP Levels of RAP Framework.\nThis framework is maintained by the NHS RAP Community of Practice and is © 2024 Crown Copyright (NHS England), shared by them under the terms of the Open Government 3.0 licence.\nThe specific version of the framework copied below is that from commit 2549256 (9th September 2024).\n🥉 Baseline: RAP fundamentals offering resilience against future change.\n\nData produced by code in an open-source language (e.g., Python, R, SQL).\nCode is version controlled (see Git basics and using Git collaboratively guides).\nRepository includes a README.md file (or equivalent) that clearly details steps a user must follow to reproduce the code (use NHS Open Source Policy section on Readmes as a guide).\nCode has been peer reviewed.\nCode is published in the open and linked to & from accompanying publication (if relevant).\n\n🥈 Silver: Implementing best practice by following good analytical and software engineering standards. Meeting all of the above requirements, plus:\n\nOutputs are produced by code with minimal manual intervention.\nCode is well-documented including user guidance, explanation of code structure & methodology and docstrings for functions.\nCode is well-organised following standard directory format.\nReusable functions and/or classes are used where appropriate.\nCode adheres to agreed coding standards (e.g PEP8, style guide for Pyspark).\nPipeline includes a testing framework (unit tests, back tests).\nRepository includes dependency information (e.g. requirements.txt, PipFile, environment.yml).\nLogs are automatically recorded by the pipeline to ensure outputs are as expected.\nData is handled and output in a Tidy data format.\n\n🥇 Gold: Analysis as a product to further elevate your analytical work and enhance its reusability to the public. Meeting all of the above requirements, plus:\n\nCode is fully packaged.\nRepository automatically runs tests etc. via CI/CD or a different integration/deployment tool e.g. GitHub Actions.\nProcess runs based on event-based triggers (e.g., new data in database) or on a schedule.\nChanges to the RAP are clearly signposted. E.g. a changelog in the package, releases etc. (See gov.uk info on Semantic Versioning).",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Sharing reproducible models</span>"
    ]
  },
  {
    "objectID": "sharing_reproducible_models.html#implementing-these-recommendations",
    "href": "sharing_reproducible_models.html#implementing-these-recommendations",
    "title": "40  Sharing reproducible models",
    "section": "40.2 Implementing these recommendations",
    "text": "40.2 Implementing these recommendations\nA model and repository has been developed to help support, demonstrate and serve as a possible template for how you could meet these recommendations:\n\nHeather, A. Monks, T. (2025). Python DES RAP Template. https://github.com/pythonhealthdatascience/rap_template_python_des/.\n\nIt adheres to all the recommendations from:\n\n✅ Heather et al. (2025).\n✅ NHS Levels of RAP Framework.\n\nThe DES model is a simple queueing system where patients arrive, wait to see a nurse, undergo a consultation, and then leave. This model can be extended with advanced features such as multiple activities, branching paths, and priority-based queueing, as discussed in the book.\nThe model was inspired by this book, alongside other sources and with some other changes, and so the model is similar but with some structural differences. For details on how the model differs from this book and the rationale behind those changes, refer to docs/hsma_changes.md in the model repository.\n\n\n\n\nPython DES RAP Template GitHub",
    "crumbs": [
      "Part 7 - Model Reporting and Sharing",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Sharing reproducible models</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html",
    "href": "testing_large_numbers_scenarios.html",
    "title": "41  Running Large Numbers of Scenarios",
    "section": "",
    "text": "41.1 Scenarios\nWhen working out the best possible configuration for a service, you may wish to try out a large number of scenarios.\nLet’s return to our branching model (with the reproducibility set via sim-tools as described in chapter Chapter 14).\nWe have a number of parameters available to us in this model:\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 2\nWe can first create a python dictionary of the possible parameter values.\nscenarios = {\n    'patient_inter': [4, 8, 12],\n    'mean_reception_time': [2, 3],\n    'mean_n_consult_time': [6, 10, 14],\n    'mean_d_consult_time': [10, 20],\n    'number_of_receptionists': [1, 2],\n    'number_of_nurses': [1, 2, 3],\n    'number_of_doctors': [2, 3, 4],\n    'prob_seeing_doctor': [0.6, 0.8]\n}\nNext we use the itertools package to create every possible permutation of the scenarios.\nimport itertools\n\n# Generate all scenarios:\nall_scenarios_tuples = [\n    x for x in itertools.product(*scenarios.values())]\n# Convert list of tuples back to list of dictionaries:\nall_scenarios_dicts = [\n    dict(zip(scenarios.keys(), p)) for p in all_scenarios_tuples]\nLet’s take a look at the first 3 scenario dictionaries.\nall_scenarios_dicts[0:3]\n\n[{'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 2,\n  'prob_seeing_doctor': 0.6},\n {'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 2,\n  'prob_seeing_doctor': 0.8},\n {'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 3,\n  'prob_seeing_doctor': 0.6}]\nWe can see that all that has changed is the probability of seeing a doctor (the last key-value pair in each dictionary).\nHow many scenarios have we created?\nlen(all_scenarios_dicts)\n\n1296\nNow let’s update our model code.",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Running Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html#scenarios",
    "href": "testing_large_numbers_scenarios.html#scenarios",
    "title": "41  Running Large Numbers of Scenarios",
    "section": "",
    "text": "Warning\n\n\n\nBe careful - the total number of possible permutations starts to grow very rapidly when you have lots of parameters with multiple options for each!\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nMake sure to use exactly the same naming for the dictionary keys as is used in your g class.\nThis is because we will reset the values of the g class for each Trial programmatically.\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor a small number of possibilities, setting the variables by hand will be fine.\nFor a larger number, you may want to use the range function.\ne.g. to get 6, 10, 14 you would do\n\n[i for i in range(6, 15, 4)]\n\n[6, 10, 14]",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Running Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html#coding-the-model",
    "href": "testing_large_numbers_scenarios.html#coding-the-model",
    "title": "41  Running Large Numbers of Scenarios",
    "section": "41.2 Coding the model",
    "text": "41.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\n\n41.2.1 g class\nWe’ll just add in a space to for the scenario name.\n\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 2\n    scenario_name = 0 ##NEW\n\n\n\n41.2.2 Patient and model classes\nThese remained unchanged.\n\n\n41.2.3 Trial class\n\n41.2.3.1 The init method\nThe scenario is add to the results dataframe, along with some other results metrics.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"scenario\"] = [0]  ##NEW\n    self.df_trial_results[\"average_inter_arrival\"] = [0.0]  ##NEW\n    self.df_trial_results[\"num_recep\"] = [0]  ##NEW\n    self.df_trial_results[\"num_nurses\"] = [0]  ##NEW\n    self.df_trial_results[\"num_doctors\"] = [0]  ##NEW\n    self.df_trial_results[\"average_reception_time\"] = [0.0]  ##NEW\n    self.df_trial_results[\"average_nurse_time\"] = [0.0]  ##NEW\n    self.df_trial_results[\"average_doctor_time\"] = [0.0]  ##NEW\n    self.df_trial_results[\"prob_need_doctor\"] = [0.0]  ##NEW\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n41.2.4 The print_trial_results method\nThis remains unchanged.\n\n\n41.2.5 The run_trial method\nThis is updated to include the scenario name and other new metrics.\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        patient_level_results = my_model.run()\n\n        ##NEW\n        self.df_trial_results.loc[run] = [\n            g.scenario_name,\n            g.patient_inter,\n            g.number_of_receptionists,\n            g.number_of_nurses,\n            g.number_of_doctors,\n            g.mean_reception_time,\n            g.mean_n_consult_time,\n            g.mean_d_consult_time,\n            g.prob_seeing_doctor,\n            len(patient_level_results),\n            my_model.mean_q_time_recep,\n            my_model.mean_q_time_nurse,\n            my_model.mean_q_time_doctor\n            ]\n\n    return self.df_trial_results",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Running Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html#the-full-code",
    "href": "testing_large_numbers_scenarios.html#the-full-code",
    "title": "41  Running Large Numbers of Scenarios",
    "section": "41.3 The full code",
    "text": "41.3 The full code\nThe full updated code for the model is given below.\n\n\n\n\n\n\nClick here to view the code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 2\n    scenario_name = 0  ##NEW\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(mean = g.mean_reception_time, random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(mean = g.mean_d_consult_time, random_seed = self.run_number*5)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample() ##NEW\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample() ##NEW\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = self.nurse_consult_time_dist.sample() ##NEW\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.nurse_consult_time_dist.sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        return (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"scenario\"] = [0]  ##NEW\n        self.df_trial_results[\"average_inter_arrival\"] = [0.0]  ##NEW\n        self.df_trial_results[\"num_recep\"] = [0]  ##NEW\n        self.df_trial_results[\"num_nurses\"] = [0]  ##NEW\n        self.df_trial_results[\"num_doctors\"] = [0]  ##NEW\n        self.df_trial_results[\"average_reception_time\"] = [0.0]  ##NEW\n        self.df_trial_results[\"average_nurse_time\"] = [0.0]  ##NEW\n        self.df_trial_results[\"average_doctor_time\"] = [0.0]  ##NEW\n        self.df_trial_results[\"prob_need_doctor\"] = [0.0]  ##NEW\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            ##NEW\n            self.df_trial_results.loc[run] = [\n                g.scenario_name,\n                g.patient_inter,\n                g.number_of_receptionists,\n                g.number_of_nurses,\n                g.number_of_doctors,\n                g.mean_reception_time,\n                g.mean_n_consult_time,\n                g.mean_d_consult_time,\n                g.prob_seeing_doctor,\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, return the final results\n        return self.df_trial_results",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Running Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html#running-the-scenarios",
    "href": "testing_large_numbers_scenarios.html#running-the-scenarios",
    "title": "41  Running Large Numbers of Scenarios",
    "section": "41.4 Running the scenarios",
    "text": "41.4 Running the scenarios\nLet’s now create all of the scenario objects.\n\nresults = []\n\nfor index, scenario_to_run in enumerate(all_scenarios_dicts):\n    g.scenario_name = index\n\n    # Overwrite defaults from the passed dictionary\n\n    for key in scenario_to_run:\n        setattr(g, key, scenario_to_run[key])\n\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    results.append(my_trial.run_trial())\n\npd.concat(results).groupby(\"scenario\").mean().head(20)\n\n\n\n\n\n\n\n\naverage_inter_arrival\nnum_recep\nnum_nurses\nnum_doctors\naverage_reception_time\naverage_nurse_time\naverage_doctor_time\nprob_need_doctor\nArrivals\nMean Q Time Recep\nMean Q Time Nurse\nMean Q Time Doctor\n\n\nscenario\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n4.0\n1.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n133.505891\n0.676479\n\n\n1.0\n4.0\n1.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n105.505442\n1.263302\n\n\n2.0\n4.0\n1.0\n1.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n129.216818\n0.014072\n\n\n3.0\n4.0\n1.0\n1.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n107.602443\n0.147246\n\n\n4.0\n4.0\n1.0\n1.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n129.216818\n0.000000\n\n\n5.0\n4.0\n1.0\n1.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n95.026033\n0.032971\n\n\n6.0\n4.0\n1.0\n2.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n5.215946\n2.477255\n\n\n7.0\n4.0\n1.0\n2.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n7.497472\n1.842969\n\n\n8.0\n4.0\n1.0\n2.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n4.266968\n0.592513\n\n\n9.0\n4.0\n1.0\n2.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n9.260408\n0.089449\n\n\n10.0\n4.0\n1.0\n2.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n5.405535\n0.063385\n\n\n11.0\n4.0\n1.0\n2.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n8.370422\n0.015803\n\n\n12.0\n4.0\n1.0\n3.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n0.833707\n1.786491\n\n\n13.0\n4.0\n1.0\n3.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.871273\n2.689420\n\n\n14.0\n4.0\n1.0\n3.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n1.155603\n0.142991\n\n\n15.0\n4.0\n1.0\n3.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.697876\n0.615490\n\n\n16.0\n4.0\n1.0\n3.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n0.925463\n0.009072\n\n\n17.0\n4.0\n1.0\n3.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.540083\n0.186033\n\n\n18.0\n4.0\n2.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n0.091630\n134.540431\n0.676479\n\n\n19.0\n4.0\n2.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n0.091630\n106.515917\n1.263302\n\n\n\n\n\n\n\nFinally the following will give you a nice dictionary of all of your scenarios.\n\npd.DataFrame.from_dict(all_scenarios_dicts).head()\n\n\n\n\n\n\n\n\npatient_inter\nmean_reception_time\nmean_n_consult_time\nmean_d_consult_time\nnumber_of_receptionists\nnumber_of_nurses\nnumber_of_doctors\nprob_seeing_doctor\n\n\n\n\n0\n4\n2\n6\n10\n1\n1\n2\n0.6\n\n\n1\n4\n2\n6\n10\n1\n1\n2\n0.8\n\n\n2\n4\n2\n6\n10\n1\n1\n3\n0.6\n\n\n3\n4\n2\n6\n10\n1\n1\n3\n0.8\n\n\n4\n4\n2\n6\n10\n1\n1\n4\n0.6\n\n\n\n\n\n\n\n\npd.DataFrame.from_dict(all_scenarios_dicts).tail()\n\n\n\n\n\n\n\n\npatient_inter\nmean_reception_time\nmean_n_consult_time\nmean_d_consult_time\nnumber_of_receptionists\nnumber_of_nurses\nnumber_of_doctors\nprob_seeing_doctor\n\n\n\n\n1291\n12\n3\n14\n20\n2\n3\n2\n0.8\n\n\n1292\n12\n3\n14\n20\n2\n3\n3\n0.6\n\n\n1293\n12\n3\n14\n20\n2\n3\n3\n0.8\n\n\n1294\n12\n3\n14\n20\n2\n3\n4\n0.6\n\n\n1295\n12\n3\n14\n20\n2\n3\n4\n0.8",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Running Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html",
    "href": "running_parallel_cpus.html",
    "title": "42  Parallelisation",
    "section": "",
    "text": "42.1 A simple joblib example\nSimpy is a good candidate for running code in parallel! By running our simpy code in parallel, we can potentially dramatically cut down the length of time\nFirst, it may be helpful to see a simpler example of joblib.\nLet’s start by looking at a for loop to square the numbers 1 to 10.\nsquared_numbers = []\nfor i in range(1, 11, 1):\n  squared_numbers.append(i * i)\n\nprint(squared_numbers)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nWe can simplify the code above into a list comprehension.\n[i*i for i in range(1, 11, 1)]\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nWhy is this important? Well, to use joblib, it’s easiest to write our loop as a list comprehension.\nInstead of doing i * i to square our number, we have made a new function that does the same thing.\nfrom joblib import Parallel, delayed\n\ndef multiply_by_self(input_number):\n  return input_number * input_number\n\nParallel(n_jobs=2)(delayed(multiply_by_self)(i) for i in range(1, 11, 1))\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#a-simple-joblib-example",
    "href": "running_parallel_cpus.html#a-simple-joblib-example",
    "title": "42  Parallelisation",
    "section": "",
    "text": "Why Parallel and delayed?\n\n\n\nParallel is a function that allows you to run tasks concurrently across multiple CPU cores. By setting n_jobs=2, we tell Joblib to use 2 CPU cores to run process the tasks in parallel.\nThe function delayed is used to delay the execution of our function. If we had just run…\n\nParallel(n_jobs=2)(multiply_by_self)(i) for i in range(1, 11, 1)\n\n… then, by the time it gets passed to Parallel, the multiply_by_self(i) calls would have already returned, so there would be nothing left to execute in parallel. This is because squaring numbers from 1 to 10 is a very quick task.\nThe real benefit of joblib and parallelism will come when we have more computationally expensive tasks that take a longer time to complete.",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#coding-the-model",
    "href": "running_parallel_cpus.html#coding-the-model",
    "title": "42  Parallelisation",
    "section": "42.2 Coding the model",
    "text": "42.2 Coding the model\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\nWe will make use of the Joblib package to easily split our SimPy code to run across multiple processor cores.\nWe will take the model created in the Reproducibility chapter (Chapter 14) and add parallelisation to it.\n\n42.2.1 Library imports\nWe will need to import Parallel and delayed from the joblib library.\nYou will need to run !pip install joblib if you have not previously made use of this library.\n\nfrom joblib import Parallel, delayed\n\n\n\n42.2.2 The g, patient and model classes\nOur g, patient and model classes are unchanged.\n\n\n42.2.3 The trial class\nIn the trial class, we need to change a number of functions, tweak our attributes, and make use of the joblib library.\n\n\n\n\n\n\nWarning\n\n\n\nBecause of the way joblib executes things, if we try to keep track of our results in the same way we have so far - setting up a dummy dataframe and then using the .loc accessor to write our results to the correct row of the dataframe for each run - we will end up with an empty results list.\nInstead, we will create an empty list. Into this list we will place a dictionary of results from the run.\n\n\n\n42.2.3.1 The init method\nLet’s start by adjusting our __init__ method for our new way of carrying out the results collection.\n\ndef  __init__(self):\n    self.df_trial_results = []\n\n\n\n42.2.3.2 The process_trial_results method\nNext we want to create a new method that will turn our list of dictionaries into a Python dataframe.\nAll we need to do is call pd.DataFrame on that object. In this case, we overwrite the original df_trial_results object.\nNext we set the index of the dataframe to the run number, which is how it was set up in the original code.\n\ndef process_trial_results(self):\n  self.df_trial_results = pd.DataFrame(self.df_trial_results)\n  self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n42.2.3.3 the print_trial_results method\nBecause we went to the effort of setting the index in the step above, this method can remain unchanged.\n\n\n42.2.3.4 the run_single method\nFirst, let’s look back at how our run_trial function was written before.\n\ndef run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\")\n        print(\"\") # Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nTo use parallelisation, we now split this out into two separate functions. The first is the run_single method.\nNote that it’s very similar to the indented part of the for loop from the code above.\nThe main change is how the results are stored - they are now put into a dictionary. Remember, dictionaries use the format {“key”:value} - here we have made our column names the ‘keys’ and our results the ‘values’.\nFinally, it’s important to return the results object from the function.\n\ndef run_single(self, run):\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    random.seed(run)\n\n    my_model = Model(run)\n    patient_level_results = my_model.run()\n\n    results = {\"Run Number\":run,\n        \"Arrivals\": len(patient_level_results),\n        \"Mean Q Time Recep\": my_model.mean_q_time_recep,\n        \"Mean Q Time Nurse\": my_model.mean_q_time_nurse,\n        \"Mean Q Time Doctor\": my_model.mean_q_time_doctor\n        }\n\n    return results\n\n\n\n42.2.3.5 the run_trial method\nFinally, we need to do a few things.\nThe key one is making our trial now use the Parallel class and delayed function.\nWe set up an instance of the Parallel class and set the number of jobs to -1.\n\n\n\n\n\n\nTip\n\n\n\n-1 just means that the joblib library will use every available core to run the code.\nYou can instead specify a particular number of cores to use as a positive integer value.\n\n\nWe then pass in the self.run_single function to the delayed function.\nFinally, we pass in the arguments that are required for the self.run_single function, which is just the run number.\nThe syntax can appear a little bit strange - just take a close look at the full line below and try and understand it.\n\nself.df_trial_results = Parallel(n_jobs=-1)(delayed(self.run_single)(run) for run in range(g.number_of_runs))\n\nWe assign all of this to the self.df_trial_results attribute of our class.\nNow the only additional step is to run our new process_trial_results() function before we run print_trial_results().\n\ndef run_trial(self):\n    print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\")\n    print(\"\") # Print a blank line\n\n    # Run the simulation for the number of runs specified in g class.\n    self.df_trial_results = Parallel(n_jobs=-1)(delayed(self.run_single)(run) for run in range(g.number_of_runs))\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.process_trial_results()\n    self.print_trial_results()\n\nVoila! Our model is now set up to use parallelisation. Let’s take a look at how much faster this can make things.",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#evaluating-the-code-outputs",
    "href": "running_parallel_cpus.html#evaluating-the-code-outputs",
    "title": "42  Parallelisation",
    "section": "42.3 Evaluating the code outputs",
    "text": "42.3 Evaluating the code outputs\nFirst, let’s run this the original way and time how long it takes.\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00              57.19                1.15\n1              125.0               1.84             144.69                0.02\n2              112.0               0.85              15.30                1.13\n3              120.0               1.08              82.67                0.04\n4              132.0               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n995             97.0               0.59              36.91                0.00\n996            111.0               1.10              68.32                0.18\n997            129.0               0.99             122.27                0.06\n998            140.0               1.73              92.57                0.30\n999            109.0               0.67              45.83                0.39\n\n[1000 rows x 4 columns]\nArrivals              120.98\nMean Q Time Recep       1.31\nMean Q Time Nurse      62.75\nMean Q Time Doctor      0.50\ndtype: float64\n\nIt took 40.0011 seconds to do 10 runs without parallelisation\n\n\nNow let’s run it again with parallisation.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\n\n\n\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0                102               0.00              57.19                1.15\n1                125               1.84             144.69                0.02\n2                112               0.85              15.30                1.13\n3                120               1.08              82.67                0.04\n4                132               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n995               97               0.59              36.91                0.00\n996              111               1.10              68.32                0.18\n997              129               0.99             122.27                0.06\n998              140               1.73              92.57                0.30\n999              109               0.67              45.83                0.39\n\n[1000 rows x 4 columns]\nArrivals              120.98\nMean Q Time Recep       1.31\nMean Q Time Nurse      62.75\nMean Q Time Doctor      0.50\ndtype: float64\n\nIt took 32.3683 seconds to do 10 runs **with** parallelisation",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#evaluating-speed-gains",
    "href": "running_parallel_cpus.html#evaluating-speed-gains",
    "title": "42  Parallelisation",
    "section": "42.4 Evaluating speed gains",
    "text": "42.4 Evaluating speed gains\nLet’s run the model a few times, specifying a different number of cores to run it on each time.\nThis book is being compiled on a machine with a 14 core processor.\nAn argument has been added to the run_trial function to allow us to pass in the number of cores to use.\nThe results below all relate to 100 runs of the simulation.\n\nspeed = []\n\ng.number_of_runs = 100\n\nfor i in range(1, 15, 1):\n    start_time = time.time()\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    my_trial.run_trial(cores=i)\n\n    run_time = round((time.time() - start_time), 3)\n\n    speed.append({\"Cores\":i, \"Run Time (seconds)\": run_time})\n\ntiming_results = pd.DataFrame(speed)\n\nprint(timing_results)\n\n    Cores  Run Time (seconds)\n0       1               4.668\n1       2              12.810\n2       3              12.363\n3       4              10.609\n4       5              13.158\n5       6              14.729\n6       7              16.159\n7       8               0.965\n8       9              12.726\n9      10              11.258\n10     11              20.701\n11     12               0.822\n12     13               0.782\n13     14              12.473\n\n\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nLet’s run it again and look at the speed gains when doing 1000 runs of the simulation.\nNotice that doubling the number of cores doesn’t halve the time - there is fixed overhead that will take a certain amount of time. This can be even more noticeable with a smaller number of runs.\nWe make big gains at the beginning, but the fixed overheads mean that higher numbers of cores start to have less and less of an effect.\n\n\n    Cores  Run Time (seconds)\n0       1              38.831\n1       2              29.703\n2       3              23.825\n3       4              21.798\n4       5              22.016\n5       6              20.702\n6       7              21.740\n7       8              14.876\n8       9              13.957\n9      10              14.161\n10     11              25.492\n11     12              15.549\n12     13              12.828\n13     14              13.655",
    "crumbs": [
      "Part 8 - Advanced Concepts",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html",
    "href": "alternative_foss_simulation_libraries_software.html",
    "title": "43  Alternative FOSS Simulation Libraries and Software",
    "section": "",
    "text": "43.1 Python libraries\nWhile the focus of this book is on SimPy, there are other open-source alternatives for discrete event simulation. We will not give a full treatment of the pros and cons of each option, but just make you aware of the key players and some resources for each so you can explore them if you wish to.",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#python-libraries",
    "href": "alternative_foss_simulation_libraries_software.html#python-libraries",
    "title": "43  Alternative FOSS Simulation Libraries and Software",
    "section": "",
    "text": "43.1.1 ciw\n\n“Ciw is a discrete event simulation library for open queueing networks. Its core features include the capability to simulate networks of queues, multiple customer classes, and implementation of Type I blocking for restricted networks. A number of other features are also implemented, including priorities, baulking, reneging, schedules, slotted services, batch arrivals, service disciplines, dynamic customer classes, and deadlock detection.\n\n\nThe name Ciw is the Welsh word for a queue.”\n\n\nCiw documentation\n\nAn example of a ciw simulation of an urgent care call centre can be found in this repository.\nThere is also a more detailed description of the steps required to convert a model from simpy to ciw in this tutorial by Monks.\n\n\n43.1.2 salabim\n\n“Salabim is a package for discrete event simulation in Python. It follows the methodology of process description as originally demonstrated in Simula and later in Prosim, Must and Tomas. The process interaction methods are also quite similar to the Python package SimPy version 2.\n\n\nThe package comprises discrete event simulation, queue handling, resources, stores, statistical sampling and monitoring. And -last but not least- real time 2D- and 3D-animation and video production.”\n\n\nSalabim documentation\n\nSalabim is thoroughly documented and sets itself apart by providing methods for 2D and 3D animation.",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#r-libraries",
    "href": "alternative_foss_simulation_libraries_software.html#r-libraries",
    "title": "43  Alternative FOSS Simulation Libraries and Software",
    "section": "43.2 R libraries",
    "text": "43.2 R libraries\n\n43.2.1 simmeR\n\nsimmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. Designed to be a generic framework like SimPy or SimJulia, it leverages the power of Rcpp to boost the performance and turning DES in R feasible. As a noteworthy characteristic, simmer exploits the concept of trajectory: a common path in the simulation model for entities of the same type. It is pretty flexible and simple to use, and leverages the chaining/piping workflow introduced by the magrittr package.\n\n\nsimmer documentation\n\nThe documentation is notable for containing details on translating models from simpy to simmer.\nLink\nUsers of R in the NHS community have been exploring the use of simpy for healthcare examples for several years.\nThis tutorial from the strategy unit covers the creation of a simple model.\nOne key benefit is being able to plot a flow diagram of the steps in a simmer model.\n\n\n\nSimmer Plot: credit to Stacey Croft, Anastasiia Zharinova and Tom Jemmett 1",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#gui-software",
    "href": "alternative_foss_simulation_libraries_software.html#gui-software",
    "title": "43  Alternative FOSS Simulation Libraries and Software",
    "section": "43.3 GUI software",
    "text": "43.3 GUI software\n\n43.3.1 JaamSim\nJaamSim is quite different from all of the other offerings discussed so far due to it providing a graphical, drag and drop interface for simulations.\nYou can read more, and download the software, on their website.\nOne big benefit of JaamSim, in addition to its lower barrier to entry, is the ability to visually demonstrate the movement of entities to stakeholders, as well as generating graphs which update live as the simulation is run.",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#footnotes",
    "href": "alternative_foss_simulation_libraries_software.html#footnotes",
    "title": "43  Alternative FOSS Simulation Libraries and Software",
    "section": "",
    "text": "https://the-strategy-unit.github.io/des_simmer_workshop/↩︎",
    "crumbs": [
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "44  Further Reading",
    "section": "",
    "text": "44.1 SimPy examples",
    "crumbs": [
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Further Reading</span>"
    ]
  },
  {
    "objectID": "further_reading.html#simpy-examples",
    "href": "further_reading.html#simpy-examples",
    "title": "44  Further Reading",
    "section": "",
    "text": "Warning\n\n\n\nNote that the linked examples will generally not follow the exact structure we have used throughout this book. However, the fundamental concepts remain unchanged, and the knowledge you have acquired from this book should help you to read and understand most simpy models out there.\n\n\n\n44.1.1 General examples\nA list of additional SimPy examples is kept up-to-date here.\n\n\n44.1.2 Visualisation examples\nA library of simpy visualisation examples, which may also prove useful due to containing code for a range of different types of healthcare model, can be found here.",
    "crumbs": [
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Further Reading</span>"
    ]
  }
]