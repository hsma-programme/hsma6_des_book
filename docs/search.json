[
  {
    "objectID": "multiple_entity_types.html",
    "href": "multiple_entity_types.html",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "",
    "text": "14.1 The Approach\nTherefore, we will be wanting to set up a generator for each of the new types of patients we opt to add to this model.\nIn this case, we are going to have patients of high, medium and low severity.\nHowever, before we kick off, it will save us time down the road if we first improve the way the model handles randomness. Full details can be found in the reproducibility chapter, but we will cover the key changes in this section as well.\nIn short, what we will do in our model is",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#the-approach",
    "href": "multiple_entity_types.html#the-approach",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "",
    "text": "Tip\n\n\n\nThe basic rule of thumb is have different generators if the entities (and / or what happens to them) is different if they come in via a different route\n\n\n\n\n\nLow severity patients will arrive frequently, only spend a short time with each resource, and have a low probability of needing to see the doctor.\nMedium severity pateints will arrive less frequently, spend more time with a nurse than the doctor, and have a medium probability of needing to see the doctor.\nHigh severity patients will arrive even less frequently, spend a short amount of time with the nurse, then always visit the doctor and spend a long time with them.\n\n\n\n\nadd additional attributes to our g class for our different types of patients\nadd an additional attribute to our patient class to track the type of patient they are\nmove the setup of our sampling distributions into our model class\nadjust our patient generator function to pull in the appropriate inter-arrival time for the patient type\nadjust our patient journey function to pull in the appropriate sampling distribution for each patient type\nadjust our model run function to multiple generators that will cause our different patient types to arrive at the appropriate rate\nupdate our outputs and visualisations to check our different patient classes are working as expected\n\n\n14.1.1 Some different ways we could approach this\n\n\n\n\n\n\nNote\n\n\n\nAs mentioned before, there are different approaches you can take to having multiple types of entities - this is one of the situations in which the flexiblity of Python and SimPy start to become apparent, and there isn’t necessarily one ‘right’ way.\nFor example, let’s imagine a scenario where we have two types of patient arriving at different rates - let’s split them into ‘seriously injured’ and ‘mildly injured’.\n\n14.1.1.1 Approaches to Managing Arrivals\nWe could filter our historical data by patient type, work out the inter-arrival time between the ‘seriously injured’ patients and set up a generator for these patients, and then repeat this for the ‘mildly injured’ patients.\nHowever - you could instead have stuck with a single generator, like in our previous approach, but instead sampled whether the incoming patient is a ‘seriously injured’ or ‘mildly injured’ patient at the start of their journey based on known proportions of these patients.\n\n\n14.1.1.2 Approaches to Patient Classes\nSimilarly, when it comes to our patient classes, there are multiple ways we could handle it.\nWe could use the concept of inheritance to have a main patient class, then have multiple ‘child’ classes who inherit the properties of the parent class while also recording their own special attributes, with the different processes generating the relevant patient type.\nHowever, if our patients are following the same or a sufficiently similar route that means that the attributes of the patient classes don’t substantially change, it is often simpler to add an additional attribute that we set when initialising a patient to track their ‘type’, allowing us to then filter and subset patient groups in our results. This is similar to what is done in the priority resources chapter.\n\n\n\nIn this example, we will be working with three ‘tiers’ of patients and - keeping a single patient class and using an attribute to differentiate between them - using multiple generators with each patient class having their own inter-arrival time",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#coding-the-model",
    "href": "multiple_entity_types.html#coding-the-model",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "14.2 Coding the model",
    "text": "14.2 Coding the model\n\n14.2.1 Imports\nAs mentioned before, we will be taking the opportunity to better control the randomness of our model runs while we are making this change - so we will import the Exponential and Uniform distribution functions from the sim_tools library.\n\n\n\n\n\n\nTip\n\n\n\nIf you don’t already have sim-tools in your environment, install it with pip install sim-tools.\nNote that we use a hyphen in the package name when installing it, but an underscore when importing it into our script.\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential, Uniform ## NEW\n\n\n\n14.2.2 the g class\nWe need to add a few additional parameters to our g class.\nAs the number of parameters in our g class continues to increase, it can be worth reordering them and splitting them up with some comments to make it clear.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    # Simulation Parameters\n    sim_duration = 60 * 8\n    number_of_runs = 5\n\n    # Shared Parameters between patient classes\n1    mean_reception_time = 2\n\n    # Resource Numbers\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n\n    # -- Entity and Inter-arrival Time Parameters -- #\n\n    # Tier 1 Patients - Very Ill\n2    entity_1 = {\n3        'label': 'high',\n4        'mean_inter_arrival_time': 25,\n        'mean_n_consult_time': 5,\n        'mean_d_consult_time': 45,\n        'prob_seeing_doctor': 1.0\n    }\n\n    # Tier 2 Patients - Somewhat Ill\n5    entity_2 = {\n        'label': 'medium',\n        'mean_inter_arrival_time': 15,\n        'mean_n_consult_time': 10,\n        'mean_d_consult_time': 20,\n        'prob_seeing_doctor': 0.6\n    }\n\n    # Tier 3 Patients - Mildly Ill\n    entity_3 = {\n        'label': 'low',\n        'mean_inter_arrival_time': 5,\n        'mean_n_consult_time': 8,\n        'mean_d_consult_time': 10,\n        'prob_seeing_doctor': 0.2\n    }\n\n\n1\n\nIn this case, we will have all of our patients having the same average time spent with the receptionist. Therefore, we can set this parameter up in the usual way.\n\n2\n\nWe are going to structure our parameters per entity type (here, with each entity being a type of patient). We will use a dictionary with the parameter name as a key and the parameter value as the associated value. We could have instead structured this as a dictionary per parameter, with the keys being the entity types and the values being the associated parameter value. We have used the variable name of the form ‘entity_x’ rather than ‘high_severity’, for example. This means our patient type labels are easy to change later as we will simply change the ‘label’ entry for the entity, and not have to make changes to the name of the variable itself in our code.\n\n3\n\nHere, we set our patient type label. This will be used to identify and pull back the correct values for the patient throughout, so they must be different for each entity type.\n\n4\n\nWhile each entity dictionary does not have to have all keys, where they are used across multiple entity types, you should keep the naming consistent.\n\n5\n\nWe repeat the same structure for as many different entity types as we wish to define.\n\n\n\n\n\n\n14.2.3 The Patient class\nIn our patient class, we’re going to add a new label that will relate to the severity of our patients. We will pass this in when initialising the patients later on.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, severity):\n        self.id = p_id\n\n        self.severity = severity\n\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.seen_doctor = False ## NEW\n        self.q_time_doctor = 0\n\n\n\n14.2.4 The Model Class\n\n14.2.4.1 The __init__ method\n\n\n\n\n\n\nNote\n\n\n\nOne of the big changes here is that, unlike our simple models, we will be setting up our sampling distributions here too. The approach we are using here has strong benefits for reproducibility of your models and ensuring your conclusions on the impact of parameter changes are valid.\nTo see how this is done with a single patient class, head over to the reproducibility chapter.\nThe setup of a sampling distribution follows a repeatable pattern.\n\nself.patient_inter_arrival_dist = Exponential(\n    mean = g.patient_inter,\n    random_seed = self.run_number * 2\n    )\n\n\nself.patient_reception_time_dist = Exponential(\n    mean = g.mean_reception_time,\n    random_seed = self.run_number * 3\n    )\n\nThen, when we wish to pull back a value from this distribution, we use\n\nself.patient_reception_time_dist.sample()\n\nself.patient_reception_time_dist.sample()\n\nBy using the run number as part of the random seed, we can ensure reproducibility across the same run in different trials.\nTo avoid getting identical numbers in the instance that we had two distributions with the same mean, we multiply the random seed by a number. It doesn’t matter what the number is (as long as you’re not randomly generating it in the code!).\n\n\nLet’s now start setting up our model class.\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n1        self.results_df[\"Patient Severity\"] = [\"\"] ## NEW\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Sees Doctor\"] = [False]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Completed Journey\"] = [False]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        # ============================================== #\n        # NEW CODE                                       #\n        # ============================================== #\n\n2        self.patient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n3                mean = g.entity_1['mean_inter_arrival_time'],\n4                random_seed = self.run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n5                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = self.run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n6                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = self.run_number * 4\n                )\n\n        }\n\n        # In this model, all patients have the same distribution for the time they spend with\n        # a receptionist, so we can set up a single distribution instead of a dictionary\n        # of distributions\n        self.patient_reception_time_dist = Exponential(\n                mean = g.mean_reception_time,\n                random_seed = self.run_number * 5\n                )\n\n        # The time spent with the nurses, with the doctors, and the probability of seeing a\n        # doctor all differ between our tiers of patients, so we need to set up dictionaries of\n        # distributions like with the\n        self.nurse_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_n_consult_time'],\n                random_seed = self.run_number * 6\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_n_consult_time'],\n                random_seed = self.run_number * 7\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_n_consult_time'],\n                random_seed = self.run_number * 8\n                )\n\n        }\n\n        self.doctor_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_d_consult_time'],\n                random_seed = self.run_number * 9\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_d_consult_time'],\n                random_seed = self.run_number * 10\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_d_consult_time'],\n                random_seed = self.run_number * 11\n                )\n\n        }\n\n        self.doctor_prob_seeing_dist = Uniform(\n            low=0.0,\n            high=1.0,\n            random_seed = self.run_number * 12\n            )\n\n        self.doctor_probs_seeing = {\n            g.entity_1['label']: g.entity_1['prob_seeing_doctor'],\n            g.entity_2['label']: g.entity_2['prob_seeing_doctor'],\n            g.entity_3['label']: g.entity_3['prob_seeing_doctor']\n        }\n\n\n1\n\nWe add in an additional column in our dataframe where we will store the patient severity. This wll help us to summarise results for different patient groups later.\n\n2\n\nNext, we need to set up our inter-arrival time distributions.\n\n3\n\nFor the mean, by having a single attribute but setting these up as a dictionary, we will be able to access the relevant distribution with self.patient_inter_arrival_dist['high'], replacing ‘high’ with the tier of patient (or, in a different model, whichever identifier we have opted to use for our different patients)\n\n4\n\nFor the random seed, we will use the run number to ensure reproducibility across runs, but we will multiply it by some other value (which is random in the sense that it doesn’t matter what it is, but non-random in that we have chosen it and do not vary it across runs). By making it different for different distributions, we avoid the possibility of having different distributions that have the same mean and same set of randomly generated numbers in the same order.\n\n5\n\nWe then repeat this, making sure we pull back the value from our tier 2 patients this time.\n\n6\n\nFinally, we repeat for our tier 3 patients. We could repeat this for as many patient classes as we wished.\n\n\n\n\nLet’s print the output of one of these dictionaries so you can see the effect of passing in our entity label as the parameter. .\n\nrun_number = 1\n\npatient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_inter_arrival_time'],\n                random_seed = run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = run_number * 4\n                )\n\n        }\n\npatient_inter_arrival_dist\n\n{'high': &lt;sim_tools.distributions.Exponential at 0x7f60e8ff1c30&gt;,\n 'medium': &lt;sim_tools.distributions.Exponential at 0x7f60e8ff12a0&gt;,\n 'low': &lt;sim_tools.distributions.Exponential at 0x7f61402bec80&gt;}\n\n\nI can now pull back and sample from these distributions.\n\npatient_inter_arrival_dist['high']\n\n&lt;sim_tools.distributions.Exponential at 0x7f60e8ff1c30&gt;\n\n\n\npatient_inter_arrival_dist['high'].sample()\n\n3.2465284000996624\n\n\nLet’s imagine I’ve initiated a patient. Now, I can pass in the severity attribute of that patient to pull back the correct distribution.\n\nmy_example_patient = Patient(p_id=123, severity=\"low\")\n\npatient_inter_arrival_dist[my_example_patient.severity].sample()\n\n18.994133312745088\n\n\n\n\n14.2.4.2 The generator_patient_arrivals method\nHere, the key thing we need to do is make it possible to vary the inter-arrival time depending on the class of patient we are working with - as we have just demonstrated above.\nWe will call this method three times later in our code - one per severity of patient. You could call it as many times as needed for different patients, or even do this in a loop if you had an unusually large number of entities.\n\n# A generator function that represents the DES generator for patient\n    # arrivals\n1    def generator_patient_arrivals(self, patient_severity):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n2            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n3            p = Patient(self.patient_counter, patient_severity)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n4            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n5            sampled_inter = self.patient_inter_arrival_dist[patient_severity].sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n6            yield self.env.timeout(sampled_inter)\n\n\n1\n\nWe begin by adding an extra parameter that will get passed into our patient generator method. By passing in ‘high’, ‘medium’ or ‘low’, we will be able to look up the appropriate inter-arrival time and ensure we set up our patient objects with the correct severity indicator.\n\n2\n\nAs we have defined the patient counter at the model level, we will not end up with overlapping IDs across our different patient severities - they will remain unique.\n\n3\n\nHere, we will pass in the patient severity to the patient constructor so that it can be added as a patient attribute.\n\n4\n\nOur attend_clinic method will be updated to cope with patients of different severity and pull back the correct values. Alternatively, if our patients of different severity had substantially different pathways, we may wish to define different attend_clinic methods and use conditional logic here to determine which pathway they will be sent down; however, in this case, our pathways are the same, so we do not need to do this.\n\n5\n\nRemember - our attribute self.patient_inter_arrival_dist is now a dictionary. By passing in the patient severity as our ‘key’, it will look up the correct distribution from our self.patient_inter_arrival_dist automatically. We then use the ‘sample()’ method to get out an appropriate inter-arrival time for that severity of patient.\n\n6\n\nAs before, we pass this inter-arrival time to the self.env.timeout() method. This will pause the patient-generating process in place for this severity of patient until the sampled time has elapsed - but during this time patients of other severities will continue to be generated, and patients will progress through their pathways appropriately.\n\n\n\n\n\n\n14.2.4.3 The attend_clinic method\nLet’s start working through the changes to the method where the patients move through the system.\nTo start with, they see a receptionist. All patients have the same distribution for this regardless of their severity; however, we do need to ensure we are sampling from this distribution in the correct way.\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n\n1        self.results_df.at[patient.id, \"Patient Severity\"] = (\n                 patient.severity\n            )\n\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n2            sampled_recep_act_time = self.patient_reception_time_dist.sample()\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n    # Here's where the patient finishes with the receptionist, and starts queuing for the nurse\n\n\n1\n\nFirst, let’s ensure we record the severity of our patients against their entry in the dataframe when they enter the system.\n\n2\n\nWe are going to use the .sample() method of our patient_reception_time_dist to pull back a number from our distribution. Everything else in this section of the code is unchanged.\n\n\n\n\nLet’s continue - for the nurse and doctor steps, it will be similar, but we will need to select the correct distribution depending on the patient severity.\nRemember - the patient object we have passed in has a ‘severity’ attribute that will match the key of one of the entries in the relevant dictionary of distributions.\nWe’ll look at the nurse step next.\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n1            sampled_nurse_act_time = self.nurse_consult_time_dist[patient.severity].sample()\n\n            # Here we'll store the queuing time for the nurse and the sampled time to spend with\n            # the nurse in the results DataFrame against the ID for this patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled above.\n            # This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n\n1\n\nHere, we pass in the severity attribute of the patient who is currently going through the model to filter our dictionary of nurse consult time distributions. If the label was, for example, ‘high’, we’d get the distribution for our most severe, tier 1 patients. We then sample from this, getting an appropriate length of time for this severity of patient to spend with the nurse.\n\n\n\n\nAnd finally, let’s look at the doctor step. Here, we will need to sample twice - once to see whether the patient actually needs to the see the doctor, and if they do, we sample from a different distribution to get the length of time spent with the doctor.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system\n1        if self.doctor_prob_seeing_dist.sample() &lt; self.doctor_probs_seeing[patient.severity]:\n            start_q_doctor = self.env.now\n\n            self.results_df.at[patient.id, \"Sees Doctor\"] = True\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n2                sampled_doctor_act_time = self.doctor_consult_time_dist[patient.severity].sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n        else:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = False\n\n        self.results_df.at[patient.id, \"Completed Journey\"] = True\n\n\n1\n\nHere, we sample from our uniform distribution, and compare it with the relevant value for our patient depending on their severity.\n\n2\n\nThis time, we sample from our exponential distribution, again selecting the correct distribution using the patient severity.\n\n\n\n\n\n\n14.2.4.4 The calculate_run_results method\nFor now, we will leave this unchanged. This means our averages will be for the whole cohort, not for the different severities of patients - however, we can calculate the latter using the patient-level\n\n\n14.2.4.5 The run method\nThe key change to the run method is that we will start up three different patient generators. Previously, we have just passed in one.\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients\n1        self.env.process(self.generator_patient_arrivals(g.entity_1['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_2['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_3['label']))\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Return the patient-level results from this run of the model\n        return self.results_df\n\n\n1\n\nFor each entity type, we now set up a separate process to generate them. By passing in the entity label to use here, the label - which in this case we are using to indicate severity, but could be any characteristic that separates your patients -",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#the-full-code",
    "href": "multiple_entity_types.html#the-full-code",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "14.3 The Full Code",
    "text": "14.3 The Full Code\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential, Uniform ## NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    # Simulation Parameters\n    sim_duration = 60 * 8\n    number_of_runs = 5\n\n    # Shared Parameters between patient classes\n    mean_reception_time = 2\n\n    # Resource Numbers\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n\n    # -- Entity and Inter-arrival Time Parameters -- #\n\n    # Tier 1 Patients - Very Ill\n    entity_1 = {\n        'label': 'high',\n        'mean_inter_arrival_time': 25,\n        'mean_n_consult_time': 5,\n        'mean_d_consult_time': 45,\n        'prob_seeing_doctor': 1.0\n    }\n\n    # Tier 2 Patients - Somewhat Ill\n    entity_2 = {\n        'label': 'medium',\n        'mean_inter_arrival_time': 15,\n        'mean_n_consult_time': 10,\n        'mean_d_consult_time': 20,\n        'prob_seeing_doctor': 0.6\n    }\n\n    # Tier 3 Patients - Mildly Ill\n    entity_3 = {\n        'label': 'low',\n        'mean_inter_arrival_time': 5,\n        'mean_n_consult_time': 8,\n        'mean_d_consult_time': 10,\n        'prob_seeing_doctor': 0.2\n    }\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, severity):\n        self.id = p_id\n\n        self.severity = severity\n\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.seen_doctor = False ## NEW\n        self.q_time_doctor = 0\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Patient Severity\"] = [\"\"] ## NEW\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Sees Doctor\"] = [False]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df[\"Completed Journey\"] = [False]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        # ============================================== #\n        # NEW CODE                                       #\n        # ============================================== #\n\n        self.patient_inter_arrival_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_inter_arrival_time'],\n                random_seed = self.run_number * 2\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_inter_arrival_time'],\n                random_seed = self.run_number * 3\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_inter_arrival_time'],\n                random_seed = self.run_number * 4\n                )\n\n        }\n\n        # In this model, all patients have the same distribution for the time they spend with\n        # a receptionist, so we can set up a single distribution instead of a dictionary\n        # of distributions\n        self.patient_reception_time_dist = Exponential(\n                mean = g.mean_reception_time,\n                random_seed = self.run_number * 5\n                )\n\n        # The time spent with the nurses, with the doctors, and the probability of seeing a\n        # doctor all differ between our tiers of patients, so we need to set up dictionaries of\n        # distributions like with the\n        self.nurse_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_n_consult_time'],\n                random_seed = self.run_number * 6\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_n_consult_time'],\n                random_seed = self.run_number * 7\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_n_consult_time'],\n                random_seed = self.run_number * 8\n                )\n\n        }\n\n        self.doctor_consult_time_dist = {\n            g.entity_1['label']: Exponential(\n                mean = g.entity_1['mean_d_consult_time'],\n                random_seed = self.run_number * 9\n                ),\n            g.entity_2['label']: Exponential(\n                mean = g.entity_2['mean_d_consult_time'],\n                random_seed = self.run_number * 10\n                ),\n            g.entity_3['label']: Exponential(\n                mean = g.entity_3['mean_d_consult_time'],\n                random_seed = self.run_number * 11\n                )\n\n        }\n\n        self.doctor_prob_seeing_dist = Uniform(\n            low=0.0,\n            high=1.0,\n            random_seed = self.run_number * 12\n            )\n\n        self.doctor_probs_seeing = {\n            g.entity_1['label']: g.entity_1['prob_seeing_doctor'],\n            g.entity_2['label']: g.entity_2['prob_seeing_doctor'],\n            g.entity_3['label']: g.entity_3['prob_seeing_doctor']\n        }\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self, patient_severity):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter, patient_severity)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist[patient_severity].sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n\n        self.results_df.at[patient.id, \"Patient Severity\"] = (\n                 patient.severity\n            )\n\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample()\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n    # Here's where the patient finishes with the receptionist, and starts queuing for the nurse\n\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            sampled_nurse_act_time = self.nurse_consult_time_dist[patient.severity].sample()\n\n            # Here we'll store the queuing time for the nurse and the sampled time to spend with\n            # the nurse in the results DataFrame against the ID for this patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled above.\n            # This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system\n        if self.doctor_prob_seeing_dist.sample() &lt; self.doctor_probs_seeing[patient.severity]:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = True\n\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.doctor_consult_time_dist[patient.severity].sample()\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n        else:\n            self.results_df.at[patient.id, \"Sees Doctor\"] = False\n\n        self.results_df.at[patient.id, \"Completed Journey\"] = True\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients\n        self.env.process(self.generator_patient_arrivals(g.entity_1['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_2['label']))\n        self.env.process(self.generator_patient_arrivals(g.entity_3['label']))\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Return the patient-level results from this run of the model\n        return self.results_df",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#checking-our-implementation",
    "href": "multiple_entity_types.html#checking-our-implementation",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "14.4 Checking Our Implementation",
    "text": "14.4 Checking Our Implementation\nUsually we would go on to run a trial - for now, we’ll just look at the output of a single run of our new model.\n\nmy_model = Model(run_number=1)\n\npatient_level_results = my_model.run()\n\npatient_level_results.head(20).round(2)\n\n\n\n\n\n\n\n\n\nPatient Severity\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\nhigh\n0.00\n3.97\n0.00\n3.46\nTrue\n0.00\n148.00\nTrue\n\n\n2\nmedium\n3.97\n1.50\n1.96\n7.08\nFalse\nNaN\nNaN\nTrue\n\n\n3\nlow\n5.47\n2.60\n6.43\n4.30\nTrue\n0.00\n2.30\nTrue\n\n\n4\nmedium\n6.43\n1.06\n9.67\n10.25\nTrue\n0.00\n15.49\nTrue\n\n\n5\nhigh\n5.89\n0.06\n19.87\n0.92\nTrue\n14.57\n22.21\nTrue\n\n\n6\nmedium\n1.70\n0.87\n19.91\n5.69\nTrue\n31.10\n9.30\nTrue\n\n\n7\nhigh\n1.35\n1.28\n24.32\n3.01\nTrue\n37.38\n42.34\nTrue\n\n\n8\nlow\n0.00\n0.23\n19.45\n11.58\nTrue\n68.15\n5.38\nTrue\n\n\n9\nlow\n0.00\n0.12\n28.99\n4.13\nFalse\nNaN\nNaN\nTrue\n\n\n10\nhigh\n0.00\n2.00\n30.83\n2.68\nTrue\n66.72\n44.94\nTrue\n\n\n11\nmedium\n0.00\n2.18\n26.40\n8.95\nTrue\n89.41\n37.65\nTrue\n\n\n12\nlow\n0.00\n2.33\n26.34\n25.07\nFalse\nNaN\nNaN\nTrue\n\n\n13\nlow\n1.63\n0.46\n50.95\n6.31\nTrue\n71.33\n11.22\nTrue\n\n\n14\nhigh\n0.90\n4.36\n52.90\n3.67\nTrue\n78.88\n36.13\nTrue\n\n\n15\nlow\n1.74\n2.86\n53.71\n2.36\nFalse\nNaN\nNaN\nTrue\n\n\n16\nlow\n0.63\n4.03\n52.05\n8.71\nFalse\nNaN\nNaN\nTrue\n\n\n17\nlow\n1.59\n1.04\n59.72\n0.57\nFalse\nNaN\nNaN\nTrue\n\n\n18\nlow\n0.00\n0.17\n55.16\n0.22\nFalse\nNaN\nNaN\nTrue\n\n\n19\nlow\n0.00\n0.88\n51.18\n4.38\nFalse\nNaN\nNaN\nTrue\n\n\n20\nmedium\n0.26\n1.14\n54.42\n2.07\nTrue\n73.71\n8.95\nTrue\n\n\n\n\n\n\n\n\nWe can now check the average time spent at each stage.\n\n(\n    patient_level_results.reset_index()\n    .groupby('Patient Severity')\n    .agg({\n        'Patient ID': 'count',\n        'Time with Recep': 'mean',\n        'Time with Nurse': 'mean',\n        'Sees Doctor': 'mean',\n        'Time with Doctor': 'mean'\n    })\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\nPatient ID\nTime with Recep\nTime with Nurse\nSees Doctor\nTime with Doctor\n\n\nPatient Severity\n\n\n\n\n\n\n\n\n\nhigh\n23\n1.73\n3.81\n1.0\n64.81\n\n\nlow\n90\n2.04\n6.19\n0.243243\n7.11\n\n\nmedium\n37\n1.80\n10.72\n0.388889\n23.09\n\n\n\n\n\n\n\n\nThese numbers look pretty good - we aren’t seeing much variation across the time patients spend with the receptionist, but we are seeing expected variation across the time they spent with the nurse and the doctor, as well as the probability of them seeing the doctor.\nHowever, uf queues build up in the system, or if our simulation is not long enough for a high proportion of the patients who start their journeys to actually make their whole journey through, we may find that some patients in our list haven’t finished their journey before they exit and this may make figures for later parts of the patient journey look a bit strange. Let’s rerun this after filtering to only include patients who finished their full journey and exited the system.\n\n(\n    patient_level_results[patient_level_results[\"Completed Journey\"] == True].reset_index()\n    .groupby('Patient Severity')\n    .agg({\n        'Patient ID': 'count',\n        'Time with Recep': 'mean',\n        'Time with Nurse': 'mean',\n        'Sees Doctor': 'mean',\n        'Time with Doctor': 'mean'\n    })\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\nPatient ID\nTime with Recep\nTime with Nurse\nSees Doctor\nTime with Doctor\n\n\nPatient Severity\n\n\n\n\n\n\n\n\n\nhigh\n13\n1.56\n3.64\n1.0\n44.79\n\n\nlow\n37\n1.81\n5.74\n0.243243\n7.11\n\n\nmedium\n17\n1.74\n10.92\n0.352941\n22.56\n\n\n\n\n\n\n\n\n\n14.4.1 Exploring this with graphs\nWe can also take a look at all of these figures in a more visual way.\nTo start with, we need to alter the structure of our dataframe slightly.\n\nimport plotly.express as px\n\ntimes_df = (\n    patient_level_results[['Patient Severity','Time with Recep', 'Time with Nurse', 'Time with Doctor']]\n    .reset_index()\n    )\n\ntimes_df_long = times_df.melt(\n    id_vars=[\"Patient ID\", \"Patient Severity\"]\n    )\n\ntimes_df_long.head(10)\n\n\n\n\n\n\n\n\n\nPatient ID\nPatient Severity\nvariable\nvalue\n\n\n\n\n0\n1\nhigh\nTime with Recep\n3.973340\n\n\n1\n2\nmedium\nTime with Recep\n1.500383\n\n\n2\n3\nlow\nTime with Recep\n2.602708\n\n\n3\n4\nmedium\nTime with Recep\n1.058856\n\n\n4\n5\nhigh\nTime with Recep\n0.060305\n\n\n5\n6\nmedium\nTime with Recep\n0.867850\n\n\n6\n7\nhigh\nTime with Recep\n1.284329\n\n\n7\n8\nlow\nTime with Recep\n0.230440\n\n\n8\n9\nlow\nTime with Recep\n0.115646\n\n\n9\n10\nhigh\nTime with Recep\n2.001424\n\n\n\n\n\n\n\n\nNow we can display this as a box plot.\n\npx.box(\n    times_df_long,\n    y=\"variable\",\n    x=\"value\",\n    color=\"Patient Severity\"\n)\n\n                                                \n\n\nLet’s look at this a different way.\n\n(\n    px.box(\n    times_df_long,\n    y=\"variable\",\n    x=\"value\",\n    facet_row=\"Patient Severity\")\n    .update_yaxes(title_text=\"\")\n    .for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1], y=1.05))\n)",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#adding-in-the-trial",
    "href": "multiple_entity_types.html#adding-in-the-trial",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "14.5 Adding in the trial",
    "text": "14.5 Adding in the trial\nFinally, now we’re happy thaat this is working at the level of a single run, let’s see what changes we need to make to our trial class.\nBelow is the trial class in its existing form.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ## NEW\n        print(\"\") ## NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nLet’s see what happens when we run this now.\n\n# Create an i#| nstance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              131.0               3.78             140.14                0.79\n1              150.0               2.20             115.32               36.08\n2              162.0               2.40             159.47                0.00\n3              143.0               2.13             146.57                2.11\n4              145.0               2.10             124.95               22.42\nArrivals              146.20\nMean Q Time Recep       2.52\nMean Q Time Nurse     137.29\nMean Q Time Doctor     12.28\ndtype: float64\n\n\nThis is working fine if we just want to get an overall sense of the queues at each step in our model, regardless of our severity.\nHowever, it doesn’t give us much insight into our different patient groups over the course of multiple runs.\nTo change this, we could go back through our model class and ensure we start recording\nHowever, this is time-consuming and can be inefficient if we later want to add additional steps or metrics to our model.\nInstead, for each run, we will output the\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    def  __init__(self):\n        self.patient_dataframes = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ## NEW\n        print(\"\") ## NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run_number=run)\n            patient_level_results = my_model.run()\n            patient_level_results.insert(\n                loc=0,\n                column=\"Run\",\n                value=run+1\n                )\n\n            self.patient_dataframes.append(patient_level_results)\n\n        # Once the trial (ie all runs) has completed, turn this into a single dataframe\n        # and return it\n        return pd.concat(self.patient_dataframes)\n\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nall_results = my_trial.run_trial()\n\nall_results.head(10).round(2)\n\n1 receptionists, 1 nurses, 2 doctors\n\n\n\n\n\n\n\n\n\n\n\nRun\nPatient Severity\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n1\nhigh\n0.00\n1.36\n0.00\n3.40\nTrue\n0.00\n30.60\nTrue\n\n\n2\n1\nmedium\n1.36\n2.04\n1.36\n6.80\nTrue\n0.00\n13.60\nTrue\n\n\n3\n1\nlow\n3.40\n0.04\n8.12\n5.44\nTrue\n8.16\n6.80\nTrue\n\n\n4\n1\nlow\n0.04\n0.00\n13.56\n8.16\nTrue\n6.80\n10.20\nTrue\n\n\n5\n1\nlow\n0.00\n1.10\n15.56\n0.16\nFalse\nNaN\nNaN\nTrue\n\n\n6\n1\nlow\n1.00\n3.26\n12.46\n0.02\nFalse\nNaN\nNaN\nTrue\n\n\n7\n1\nlow\n4.25\n1.35\n11.13\n4.40\nFalse\nNaN\nNaN\nTrue\n\n\n8\n1\nmedium\n4.01\n1.51\n14.02\n10.20\nFalse\nNaN\nNaN\nTrue\n\n\n9\n1\nlow\n4.36\n5.63\n18.58\n13.04\nFalse\nNaN\nNaN\nTrue\n\n\n10\n1\nhigh\n4.35\n12.12\n19.50\n5.10\nTrue\n0.00\n45.88\nTrue\n\n\n\n\n\n\n\n\n\nall_results.tail(10).round(2)\n\n\n\n\n\n\n\n\n\nRun\nPatient Severity\nQ Time Recep\nTime with Recep\nQ Time Nurse\nTime with Nurse\nSees Doctor\nQ Time Doctor\nTime with Doctor\nCompleted Journey\n\n\nPatient ID\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n136\n5\nhigh\n2.78\n1.78\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n137\n5\nhigh\n3.40\n2.39\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n138\n5\nlow\n1.85\n6.96\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n139\n5\nlow\n0.00\n3.83\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n140\n5\nhigh\n2.69\n3.82\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n141\n5\nmedium\n0.00\n1.28\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n142\n5\nlow\n0.00\n6.77\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n143\n5\nhigh\n4.79\n2.01\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n144\n5\nhigh\n6.53\n2.39\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n145\n5\nlow\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\n\nNow we can write simple code to recreate the output we were getting from our trial class previously, as well as allowing us to return more detailed outputs.\n\n\n\n\n\n\nTip\n\n\n\nWe could turn these into functions as well to make it clearer what each does and make them easier to reuse and adapt.\n\n\n\n14.5.1 Return Trial-level results\n\n(\n    all_results[['Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .mean()\n    .round(2)\n)\n\nQ Time Recep       2.50\nQ Time Nurse     135.72\nQ Time Doctor     13.55\ndtype: float64\n\n\n\n14.5.1.1 Segment This by Severity\n\n(\n    all_results[['Patient Severity', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Patient Severity')\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nPatient Severity\n\n\n\n\n\n\n\nhigh\n2.55\n131.94\n13.43\n\n\nlow\n2.39\n144.71\n16.18\n\n\nmedium\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\n\n\n\n14.5.2 Return Run-level results\n\n(\n    all_results[['Run', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Run')\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nRun\n\n\n\n\n\n\n\n1\n3.78\n140.14\n0.79\n\n\n2\n2.20\n115.32\n36.08\n\n\n3\n2.40\n159.47\n0.00\n\n\n4\n2.13\n146.57\n2.11\n\n\n5\n2.10\n124.95\n22.42\n\n\n\n\n\n\n\n\n\n14.5.2.1 Segment This by Severity\n\n(\n    all_results[['Run', 'Patient Severity', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby(['Run','Patient Severity'])\n    .mean()\n    .round(2)\n)\n\n\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nRun\nPatient Severity\n\n\n\n\n\n\n\n1\nhigh\n4.97\n115.24\n0.00\n\n\nlow\n3.46\n169.08\n2.49\n\n\nmedium\n4.25\n67.08\n0.00\n\n\n2\nhigh\n2.15\n105.01\n32.65\n\n\nlow\n2.20\n125.79\n44.51\n\n\nmedium\n2.24\n101.25\n32.12\n\n\n3\nhigh\n2.48\n171.34\n0.00\n\n\nlow\n2.29\n168.74\n0.00\n\n\nmedium\n2.68\n131.08\n0.00\n\n\n4\nhigh\n1.59\n145.66\n2.76\n\n\nlow\n2.03\n145.09\n1.89\n\n\nmedium\n2.90\n152.08\n1.39\n\n\n5\nhigh\n2.66\n155.01\n16.82\n\n\nlow\n2.00\n121.21\n20.51\n\n\nmedium\n1.94\n110.25\n29.92",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "multiple_entity_types.html#display-trial-results-visually",
    "href": "multiple_entity_types.html#display-trial-results-visually",
    "title": "14  Multiple Entity Types Following The Same (or Very Similar) Pathways",
    "section": "14.6 Display Trial Results Visually",
    "text": "14.6 Display Trial Results Visually\n\n14.6.1 Bar Chart Summary\n\nresults_df = (\n    all_results[['Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .mean()\n    .round(2)\n    .reset_index()\n    )\n\nresults_df.columns = ['Metric', 'Value']\n\nresults_df\n\n\n\n\n\n\n\n\n\nMetric\nValue\n\n\n\n\n0\nQ Time Recep\n2.50\n\n\n1\nQ Time Nurse\n135.72\n\n\n2\nQ Time Doctor\n13.55\n\n\n\n\n\n\n\n\n\npx.bar(\n    results_df,\n    y=\"Metric\",\n    x=\"Value\",\n    orientation='h'\n    )\n\n                                                \n\n\nWe can see that while the queue times for the receptionist and the doctor are relatively short, the queue time for the nurse resource is very long, suggesting that the nurse is the bottleneck in our current simulated environment.\n\n\n14.6.2 Bar Chart Summary - by Severity\n\nresults_df = (\n    all_results[['Patient Severity', 'Q Time Recep', 'Q Time Nurse', 'Q Time Doctor']]\n    .groupby('Patient Severity')\n    .mean()\n    .round(2)\n)\n\nresults_df\n\n\n\n\n\n\n\n\n\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\nPatient Severity\n\n\n\n\n\n\n\nhigh\n2.55\n131.94\n13.43\n\n\nlow\n2.39\n144.71\n16.18\n\n\nmedium\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\n\nresults_df = results_df.reset_index()\n\nresults_df\n\n\n\n\n\n\n\n\n\nPatient Severity\nQ Time Recep\nQ Time Nurse\nQ Time Doctor\n\n\n\n\n0\nhigh\n2.55\n131.94\n13.43\n\n\n1\nlow\n2.39\n144.71\n16.18\n\n\n2\nmedium\n2.77\n112.46\n11.27\n\n\n\n\n\n\n\n\n\nresults_df_long = results_df.melt(id_vars=\"Patient Severity\")\n\nresults_df_long\n\n\n\n\n\n\n\n\n\nPatient Severity\nvariable\nvalue\n\n\n\n\n0\nhigh\nQ Time Recep\n2.55\n\n\n1\nlow\nQ Time Recep\n2.39\n\n\n2\nmedium\nQ Time Recep\n2.77\n\n\n3\nhigh\nQ Time Nurse\n131.94\n\n\n4\nlow\nQ Time Nurse\n144.71\n\n\n5\nmedium\nQ Time Nurse\n112.46\n\n\n6\nhigh\nQ Time Doctor\n13.43\n\n\n7\nlow\nQ Time Doctor\n16.18\n\n\n8\nmedium\nQ Time Doctor\n11.27\n\n\n\n\n\n\n\n\n\npx.bar(\n    results_df_long,\n    y=\"variable\",\n    x=\"value\",\n    color=\"Patient Severity\",\n    orientation='h',\n    barmode=\"group\"\n)\n\n                                                \n\n\nWe can see that the queue times for each group across the trial are similar - which makes sense because we haven’t introduced any sort of priority for the patients of different severity.\nIf we were to introduce priority, this graph would make it easy to determine if that was working as expected.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Multiple Entity Types Following The Same (or Very Similar) Pathways</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html",
    "href": "basic_debugging_tactics.html",
    "title": "19  (Coming Soon!) Basic Debugging Tactics",
    "section": "",
    "text": "19.1 Using print() statements\nAdding print() statements to your models at",
    "crumbs": [
      "Part 4 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>(Coming Soon!) Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#using-the-logging-module",
    "href": "basic_debugging_tactics.html#using-the-logging-module",
    "title": "19  (Coming Soon!) Basic Debugging Tactics",
    "section": "19.2 Using the logging module",
    "text": "19.2 Using the logging module\nThe logging module is a step up from the use of print() statements.",
    "crumbs": [
      "Part 4 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>(Coming Soon!) Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "basic_debugging_tactics.html#event-logging",
    "href": "basic_debugging_tactics.html#event-logging",
    "title": "19  (Coming Soon!) Basic Debugging Tactics",
    "section": "19.3 Event Logging",
    "text": "19.3 Event Logging\nBuilding up our own event logs give us a very clear picture of what is happening to every entity throughout our model.\nThey are a valuable debugging technique, and by structuring them correctly, we can start to build up a bank of code that can be used to debug very different models with no or minimal changes to our code that processes the event logs. They can also then be used for building animated visuals of the flow of entities through our model.\nAs this is a more involved approach, it has been placed in its own chapter here.",
    "crumbs": [
      "Part 4 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>(Coming Soon!) Basic Debugging Tactics</span>"
    ]
  },
  {
    "objectID": "event_logging.html",
    "href": "event_logging.html",
    "title": "20  (Coming Soon!) Event Logging",
    "section": "",
    "text": "Coming soon!",
    "crumbs": [
      "Part 4 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>(Coming Soon!) Event Logging</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html",
    "href": "appointment_style_booking_models.html",
    "title": "27  Dealing With Appointment Bookings",
    "section": "",
    "text": "27.1 The appointment book\nThe key difference in this model is that we will feed in an additional object that represents the capacity of the clinic to see new clients.\nTo begin with, let’s assume that\npd.read_csv(\"resources/shifts_simplest.csv\")\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n5\n8\n\n\n6\n0\nHere, we have one row per day of the week. We will interpret an index of 0 as Monday and 6 as Sunday.",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#the-appointment-book",
    "href": "appointment_style_booking_models.html#the-appointment-book",
    "title": "27  Dealing With Appointment Bookings",
    "section": "",
    "text": "there is a single clinic\nany client can be seen by any clinician\nthey are open six days a week\nall appointments are the same length\nclients do not express any preference about being seen at a particular time of day\neveryone attends their appointment",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#coding-the-example",
    "href": "appointment_style_booking_models.html#coding-the-example",
    "title": "27  Dealing With Appointment Bookings",
    "section": "27.2 Coding the example",
    "text": "27.2 Coding the example\n\n27.2.1 The g class\nRather than setting an interarrival time, we will instead set a value that represents the average annual demand for our clinic.\nWe will also pass in the dataframe of shifts.\nAnother new parameter is the minimum wait. To give patients time to receive their appointment letter and make a plan to attend, we don’t want to just book the next available appointment, as this could be the very next day, with no time for clients to find out they are meant to be attending!\nIn the final new parameter, we will\nNext, we return to parameters we have used before - the sim duration, which we have this time set as two years (365 days times 2). Note that compared to our previous model, where we interpreted each simpy time unit as 1 minute, we are now interpreting a single time unit as one day. We do not change anything in simpy itself to do this - but we just need to be careful that we remain consistent in our application of this throughout the rest of the model.\n\nshifts_df = pd.read_csv(\"resources/shifts_simplest.csv\")\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    annual_demand = 3500\n    shifts = shifts_df\n\n    min_wait = 7\n\n    sim_duration = 365 * 2\n    number_of_runs = 100\n\n\n\n27.2.2 The Patient (entity) class\nIn our patient class, we will record an id as before.\nWe have a new attribute named ‘booker’ that we will create shortly.\nWe will also create a space to record the time patients arrive into the model, and the time they have their appointment.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, booker):\n        self.id = p_id\n        self.booker = booker\n\n        self.arrival_time = 0\n        self.waiting_time = 0\n\n\n\n27.2.3 The model class\n\n27.2.3.1 The __init__method\nWe now need to make some important changes to the __init__method of the model, as well as create a few extra methods we can call on.\nOne of the key things we need to do is create two new dataframes based on our shift data (the dataframe of available daily slots). We have only provided the required information for a single week - our model will need to\n\nextrapolate this out into an array that covers the whole model (with a bit extra for appointments that are booked while the model is running, but are booked in for after the model has finished running)\ncreate a second array with the same dimensions that will be used to track the number of patients that have been booked in on a given day, allowing us to calculate if there are any slots still available when\n\n\n\n\n\n\n\nTip\n\n\n\nNote that we are using numpy throughout for the operations relating to the bookings. This is just due to the speed advantage of numpy in this context.\n\n\nWhen setting up our model class, we also want to create a distribution object that can be used to sample the number of daily arrivals to our system, based on the average number of yearly arrivals passed in our g class.\nFor more information on these functions, refer to #sec-reproducibility and #sec-distributions.\nWe will be using the Poisson class from the sim-tools package, so first need to run the following line.\n\nfrom sim_tools.distributions import Poisson\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ## NEW\n        self.available_slots = None\n        self.bookings = None\n\n        ## NEW - run the new methods we have created below\n        self.create_slots() ##NEW\n        self.create_bookings() ##NEW\n\n        ## NEW\n1        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n2                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0 ## NEW\n        self.mean_yearly_arrivals = 0 ## NEW\n\n    ########################################\n    ## ---------- NEW ------------------- ##\n    ########################################\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    ########################################\n    ## ---------- END NEW --------------- ##\n    ########################################\n\n\n1\n\nThe parameter we pass to the poisson distribution is the average number of daily arrivals; this will be the average number of yearly arrivals divided by the number of weeks in a year and the number of days in a week.\n\n2\n\nThis will ensure we have a different random pattern of arrivals per run, but that the number of arrivals is reproducible across trials.\n\n\n\n\nLet’s look at the outputs from this.\n\nmodel = Model(run_number=1)\n\nmodel.create_slots()\nmodel.available_slots\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n...\n...\n\n\n2186\n8\n\n\n2187\n10\n\n\n2188\n12\n\n\n2189\n8\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\nmodel.create_bookings()\nmodel.bookings\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n2\n0\n\n\n3\n0\n\n\n4\n0\n\n\n...\n...\n\n\n2186\n0\n\n\n2187\n0\n\n\n2188\n0\n\n\n2189\n0\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\n\n\n27.2.4 The booker class\nBefore we continue making changes to our model class, we want to introduce a new class that will deal with patient bookings.\n\n\n\n\n\n\nTip\n\n\n\nWhile at this stage these methods could easily be incorporated elsewhere - such as into the model class itself - separating it out into its own class will give us more flexibility in the future when we wish to add in features such as pooling of clinic resources or different booking protocols for high and low priority patients.\nIn this case, this is also the motivation for adding in a ‘clinic ID’ parameter that is passed in when making the booking. While we only have a single clinic in this version of the model, allowing for a situation where we have multiple clinics a client could attend, and can make a choice to send them to whichever of these potential clinics have the earliest available appointment.\n\n\n\nclass Booker():\n    '''\n    Booking class.\n    '''\n    def __init__(self, model):\n        self.priority = 1\n        self.model = model\n\n    def find_slot(self, t, clinic_id):\n        '''\n        Finds a slot in a diary of available slot\n\n        Params:\n        ------\n        t: int,\n            current simulation time in days\n            required to prevent booking an appointment\n            in the past\n\n        clinic_id: int,\n            index of clinic to look up slots for\n\n        Returns:\n        -------\n        (int, int)\n        (booking_t, best_clinic_idx)\n\n        '''\n        # to reduce runtime - drop down to numpy\n        available_slots_np = self.model.available_slots.to_numpy()\n\n        # get the clinic slots t + min_wait forward\n        clinic_slots = available_slots_np[t + g.min_wait: , clinic_id]\n\n        # get the earliest day number (its the name of the series)\n        best_t = np.where((clinic_slots.reshape(len(clinic_slots),1).sum(axis=1) &gt; 0))[0][0]\n\n        # Note that to get the index (day) of the actual booking, we\n        # need to add the simulation time (t) and the minimum wait to the\n        # index of the best time we found\n        booking_t = t + g.min_wait + best_t\n\n        return booking_t, clinic_id\n\n\n    def book_slot(self, booking_t, clinic_id):\n        '''\n        Book a slot on day t for clinic c\n\n        A slot is removed from args.available_slots\n        A appointment is recorded in args.bookings.iat\n\n        Params:\n        ------\n        booking_t: int\n            Day of booking\n\n        clinic_id: int\n            the clinic identifier\n        '''\n\n        # Reduce the number of available slots by one at the point of the booking\n        self.model.available_slots.iat[booking_t, clinic_id] -= 1\n\n        # Increase the number of bookings we have on that day\n        self.model.bookings.iat[booking_t, clinic_id] += 1\n\nLet’s take a look at the output of these.\n\nsample_booker = Booker(model)\n\nbooking_t, clinic_id = sample_booker.find_slot(t=10, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nBooking t: 17\nClinic Index: 0\n\n\n\nbooking_t, clinic_id = sample_booker.find_slot(t=320, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nBooking t: 327\nClinic Index: 0\n\n\n\nbooking_t, clinic_id = sample_booker.find_slot(t=0, clinic_id=0)\nprint(f\"Booking t: {booking_t}\")\nprint(f\"Clinic Index: {clinic_id}\")\n\nsample_booker.book_slot(booking_t=booking_t, clinic_id=clinic_id)\n\nmodel.available_slots\n\nBooking t: 7\nClinic Index: 0\n\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n12\n\n\n1\n15\n\n\n2\n8\n\n\n3\n10\n\n\n4\n12\n\n\n...\n...\n\n\n2186\n8\n\n\n2187\n10\n\n\n2188\n12\n\n\n2189\n8\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\nmodel.bookings\n\n\n\n\n\n\n\n\n\nclinic_1\n\n\nday\n\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n2\n0\n\n\n3\n0\n\n\n4\n0\n\n\n...\n...\n\n\n2186\n0\n\n\n2187\n0\n\n\n2188\n0\n\n\n2189\n0\n\n\n2190\n0\n\n\n\n\n2191 rows × 1 columns\n\n\n\n\n\n\n27.2.5 Further changes to the Model class\nNow we have our booker method, we can make the remaining changes required to the model class.\n\n27.2.5.1 The generator_patient_arrivals method\nThis method changes quite significantly from our existing models.\nInstead of generating a patient, calculating the length of time that elapses until the next patient arrives and then waiting for that time to elapse, we mode through the simulation one day at a time, performing the following steps:\n\ncalculating (sampling) the number of arrivals per day\nlooping through each referral and creating a new patient object\ncreating an instance of the booker class for each patient\nstarting a referral process for that patient\n\nWhen this is complete for every patient who is generated for that day, we can step forward to the next day by waiting for one time unit to elapse.\n\ndef generator_patient_arrivals(self):\n    for t in itertools.count():\n\n        #total number of referrals today\n        n_referrals = self.arrival_dist.sample()\n\n        #loop through all referrals recieved that day\n        for i in range(n_referrals):\n            self.patient_counter += 1\n\n            booker = Booker(model=self)\n\n            # Create instance of Patient\n            p = Patient(p_id=self.patient_counter, booker=booker)\n\n            # Start a referral assessment process for patient.\n            self.env.process(self.attend_clinic(p))\n\n        #timestep by one day\n        yield self.env.timeout(1)\n\n\n\n27.2.5.2 The attend_clinic method\nThis method also needs to change quite significantly.\n\ndef attend_clinic(self, patient):\n    patient.arrival_time = self.env.now\n\n    best_t, clinic_id = (\n            patient.booker.find_slot(\n1              t = patient.arrival_time,\n2              clinic_id = 0\n              )\n    )\n\n    #book slot at clinic = time of referral + waiting_time\n    #\n    patient.booker.book_slot(best_t, clinic_id)\n\n    # Wait for the time until the appointment to elapse\n    yield self.env.timeout(best_t - patient.arrival_time)\n\n    patient.waiting_time = self.env.now - patient.arrival_time\n\n    self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n               patient.waiting_time\n               )\n\n\n1\n\nThe arrival time of the patient is passed in so that only appointments in the future are considered as eligible slots.\n\n2\n\nIn this example we are only looking at a single clinic. In later versions of this model, patients who arrive will also have a preferred ‘home’ clinic, which will mean that different clinic IDs can be passed in at this stage.\n\n\n\n\n\n\n27.2.5.3 The calculate_run_results method\nHere, we are just altering the column name we refer to when calculating our metric of interest.\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for an appointment across this run of the model\n        self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n        # use our patient counter to track how many patients turn up on average during each\n        # year of the simulation.\n        self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n\n\n\n27.2.5.4 The run method\nThe run method is unchanged.\n\n\n\n27.2.6 The trial class\nOur trial class is fundamentally unchanged - the main differences relate to the changes to the metrics we are interested in tracking.\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment] ##NEW\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals] ##NEW\n\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n27.2.7 The full code\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nfrom sim_tools.distributions import Poisson\nimport pandas as pd\nimport numpy as np\nimport simpy\nimport itertools\n\nshifts_df = pd.read_csv(\"resources/shifts_simplest.csv\")\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    annual_demand = 3500\n    shifts = shifts_df\n\n    min_wait = 7\n\n    sim_duration = 365 * 2\n    number_of_runs = 10\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id, booker):\n        self.id = p_id\n        self.booker = booker\n\n        self.arrival_time = 0\n        self.waiting_time = 0\n\nclass Booker():\n    '''\n    Booking class.\n    '''\n    def __init__(self, model):\n        self.priority = 1\n        self.model = model\n\n    def find_slot(self, t, clinic_id):\n        '''\n        Finds a slot in a diary of available slot\n\n        Params:\n        ------\n        t: int,\n            current simulation time in days\n            required to prevent booking an appointment\n            in the past\n\n        clinic_id: int,\n            index of clinic to look up slots for\n\n        Returns:\n        -------\n        (int, int)\n        (booking_t, best_clinic_idx)\n\n        '''\n        # to reduce runtime - drop down to numpy\n        available_slots_np = self.model.available_slots.to_numpy()\n\n        # get the clinic slots t + min_wait forward\n        clinic_slots = available_slots_np[t + g.min_wait: , clinic_id]\n\n        # get the earliest day number (its the name of the series)\n        best_t = np.where((clinic_slots.reshape(len(clinic_slots),1).sum(axis=1) &gt; 0))[0][0]\n\n        # Note that to get the index (day) of the actual booking, we\n        # need to add the simulation time (t) and the minimum wait to the\n        # index of the best time we found\n        booking_t = t + g.min_wait + best_t\n\n        return booking_t, clinic_id\n\n\n    def book_slot(self, booking_t, clinic_id):\n        '''\n        Book a slot on day t for clinic c\n\n        A slot is removed from args.available_slots\n        A appointment is recorded in args.bookings.iat\n\n        Params:\n        ------\n        booking_t: int\n            Day of booking\n\n        clinic_id: int\n            the clinic identifier\n        '''\n\n        # Reduce the number of available slots by one at the point of the booking\n        self.model.available_slots.iat[booking_t, clinic_id] -= 1\n\n        # Increase the number of bookings we have on that day\n        self.model.bookings.iat[booking_t, clinic_id] += 1\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        ## NEW\n        self.available_slots = None\n        self.bookings = None\n\n        ## Populate these two items\n        self.create_slots() ##NEW\n        self.create_bookings() ##NEW\n\n\n        ## NEW\n        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0 ## NEW\n        self.mean_yearly_arrivals = 0 ## NEW\n\n    ########################################\n    ## ---------- NEW ------------------- ##\n    ########################################\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    def generator_patient_arrivals(self):\n        for t in itertools.count():\n\n            #total number of referrals today\n            n_referrals = self.arrival_dist.sample()\n\n            #loop through all referrals recieved that day\n            for i in range(n_referrals):\n                self.patient_counter += 1\n\n                booker = Booker(model=self)\n\n                # Create instance of Patient\n                p = Patient(p_id=self.patient_counter, booker=booker)\n\n                # Start a referral assessment process for patient.\n                self.env.process(self.attend_clinic(p))\n\n            #timestep by one day\n            yield self.env.timeout(1)\n\n    def attend_clinic(self, patient):\n        patient.arrival_time = self.env.now\n\n        best_t, clinic_id = (\n                patient.booker.find_slot(\n                  t = patient.arrival_time,\n                  clinic_id = 0\n                  )\n        )\n\n        #book slot at clinic = time of referral + waiting_time\n        patient.booker.book_slot(best_t, clinic_id)\n\n        # Wait for the time until the appointment to elapse\n        yield self.env.timeout(best_t - patient.arrival_time)\n\n        patient.waiting_time = self.env.now - patient.arrival_time\n\n        self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n                  patient.waiting_time\n                  )\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n        self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # Commented out for now\n        #print (f\"Run Number {self.run_number}\")\n        #print (self.results_df)\n\n    ########################################\n    ## ---------- END NEW --------------- ##\n    ########################################\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment] ##NEW\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n\n27.2.8 Evaluating the results\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Appointment Wait (Days)  Average Yearly Arrivals\nRun Number                                                       \n0                              17.009395                   3470.0\n1                              18.042281                   3488.0\n2                              25.047924                   3549.5\n3                              14.848336                   3435.0\n4                              27.680286                   3594.5\n5                              19.943840                   3547.5\n6                              29.153250                   3577.5\n7                              25.724776                   3603.5\n8                              22.593023                   3553.0\n9                              19.984317                   3504.0",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#tracking-additional-metrics",
    "href": "appointment_style_booking_models.html#tracking-additional-metrics",
    "title": "27  Dealing With Appointment Bookings",
    "section": "27.3 Tracking additional metrics",
    "text": "27.3 Tracking additional metrics\nWe may find it useful to understand how many of our available appointment slots are going unused in the simulation.\nTo do this, we can slice our available_slots and bookings objects to just include the period of interest.\nRemember that available_slots refers to the number of remaining slots after bookings have been made - not the total available theoretical slots per day, which is stored in our g class as shifts - but remember that the shifts object is only a template for a seven day period rather than encompassing the whole model duration.\nTherefore, to get the total number of possible slots, we must do available_slots + bookings.\nThis will add up the relevant values on a day-by-day basis.\nWe can then sum available_slots to get the total number of slots that weren’t utilised, and then sum the result of available_slots + bookings to get the total number of slots that were available. By dividing the first result by the second, we get an indication of what proportion of slots were actually used.\n\n\n\n\n\n\nNote\n\n\n\nChanges to the code are marked with ##NEW below\n\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        self.available_slots = None\n        self.bookings = None\n\n        ## Populate these two items\n        self.create_slots()\n        self.create_bookings()\n\n        self.arrival_dist = Poisson(g.annual_demand / 52 / 7,\n                                    random_seed=run_number*42)\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Appointment\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean waiting time for an appointment\n        # across this run of the model\n        self.mean_wait_time_appointment = 0\n        self.mean_yearly_arrivals = 0\n        self.percentage_slots_used = 0.0 ##NEW\n\n    def create_slots(self):\n\n        available_slots = g.shifts.astype(np.uint8)\n        template = available_slots.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            available_slots = pd.concat([available_slots, template.copy()],\n                                         ignore_index=True)\n\n        available_slots.index.rename('day', inplace=True)\n        self.available_slots = available_slots\n\n    def create_bookings(self):\n        bookings = np.zeros(shape=(len(g.shifts), len(g.shifts.columns)), dtype=np.uint8)\n\n        columns = [f'clinic_{i}' for i in range(1, len(g.shifts.columns)+1)]\n        bookings_template = pd.DataFrame(bookings, columns=columns)\n\n        bookings = bookings_template.copy()\n\n        #longer than run length as patients will need to book ahead\n        for day in range(int((g.sim_duration/len(g.shifts))*3)):\n            bookings = pd.concat([bookings, bookings_template.copy()],\n                                 ignore_index=True)\n\n        bookings.index.rename('day', inplace=True)\n        self.bookings = bookings\n\n    def generator_patient_arrivals(self):\n        for t in itertools.count():\n\n            #total number of referrals today\n            n_referrals = self.arrival_dist.sample()\n\n            #loop through all referrals recieved that day\n            for i in range(n_referrals):\n                self.patient_counter += 1\n\n                booker = Booker(model=self)\n\n                # Create instance of Patient\n                p = Patient(p_id=self.patient_counter, booker=booker)\n\n                # Start a referral assessment process for patient.\n                self.env.process(self.attend_clinic(p))\n\n            #timestep by one day\n            yield self.env.timeout(1)\n\n    def attend_clinic(self, patient):\n        patient.arrival_time = self.env.now\n\n        best_t, clinic_id = (\n                patient.booker.find_slot(\n                  t = patient.arrival_time,\n                  clinic_id = 0\n                  )\n        )\n\n        #book slot at clinic = time of referral + waiting_time\n        patient.booker.book_slot(best_t, clinic_id)\n\n        # Wait for the time until the appointment to elapse\n        yield self.env.timeout(best_t - patient.arrival_time)\n\n        patient.waiting_time = self.env.now - patient.arrival_time\n\n        self.results_df.at[patient.id, \"Q Time Appointment\"] = (\n                  patient.waiting_time\n                  )\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_wait_time_appointment= self.results_df[\"Q Time Appointment\"].mean()\n        self.mean_yearly_arrivals = self.patient_counter / (g.sim_duration / 365)\n        #########\n        ## NEW ##\n        #########\n\n        slots_unused = self.available_slots.clinic_1.values[ : g.sim_duration]\n\n        slots_used = self.bookings.clinic_1.values[ : g.sim_duration]\n\n        total_slots_available_daily = np.add(slots_unused, slots_used)\n\n        self.percentage_slots_used = (sum(slots_used) / sum(total_slots_available_daily))\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # Commented out for now\n        #print (f\"Run Number {self.run_number}\")\n        #print (self.results_df)\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results[\"Percentage of Slots Used\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment]\n\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals]\n\n            self.df_trial_results.loc[run, \"Percentage of Slots Used\"] = [my_model.percentage_slots_used] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n27.3.1 Evaluating the Results\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Appointment Wait (Days)  Average Yearly Arrivals  \\\nRun Number                                                          \n0                              17.009395                   3470.0   \n1                              18.042281                   3488.0   \n2                              25.047924                   3549.5   \n3                              14.848336                   3435.0   \n4                              27.680286                   3594.5   \n5                              19.943840                   3547.5   \n6                              29.153250                   3577.5   \n7                              25.724776                   3603.5   \n8                              22.593023                   3553.0   \n9                              19.984317                   3504.0   \n\n            Percentage of Slots Used  \nRun Number                            \n0                           0.988065  \n1                           0.989686  \n2                           0.989981  \n3                           0.987034  \n4                           0.988065  \n5                           0.989097  \n6                           0.988360  \n7                           0.987181  \n8                           0.988360  \n9                           0.986445  \n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that in this example we have not made use of a warm-up period.\nIn the early phases of the model, we would expect the utilisation of available slots to be lower, as there will be no booked appointments at the beginning of the model, and the first people to be booked in will be booked in a week ahead due to the mandatory delay period. Therefore the utilisation is likely to be an underestimate.\nTo learn more about setting warm-up periods, refer to #sec-warmup",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models.html#evaluating-the-impact-of-changing-the-number-of-yearly-attendances",
    "href": "appointment_style_booking_models.html#evaluating-the-impact-of-changing-the-number-of-yearly-attendances",
    "title": "27  Dealing With Appointment Bookings",
    "section": "27.4 Evaluating the impact of changing the number of yearly attendances",
    "text": "27.4 Evaluating the impact of changing the number of yearly attendances\nTo make it possible to see the impact of changing the number of attendances, we will modify our run_trial method to return the final dataframe instead of printing it.\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Appointment Wait (Days)\"] = [0.0] ##NEW\n        self.df_trial_results[\"Average Yearly Arrivals\"] = [0.0] ##NEW\n        self.df_trial_results[\"Percentage of Slots Used\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Appointment Wait (Days)\"] = [my_model.mean_wait_time_appointment]\n\n            self.df_trial_results.loc[run, \"Average Yearly Arrivals\"] = [my_model.mean_yearly_arrivals]\n\n            self.df_trial_results.loc[run, \"Percentage of Slots Used\"] = [my_model.percentage_slots_used] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        return self.df_trial_results\n\nWe can then iterate through and store the results for a number of different average yearly demand.\n\nyearly_demand = [2500, 2750, 3000, 3250, 3500, 3750, 4000]\nresults_frames = []\n\n# We will also extend the duration of each run to 4 years\nsim_duration = 365 * 4\n\nfor demand in yearly_demand:\n    g.annual_demand = demand\n\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    results_df = my_trial.run_trial()\n\n    results_df['Demand'] = demand\n\n    results_frames.append(results_df)\n\nfinal_results_df = pd.concat(results_frames)\n\nWe can then visualise the results in bar charts.\nFirst, to make it easier to visualise multiple metrics at once, we will reshape our results dataframe from wide to long.\nThe original dataframe looks like this:\n\nfinal_results_df\n\n\n\n\n\n\n\n\n\nMean Appointment Wait (Days)\nAverage Yearly Arrivals\nPercentage of Slots Used\nDemand\n\n\nRun Number\n\n\n\n\n\n\n\n\n0\n7.267180\n2483.0\n0.726831\n2500\n\n\n1\n7.262172\n2478.0\n0.723295\n2500\n\n\n2\n7.260255\n2536.0\n0.739944\n2500\n\n\n3\n7.260905\n2469.0\n0.719464\n2500\n\n\n4\n7.297517\n2603.5\n0.759688\n2500\n\n\n...\n...\n...\n...\n...\n\n\n5\n64.057011\n4012.5\n0.989834\n4000\n\n\n6\n67.956994\n4087.0\n0.990128\n4000\n\n\n7\n62.453639\n4048.0\n0.989981\n4000\n\n\n8\n58.317168\n3910.5\n0.990423\n4000\n\n\n9\n55.426720\n3942.0\n0.989244\n4000\n\n\n\n\n70 rows × 4 columns\n\n\n\n\nAfter using the melt function of pandas, our dataframe now has one row per run.\n\nfinal_results_df_long = pd.melt(\n  final_results_df.reset_index(),\n  id_vars=[\"Demand\", \"Run Number\"]\n  )\n\nfinal_results_df_long\n\n\n\n\n\n\n\n\n\nDemand\nRun Number\nvariable\nvalue\n\n\n\n\n0\n2500\n0\nMean Appointment Wait (Days)\n7.267180\n\n\n1\n2500\n1\nMean Appointment Wait (Days)\n7.262172\n\n\n2\n2500\n2\nMean Appointment Wait (Days)\n7.260255\n\n\n3\n2500\n3\nMean Appointment Wait (Days)\n7.260905\n\n\n4\n2500\n4\nMean Appointment Wait (Days)\n7.297517\n\n\n...\n...\n...\n...\n...\n\n\n205\n4000\n5\nPercentage of Slots Used\n0.989834\n\n\n206\n4000\n6\nPercentage of Slots Used\n0.990128\n\n\n207\n4000\n7\nPercentage of Slots Used\n0.989981\n\n\n208\n4000\n8\nPercentage of Slots Used\n0.990423\n\n\n209\n4000\n9\nPercentage of Slots Used\n0.989244\n\n\n\n\n210 rows × 4 columns\n\n\n\n\nThis allows us to use the facet_rows argument in plotly express.\n\nimport plotly.express as px\n\nfig = px.box(\n  final_results_df_long,\n  x=\"Demand\",\n  y=\"value\",\n  facet_col=\"variable\",\n  facet_col_wrap=1,\n  height=1200\n)\n\nfig.update_yaxes(matches=None)\nfig.for_each_annotation(lambda a: a.update(text=a.text.split(\"=\")[-1]))\nfig.show()",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Dealing With Appointment Bookings</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html",
    "href": "appointment_style_booking_models_advanced.html",
    "title": "28  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "",
    "text": "28.1 Adding in priority and carve-out",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#adding-in-priority-and-carve-out",
    "href": "appointment_style_booking_models_advanced.html#adding-in-priority-and-carve-out",
    "title": "28  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#adding-multiple-clinics",
    "href": "appointment_style_booking_models_advanced.html#adding-multiple-clinics",
    "title": "28  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "28.2 Adding multiple clinics",
    "text": "28.2 Adding multiple clinics\n\n\n\n\n\n\nNote\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_advanced.html#pooling-of-clinics",
    "href": "appointment_style_booking_models_advanced.html#pooling-of-clinics",
    "title": "28  (Coming Soon!) Advanced Appointment Booking Model Features",
    "section": "28.3 Pooling of clinics",
    "text": "28.3 Pooling of clinics\n\n\n\n\n\n\nNote\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>(Coming Soon!) Advanced Appointment Booking Model Features</span>"
    ]
  },
  {
    "objectID": "appointment_style_booking_models_multistep.html",
    "href": "appointment_style_booking_models_multistep.html",
    "title": "29  (Coming Soon!) Multi-step Appointment Booking Models",
    "section": "",
    "text": "Note\n\n\n\nThis section is coming soon.",
    "crumbs": [
      "Part 5 - Advanced Concepts",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>(Coming Soon!) Multi-step Appointment Booking Models</span>"
    ]
  }
]