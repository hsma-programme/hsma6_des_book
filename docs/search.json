[
  {
    "objectID": "event_logging.html",
    "href": "event_logging.html",
    "title": "30  Event Logging",
    "section": "",
    "text": "30.1 A sample event log\nIn this chapter and beyond, we will be using the term ‘event logging’ to describe the process of generating a step-by-step log of what happens to each entity as they pass through our system. The resulting file will be an ‘event log’.\nBut why bother with event logging? In previous chapters, we have managed to record a range of useful metrics from our simulation, and used these to display the performance of our model with different sets of parameters. In the debugging chapters, we have explored how to track down issues in our simulation with a combination of print statements and the logging module. So what else is there left to do?\nEvent logging can be a way to tackle both of the above in a robust, efficient and reusable way - while also opening up the use of a wide range of reusable boilerplate code for visualising, animating and formally testing our simulation outputs.\nFirst, it may be helpful to see what an event log looks like.\nA sample log is displayed below:\nimport pandas as pd\nevent_log = pd.read_csv(\"resources/sample_event_log.csv\")\n\nevent_log\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\nLet’s break down the key components.",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#a-sample-event-log",
    "href": "event_logging.html#a-sample-event-log",
    "title": "30  Event Logging",
    "section": "",
    "text": "30.1.1 Mandatory Columns\nWe have several mandatory columns:\n\nentity_id\nevent_type\nevent\ntime\n\nentity_id: a unique identifider to allow us to follow a given entity through their journey\nevent_type: this column is used to distinguish between three key kinds of events:\n\narrival_departure: an entity first entering the system, or the entity leaving the system\nqueue: an entity beginning to queue for a resource\n\nthis can also be used to just generally record the movement of someone through points of a system that don’t necessarily have a traditional ‘queue’\n\nresource_use: this relates to anything where someone starts or ends their time with a resource in the system\n\nevent: this column further breaks down what is happening during each event type, such as what stage of the system people are waiting to interact with\ntime: this can be an absolute timestamp in the form of a datetime (e.g. 2027-01-01 23:01:47), or a relative timestamp in time units from the start of the simulation.\n\n\n30.1.2 Recommended Columns\nIn addition, the following columns are highly recommended to include:\nrun: this separates out results across multiple simulations, allowing for easy grouping of results by run\n\n\n30.1.3 Optional Columns\nThere are a few more recommended but optional columns:\n\nresource_id\npathway\n\nresource_id: While a traditional simpy resource does not have a concept of a resource ID, there are various ways we can tackle adding one into our system. Let’s assume we have 5 nurses - it’s very helpful to know which of these 5 nurses are in use at any given time for visualisation and auditing purposes. A discussion of approaches to this will be found in a later chapter (coming soon), or you can take a look at the populate_store function from vidigi for a discussion on one approach to this: click here",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#exploring-our-log",
    "href": "event_logging.html#exploring-our-log",
    "title": "30  Event Logging",
    "section": "30.2 Exploring our log",
    "text": "30.2 Exploring our log\nLet’s explore what we can find out even from this small sample of logs.\n\n30.2.1 Tracking the journey of a single entity/patient\nWe can easily filter down by entity ID to see how the journey of an individual looks\n\nevent_log[event_log[\"entity_id\"] == 1]\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n\n\n\n\n\nWe can see that this person arrived and was seen immediately.\n\n\n30.2.2 Calculating waits\nIn this event log, patients who wait for treatment (an event of ‘treatment_wait_begins’) will have the next event of ‘treatment_wait’. We’ll start by just pulling out those instances.\n\ntreatment_waits_df = event_log[event_log[\"event\"].isin([\"treatment_wait_begins\",\"treatment_begins\"])]\n\ntreatment_waits_df\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n\n\n\n\n\nNext, we’ll pivot these to a wide format.\n\ntreatment_waits_df_wide = treatment_waits_df.pivot(index=\"entity_id\", columns=\"event\", values=\"time\")\n\ntreatment_waits_df_wide = treatment_waits_df_wide[['treatment_wait_begins', 'treatment_begins']]\n\ntreatment_waits_df_wide\n\n\n\n\n\n\n\nevent\ntreatment_wait_begins\ntreatment_begins\n\n\nentity_id\n\n\n\n\n\n\n1\n0.000000\n0.000000\n\n\n2\n3.399660\n3.399660\n\n\n3\n8.497645\n8.497645\n\n\n4\n8.596678\n8.596678\n\n\n5\n8.608025\n40.317385\n\n\n6\n11.359739\n42.443230\n\n\n7\n19.509442\n48.809628\n\n\n8\n22.877356\n51.483457\n\n\n9\n26.653863\n77.447488\n\n\n10\n40.737793\n83.962251\n\n\n11\n71.026558\nNaN\n\n\n12\n87.458700\nNaN\n\n\n13\n87.465138\nNaN\n\n\n\n\n\n\n\nFinally, let’s work out the average wait for only those patients who were seen by someone before our simulation finished. We first need to calculate the difference between the two stamps, which in this simulation, represents a number of minutes\n\ntreatment_waits_df_wide[\"treatment_wait\"] = treatment_waits_df_wide[\"treatment_begins\"] - treatment_waits_df_wide[\"treatment_wait_begins\"]\n\ntreatment_waits_df_wide\n\n\n\n\n\n\n\nevent\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\nentity_id\n\n\n\n\n\n\n\n1\n0.000000\n0.000000\n0.000000\n\n\n2\n3.399660\n3.399660\n0.000000\n\n\n3\n8.497645\n8.497645\n0.000000\n\n\n4\n8.596678\n8.596678\n0.000000\n\n\n5\n8.608025\n40.317385\n31.709360\n\n\n6\n11.359739\n42.443230\n31.083491\n\n\n7\n19.509442\n48.809628\n29.300186\n\n\n8\n22.877356\n51.483457\n28.606101\n\n\n9\n26.653863\n77.447488\n50.793625\n\n\n10\n40.737793\n83.962251\n43.224458\n\n\n11\n71.026558\nNaN\nNaN\n\n\n12\n87.458700\nNaN\nNaN\n\n\n13\n87.465138\nNaN\nNaN\n\n\n\n\n\n\n\nNow we can calculate the mean of that column:\n\ntreatment_waits_df_wide[\"treatment_wait\"].mean()\n\n21.4717221\n\n\nOr the median:\n\ntreatment_waits_df_wide[\"treatment_wait\"].median()\n\n28.9531435\n\n\nOr the max and min waits:\n\ntreatment_waits_df_wide[\"treatment_wait\"].agg(['min', 'max'])\n\nmin     0.000000\nmax    50.793625\nName: treatment_wait, dtype: float64\n\n\nOr plot the distribution of waits:\n\nimport plotly.express as px\n\npx.histogram(treatment_waits_df_wide, x=\"treatment_wait\")\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nOr a boxplot:\n\npx.box(treatment_waits_df_wide, x=\"treatment_wait\")",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#exploring-a-bigger-event-log",
    "href": "event_logging.html#exploring-a-bigger-event-log",
    "title": "30  Event Logging",
    "section": "30.3 Exploring a bigger event log",
    "text": "30.3 Exploring a bigger event log\nThis would be a lot more powerful if we weren’t just working with a small sample of 50 rows of an event log. Let’s instead load in the full event log from this model, which runs for a lot longer and includes multiple runs. All our existing code can be reused.\n\nevent_log = pd.read_csv(\"resources/sample_event_log_10_day_10_run.csv\")\n\n# We'll limit this to the first 24 hours of our clinic\n\nevent_log = event_log[event_log[\"time\"] &lt;= 60 * 24]\n\nevent_log.sample(10)\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n30886\n256\nSimplest\nqueue\ntreatment_wait_begins\n1278.647345\nNaN\n3\n\n\n71032\n122\nSimplest\narrival_departure\ndepart\n1239.137428\nNaN\n7\n\n\n10754\n231\nSimplest\narrival_departure\narrival\n1092.928526\nNaN\n1\n\n\n40769\n88\nSimplest\narrival_departure\ndepart\n894.901140\nNaN\n4\n\n\n90306\n14\nSimplest\nresource_use\ntreatment_begins\n116.257681\n3.0\n9\n\n\n90511\n87\nSimplest\narrival_departure\narrival\n393.621037\nNaN\n9\n\n\n20436\n62\nSimplest\nresource_use_end\ntreatment_complete\n637.253485\n1.0\n2\n\n\n20078\n13\nSimplest\nresource_use\ntreatment_begins\n112.296632\n1.0\n2\n\n\n81021\n224\nSimplest\nqueue\ntreatment_wait_begins\n1278.663217\nNaN\n8\n\n\n40472\n102\nSimplest\narrival_departure\narrival\n490.844077\nNaN\n4\n\n\n\n\n\n\n\nLet’s recalculate our waits. In fact - let’s write a function that could be used to make a wait table for any pair of events!\nWe’ll also make sure it takes account of the ‘run’ column.\n\ndef generate_difference_df(event_log, event_1, event_2, output_col_name):\n  difference_df = event_log[event_log[\"event\"].isin([event_1,event_2])]\n\n  difference_df_wide = difference_df.pivot(index=[\"entity_id\", \"run\"], columns=\"event\", values=\"time\")\n\n  difference_df_wide = difference_df_wide[[event_1,event_2]]\n\n  difference_df_wide[output_col_name] = difference_df_wide[event_2] - difference_df_wide[event_1]\n\n  return difference_df_wide.reset_index()\n\nLet’s run this and view the first 20 rows.\n\ntreatment_wait_df = generate_difference_df(event_log=event_log, event_1=\"treatment_wait_begins\", event_2=\"treatment_begins\", output_col_name=\"treatment_wait\")\n\ntreatment_wait_df.head(20)\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\n\n\n0\n1\n0\n0.000000\n0.000000\n0.0\n\n\n1\n1\n1\n0.000000\n0.000000\n0.0\n\n\n2\n1\n2\n0.000000\n0.000000\n0.0\n\n\n3\n1\n3\n0.000000\n0.000000\n0.0\n\n\n4\n1\n4\n0.000000\n0.000000\n0.0\n\n\n5\n1\n5\n0.000000\n0.000000\n0.0\n\n\n6\n1\n6\n0.000000\n0.000000\n0.0\n\n\n7\n1\n7\n0.000000\n0.000000\n0.0\n\n\n8\n1\n8\n0.000000\n0.000000\n0.0\n\n\n9\n1\n9\n0.000000\n0.000000\n0.0\n\n\n10\n2\n0\n3.399660\n3.399660\n0.0\n\n\n11\n2\n1\n12.021043\n12.021043\n0.0\n\n\n12\n2\n2\n8.965271\n8.965271\n0.0\n\n\n13\n2\n3\n0.033294\n0.033294\n0.0\n\n\n14\n2\n4\n10.399752\n10.399752\n0.0\n\n\n15\n2\n5\n2.645552\n2.645552\n0.0\n\n\n16\n2\n6\n11.489413\n11.489413\n0.0\n\n\n17\n2\n7\n4.011208\n4.011208\n0.0\n\n\n18\n2\n8\n17.040648\n17.040648\n0.0\n\n\n19\n2\n9\n2.861402\n2.861402\n0.0\n\n\n\n\n\n\n\nHere, we never have a wait because these people are entering an empty system.\nLet’s instead look at a different patient.\n\ntreatment_wait_df[treatment_wait_df[\"entity_id\"] == 40]\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_wait_begins\ntreatment_begins\ntreatment_wait\n\n\n\n\n390\n40\n0\n225.946145\n374.475154\n148.529008\n\n\n391\n40\n1\n166.195041\n396.502222\n230.307181\n\n\n392\n40\n2\n229.388022\n384.693144\n155.305122\n\n\n393\n40\n3\n198.590107\n376.281301\n177.691195\n\n\n394\n40\n4\n209.135743\n370.569622\n161.433878\n\n\n395\n40\n5\n227.132040\n376.794591\n149.662551\n\n\n396\n40\n6\n173.002070\n383.515632\n210.513562\n\n\n397\n40\n7\n223.578745\n378.418622\n154.839878\n\n\n398\n40\n8\n228.714086\n385.852087\n157.138001\n\n\n399\n40\n9\n176.753615\n370.958861\n194.205245\n\n\n\n\n\n\n\nLet’s sample a range of other quick visualisations we can make.\n\n30.3.1 Cumulative arrivals\nLet’s first just take a look at the arrivals for a single run, with each dot representing a single person arriving in our system.\n\npx.scatter(\n  event_log[\n    (event_log[\"run\"]==1) &\n    (event_log[\"event\"]==\"arrival\")],\n    x=\"time\",\n    y=\"entity_id\"\n    )\n\n                            \n                                            \n\n\nHere, we can see how cumulative arrivals varied by run.\n\npx.line(\n  event_log[event_log[\"event\"]==\"arrival\"],\n  x=\"time\",\n  y=\"entity_id\",\n  color=\"run\"\n  )\n\n                            \n                                            \n\n\n\n\n30.3.2 Event scatterplot\n\npx.scatter(\n  event_log[event_log[\"run\"]==1],\n  y=\"time\",\n  color=\"event\",\n  x=\"entity_id\"\n  )\n\n                            \n                                            \n\n\nWe can tell that the treatment wait very quickly gets out of hand for our individuals as the simulation progresses.\n\n\n30.3.3 Treatment duration\n\ntreatment_duration_df = generate_difference_df(\n  event_log=event_log,\n  event_1=\"treatment_begins\",\n  event_2=\"treatment_complete\",\n  output_col_name=\"treatment_duration\")\n\ntreatment_duration_df.head(20)\n\n\n\n\n\n\n\nevent\nentity_id\nrun\ntreatment_begins\ntreatment_complete\ntreatment_duration\n\n\n\n\n0\n1\n0\n0.000000\n40.317385\n40.317385\n\n\n1\n1\n1\n0.000000\n41.226014\n41.226014\n\n\n2\n1\n2\n0.000000\n32.732000\n32.732000\n\n\n3\n1\n3\n0.000000\n40.023184\n40.023184\n\n\n4\n1\n4\n0.000000\n37.026630\n37.026630\n\n\n5\n1\n5\n0.000000\n34.941718\n34.941718\n\n\n6\n1\n6\n0.000000\n36.785746\n36.785746\n\n\n7\n1\n7\n0.000000\n41.752122\n41.752122\n\n\n8\n1\n8\n0.000000\n38.779312\n38.779312\n\n\n9\n1\n9\n0.000000\n42.284465\n42.284465\n\n\n10\n2\n0\n3.399660\n42.443230\n39.043571\n\n\n11\n2\n1\n12.021043\n46.891254\n34.870211\n\n\n12\n2\n2\n8.965271\n46.903314\n37.938043\n\n\n13\n2\n3\n0.033294\n40.296613\n40.263318\n\n\n14\n2\n4\n10.399752\n53.054173\n42.654422\n\n\n15\n2\n5\n2.645552\n39.743828\n37.098276\n\n\n16\n2\n6\n11.489413\n49.827460\n38.338047\n\n\n17\n2\n7\n4.011208\n41.798441\n37.787233\n\n\n18\n2\n8\n17.040648\n51.984157\n34.943509\n\n\n19\n2\n9\n2.861402\n42.211944\n39.350541\n\n\n\n\n\n\n\n\npx.box(\n  treatment_duration_df,\n  x=\"treatment_duration\",\n  title=\"Variation in treatment duration\"\n  )\n\n                            \n                                            \n\n\n\npx.box(\n  treatment_duration_df, x=\"treatment_duration\", color=\"run\",\n  range_x=[\n          0,\n          max(treatment_duration_df[\"treatment_duration\"]) * 1.1\n          ],\n  title=\"Variation in treatment duration by run\"\n        )\n\n                            \n                                            \n\n\n\n\n30.3.4 Throughput\n\npatients_entering_system = event_log[event_log[\"event\"] == \"arrival\"]\n\npatients_entering_system = (\n  patients_entering_system\n  .groupby('run')[['entity_id']]\n  .count()\n  .rename(columns={\"entity_id\": \"entering_system\"})\n  )\n\npatients_entering_system\n\n\n\n\n\n\n\n\nentering_system\n\n\nrun\n\n\n\n\n\n0\n259\n\n\n1\n303\n\n\n2\n276\n\n\n3\n285\n\n\n4\n302\n\n\n5\n270\n\n\n6\n292\n\n\n7\n294\n\n\n8\n258\n\n\n9\n286\n\n\n\n\n\n\n\n\npatients_leaving_system = event_log[event_log[\"event\"] == \"depart\"]\n\npatients_leaving_system = (\n  patients_leaving_system.groupby('run')[['entity_id']]\n  .count()\n  .rename(columns={\"entity_id\": \"leaving_system\"})\n  )\n\npatients_leaving_system\n\n\n\n\n\n\n\n\nleaving_system\n\n\nrun\n\n\n\n\n\n0\n140\n\n\n1\n142\n\n\n2\n141\n\n\n3\n141\n\n\n4\n142\n\n\n5\n143\n\n\n6\n140\n\n\n7\n142\n\n\n8\n143\n\n\n9\n142\n\n\n\n\n\n\n\n\npatient_throughput_df = patients_entering_system.merge(\n  patients_leaving_system,\n  left_index=True,\n  right_index=True\n  )\n\npatient_throughput_df[\"throughput\"] = patient_throughput_df[\"leaving_system\"] / patient_throughput_df[\"entering_system\"]\n\npatient_throughput_df[\"throughput_display\"] = patient_throughput_df[\"throughput\"].apply(lambda x: f\"{x:.1%}\")\n\npatient_throughput_df\n\n\n\n\n\n\n\n\nentering_system\nleaving_system\nthroughput\nthroughput_display\n\n\nrun\n\n\n\n\n\n\n\n\n0\n259\n140\n0.540541\n54.1%\n\n\n1\n303\n142\n0.468647\n46.9%\n\n\n2\n276\n141\n0.510870\n51.1%\n\n\n3\n285\n141\n0.494737\n49.5%\n\n\n4\n302\n142\n0.470199\n47.0%\n\n\n5\n270\n143\n0.529630\n53.0%\n\n\n6\n292\n140\n0.479452\n47.9%\n\n\n7\n294\n142\n0.482993\n48.3%\n\n\n8\n258\n143\n0.554264\n55.4%\n\n\n9\n286\n142\n0.496503\n49.7%\n\n\n\n\n\n\n\n\n\n30.3.5 Animation\nUsing the vidigi package, we can take our event log and - with only minor adjustments and additions - create a full animation of our system.\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'exit',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.n_cubicles = 4 # In this case, I know that there were four resources available.\n\nparams = model_params()\n\nprint(f\"Number of nurses: {params.n_cubicles}\")\n\nNumber of nurses: 4\n\n\n\nfrom vidigi.animation import animate_activity_log\n\nanimate_activity_log(\n        # We need to ensure we only pass in a single run of the model\n        # We also need to ensure that the column 'entity_id' is renamed to 'patient' to match\n        # vidigi's expectations - though this will be made more flexible in a future version\n        # of the package\n        event_log=event_log[event_log['run']==1].rename(columns={\"entity_id\":\"patient\"}),\n        event_position_df=event_position_df,\n        scenario=params,\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        icon_and_text_size=20,\n        gap_between_entities=6,\n        gap_between_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=event_log[\"time\"].max().astype('int'),\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 16:33:54\nIteration through minute-by-minute logs complete 16:33:55\nSnapshot df concatenation complete at 16:33:55\nReshaped animation dataframe finished construction at 16:33:55\nPlacement dataframe finished construction at 16:33:55\n\n\n/mnt/c/hsma6_des_book/.venv/lib/python3.10/site-packages/vidigi/animation.py:129: FutureWarning:\n\nThe 'unit' keyword in TimedeltaIndex construction is deprecated and will be removed in a future version. Use pd.to_timedelta instead.\n\n\n\nOutput animation generation complete at 16:34:01\nTotal Time Elapsed: 7.47 seconds",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  },
  {
    "objectID": "event_logging.html#adding-event-logging-to-your-own-model",
    "href": "event_logging.html#adding-event-logging-to-your-own-model",
    "title": "30  Event Logging",
    "section": "30.4 Adding event logging to your own model",
    "text": "30.4 Adding event logging to your own model\nHere, we’re going to work with the very basic model from the chapter‘An Example SimPy Model’.\n\n30.4.1 the g Class\nOur g class is unchanged.\n\n\n30.4.2 the Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\n30.4.3 the Model Class\n\n30.4.3.1 The init method\nTo our init method for the Model class, we add an empty list that will store event logs throughout the model run for each patient.\n\n\n\n30.4.3.1.1 Original\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\n30.4.3.1.2 With Event Logging Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Add an empty list to store our event logs in \n    self.event_log = [] \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index)\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\n30.4.3.2 the generator_patient_arrivals method\nThis method is unchanged.\n\n\n30.4.3.3 the attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nEvent logging takes the format below:\n\nself.event_log.append(\n        {'patient': entity_identifier,\n            'pathway': 'My_Pathway_Name',\n            'event_type': 'arrival_departure', # or 'queue', 'resource_use', or 'resource_use_end'\n            'event': 'arrival', # or 'depart', or for 'queue' and 'resource_use' or 'resource_use_end' you can determine your own event name\n            'time': self.env.now}\n    )\n\nMore details about event logging can be found in the ‘Event Logging’ page.\nThis is also where we need to change the way we request resources to account for the fact we are now using a simpy store instead of directly interacting with our simpy resources.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\n# Seize a treatment resource when available\ntreatment_resource = yield self.treatment_cubicles.get()\n\n# ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n# Resource is no longer in use, so put it back in the store\nself.treatment_cubicles.put(treatment_resource)\n\n\n\n\n30.4.3.3.1 Original\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n\n\n\n\n\n\n30.4.3.3.2 With Event Logging Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append( \n            {'patient': patient.identifier, \n                'pathway': 'Simplest', \n                'event': 'treatment_begins', \n                # for a resource_use, you can define your chosen event name\n                'event_type': 'resource_use', \n                'time': self.env.now \n                } \n        ) \n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append( \n            {'patient': patient.identifier, \n                'pathway': 'Simplest', \n                # for a resource_use_end, you can define your chosen event name\n                'event': 'treatment_complete', \n                'event_type': 'resource_use_end', \n                'time': self.env.now \n                } \n        ) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    ) \n\n\n\n\n\n\n30.4.3.4 the calculate_run_results method\nThis method is unchanged.\n\n\n30.4.3.5 the run method\n\n\n\n30.4.3.5.1 Original\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\n30.4.3.5.2 With Event Logging Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    self.event_log = pd.DataFrame(self.event_log) \n\n    self.event_log[\"run\"] = self.run_number \n\n    return {'results': self.results_df, 'event_log': self.event_log}  \n\n\n\n\n\n\n\n30.4.4 the Trial Class\n\n30.4.4.1 the init method\n\n\n\n30.4.4.1.1 Original\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\n30.4.4.1.2 With Event Logging Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n\n\n\n\n\n\n30.4.4.2 the run_trial method\n\n\n\n30.4.4.2.1 Original\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\n30.4.4.2.2 With Event Logging Modifications\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        model_outputs = my_model.run()\n        patient_level_results = model_outputs[\"results\"] \n        event_log = model_outputs[\"event_log\"] \n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n        self.all_event_logs.append(event_log) \n\n    self.all_event_logs = pd.concat(self.all_event_logs)",
    "crumbs": [
      "Part 5 - Debugging, Model Validation and Visualising Results",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Event Logging</span>"
    ]
  }
]