---
title: Dealing with appointment bookings
execute:
  eval: false
jupyter: python3
---

In many community-based services, it is important to model the process of booked appointments.

These are quite distinct from the processes we have modelled so far, where arrivals flow through the system immediately - or as quickly as possible, depending on the queues.

This works well for modelling a range of services, or smaller parts of more complex processes, such as

- emergency departments
- services without booking (e.g. a walk-in clinic)
- telephone helplines

However, in many services there is a process by which clients are booked into an appointment at some point in the future. There is often a delay of several days or weeks - which allows patients to receive communication about their appointment and make plans to attend it.

:::{.callout-note}
This video from NHS England explains why a certain level of waiting list can be a good thing for both patients and the service, and how to determine the ideal waiting list size for different services.

{{< video https://youtu.be/hga8HQFXaDw?si=KzNqZly5xf-bJ7S9>}}
:::

Appointment booking can take on additional layers of complexity, such as

- certain slots being set aside for more urgent referrals - and how to balance available capacity for these appointments with the importance of these clients being seen quickly
- an ongoing caseload of patients being held 'on the books' and returning for follow-up appointments at certain intervals
- a triage step prior to appointment booking where the referral may be deemed as inappropriate, giving another point at which referrals may leave the system (a **sink**)
- a certain proportion of patients not attending their appointment, with some exiting the system entirely while some may need to be rebooked

In this chapter, we will look at an implementation of a simple model of a mental health assessment service.

In this model, patients

- are referred to the service
- are booked in to the next available appointment
- wait until the appointment is carried out
- exit the system - we will make the assumption at this point that they are either discharged, or are referred on to a separate service for an intervention, but we will not model this part of the system

## The appointment book

The key difference in this model is that we will feed in an additional object that represents the capacity of the clinic to see new clients.

To begin with, let's assume that

- there is a single clinic
- any client can be seen by any clinician
- they are open six days a week
- all appointments are the same length
- clients do not express any preference about being seen at a particular time of day
- everyone attends their appointment

```{python}
#| eval: true
#| echo: false

import pandas as pd
```

```{python}
#| eval: true
pd.read_csv("resources/shifts_simplest.csv")
```

Here, we have one row per day of the week. We will interpret an index of 0 as Monday and 6 as Sunday.

## Coding the example

### The g class

Rather than setting an interarrival time, we will instead set a value that represents the average annual demand for our clinic.

We will also pass in the dataframe of shifts.

Another new parameter is the minimum wait. To give patients time to receive their appointment letter and make a plan to attend, we don't want to just book the next available appointment, as this could be the very next day, with no time for clients to find out they are meant to be attending!

In the final new parameter, we will

Next, we return to parameters we have used before - the sim duration, which we have this time set as two years (365 days times 2). Note that compared to our previous model, where we interpreted each simpy time unit as 1 minute, we are now interpreting a single time unit as one *day*. We do not change anything in simpy itself to do this - but we just need to be careful that we remain consistent in our application of this throughout the rest of the model.

```{python}
shifts_df = pd.read_csv("resources/shifts_simplest.csv")

# Class to store global parameter values.  We don't create an instance of this
# class - we just refer to the class blueprint itself to access the numbers
# inside.
class g:
    annual_demand = 3500
    shifts = shifts_df

    min_wait = 7

    sim_duration = 365 * 2
    number_of_runs = 100
```

### The Patient (entity) class

In our patient class, we will record an id as before.

We have a new attribute named 'booker' that we will create shortly.

We will also create a space to record the time patients arrive into the model, and the time they have their appointment.

```{python}
# Class representing patients coming in to the clinic.
class Patient:
    def __init__(self, p_id, booker):
        self.id = p_id
        self.booker = booker

        self.arrival_time = 0
        self.waiting_time = 0
```


### The booker class


### The Model class


### The trial class

Our trial class is fundamentally unchanged - the main differences relate to the changes to the metrics we are interested in tracking.

```{python}
# Class representing a Trial for our simulation - a batch of simulation runs.
class Trial:
    # The constructor sets up a pandas dataframe that will store the key
    # results from each run (just the mean queuing time for the nurse here)
    # against run number, with run number as the index.
    def  __init__(self):
        self.df_trial_results = pd.DataFrame()
        self.df_trial_results["Run Number"] = [0]
        self.df_trial_results["Mean Wait Time for Appointment"] = [0.0] ##NEW
        self.df_trial_results.set_index("Run Number", inplace=True)

    # Method to print out the results from the trial.  In real world models,
    # you'd likely save them as well as (or instead of) printing them
    def print_trial_results(self):
        print ("Trial Results")
        print (self.df_trial_results)

    # Method to run a trial
    def run_trial(self):
        # Run the simulation for the number of runs specified in g class.
        # For each run, we create a new instance of the Model class and call its
        # run method, which sets everything else in motion.  Once the run has
        # completed, we grab out the stored run results (just mean queuing time
        # here) and store it against the run number in the trial results
        # dataframe.
        for run in range(g.number_of_runs):
            my_model = Model(run)
            my_model.run()

            self.df_trial_results.loc[run] = [my_model.mean_wait_time_appointment] ##NEW

        # Once the trial (ie all runs) has completed, print the final results
        self.print_trial_results()
```

## Adding in priority and carve-out






## Adding multiple clinics



## Pooling of clinics
