[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HSMA - the little book of DES",
    "section": "",
    "text": "Attribution and Acknowledgements\nThe content in this book is a combined effort, bringing together the knowledge of the Peninsula Collaborative for Operational Research and Design (PenCHORD) on the topic.\nThe content in part 1 and a large amount of part 2 is from a series of sessions given on discrete event simulation as part of the HSMA programme. These lectures and accompanying code examples were written by Dr Daniel Chalk and made available under the C BY-NC-SA 4.0 licence. The chapters often replicate the wording of these lectures nearly exactly, with minor tweaks and additions for readability and to better suit the format of a book made by Sammi Rosser.\nThe content in parts 3 and 4 is more of a mixture of content from the HSMA lectures along with brand new content written for this book, drawing on a range of work done by the wider PenCHORD team. Adaptation into book format has been done throughout by Sammi Rosser.\nHSMA 6: Lecture 1 - Slides - Github\nHSMA 6: Lecture 2 - Slides - Github\nHSMA 6: Lecture 3- Slides - Github",
    "crumbs": [
      "Attribution and Acknowledgements"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html",
    "href": "intro_to_des_concepts.html",
    "title": "2  Introduction to DES Concepts",
    "section": "",
    "text": "2.1 Why use DES?\nDiscrete event simulation allows you to\nThis can allow you to optimize a system, leading to better balance and better flow, which can in turn lead to - A safer environment - Less stress for staff - Improved patient experience - Meeting targets",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#why-use-des",
    "href": "intro_to_des_concepts.html#why-use-des",
    "title": "2  Introduction to DES Concepts",
    "section": "",
    "text": "Test changes in a risk-free, low-cost way\nExplore the impact of changes in demand\nSee whether a system can cope on bad days as well as good days\nPredict how long it will take to clear an existing backlog",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#an-example",
    "href": "intro_to_des_concepts.html#an-example",
    "title": "2  Introduction to DES Concepts",
    "section": "2.2 An example",
    "text": "2.2 An example\nImagine being able to create a model of an emergency department.\nIn this model, you can change all sorts of things - how many doctors, nurses and receptionists there are at each step - how long it takes for people to be seen - how many people go into the trauma pathway versus the non-trauma pathway\nThen sprinkle in a dose of randomness - because in real life, you’re not going to have each appointment taking the exact same amount of time, or people arriving exactly every five minutes - and then you can start to explore just how well a system will perform, what changes might have the most impact, and what configuration is likely to perform best. Then you can run it 1000 times with slightly different random days to see how well it performs on both good days and bad.\nYou can polish it all off by visualising the individual entities moving through the system so people with little understanding of discrete event simulation can get a sense of what’s going on, and you can give them access to all of the controls - the number of nurses and doctors, the average consultation length, and more - so that they can explore the impact of theser changes themselves.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#runs-and-trials",
    "href": "intro_to_des_concepts.html#runs-and-trials",
    "title": "2  Introduction to DES Concepts",
    "section": "2.3 Runs and Trials",
    "text": "2.3 Runs and Trials\nIn a stochastic model, it is important that we do not just run a model once if we’re looking to draw insights from our results. This is because every run of the simulation will have different random samples for inter-arrival times, activity times etc.\nWhat if you had a run with unusually long activity times sampled (a run of “bad luck”)? Or unusually long inter-arrival times (a run of “good luck”)?\nWe need to run a stochastic simulation many times and take summary statistics over the results from each run to get more representative results from the model.\nA single run of a model for a simulated period of time is known as a run. A batch of multiple runs with the same parameter values is known as a trial.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_des_concepts.html#key-des-terminology",
    "href": "intro_to_des_concepts.html#key-des-terminology",
    "title": "2  Introduction to DES Concepts",
    "section": "2.4 Key DES Terminology",
    "text": "2.4 Key DES Terminology\n\nEntities are the things that are flowing through the sequential processes in the model (eg patients, test results, callers on a phone)\nGenerators are the way in which entities enter the model and come into being (eg arriving at ED by ambulance, self-presenting, referral from GP)\nInter-Arrival Times specify the time between entities being generated in the generators (ie the time between arrivals into the modelled system)\nActivities (sometimes referred to as Servers) are the bits of process that the entities are queuing up for (eg triaged, seen at reception, speak to doctor etc)\nActivity Time represents the amount of time it takes for an activity to happen to an entity - this is normally stochastic (random) and drawn from a distribution for each entity (eg time spent with nurse, time to be treated etc)\nResources are the “stuff” and / or “staff” required for an activity to happen to an entity (eg nurse to triage, bed for patient, consultation room for GP to see patient etc, X-Ray machine and Radiographer to be free for X-Ray etc). Important - resources may be shared between activities (eg the same nurse may be required to run multiple activities in our model, or even things we haven’t explicitly modelled)\nQueues hold entities that are waiting for an activity. Entities wait in a queue until the activity has both the capacity and all required resources.\nSinks are how entities leave the model (the bit of system we’re modelling)\n\n\n2.4.1 Entities\nEach entity may have certain “attributes” that it “carries with them” to help determine its journey through the modelled system. For example :\n\nwhether it goes down path A or B\nhow long it spends in an activity\nits priority in a queue for an activity\n\nThere may also be more than one type of entity in a model at the same time. For example, patients in a clinic, their test results, and phone calls into the clinic are all entities that we may want to capture when modelling the clinic.\n\n\n\n2.4.2 Generators and Inter-Arrival\nA generator creates new entities to bring into the system. The rate at which new entities are generated is determined by an inter-arrival time.\nThe inter-arrival time determines the time between one entity being generated, and the next one being generated.\nInter-arrival times may be fixed, but are typically sampled (drawn) stochastically (randomly) from a distribution to capture variability (even if the variability is small).\nAn Exponential Distribution is often used to sample inter-arrival times. More than one distribution may be used for the same generator (e.g. for different times of the day, day of week etc). You may also (often) have more than one generator in a system.\n\n\n\n2.4.3 Queues\nEach activity in a Discrete Event Simulation has an associated queue. The queue holds entities whilst they wait for the activity to become available for them.\nEach queue has a queuing policy. This determines the order in which entities are released from the queue into the activity. The two most common queuing policies are:\n\nFirst In First Out (FIFO) : entities are seen in the order they arrive. This is the default.\nPriority-based : entities are seen according to some priority attribute. Ties often resolved using FIFO\n\n\n\n\n2.4.4 Activities and Activity Times\nEach activity in a DES describes a process – this may be a simple atomic task, or a set of tasks bundled together. For an activity to take place, it needs : - An entity (drawn from the queue) - The required type and number of resource to be available\nOnce the above conditions have been met, the activity begins. The entity, and the resource(s) are then locked in place for an amount of time – the Activity Time. The resource(s) cannot be used elsewhere until the activity time has passed.\nActivity times may be fixed, but are typically sampled stochastically from a distribution.\n\n\n\n\n\n\n\nTip\n\n\n\nThe common distribution for process times is the Log Normal distributions. However, Exponential Distributions can be a good starting point, as it’s easy to change the “mean” when playing around with things. You can then change to something like a Log Normal once you (and the stakeholders) are happy\n\n\n\n\n2.4.5 Resources\nResources are needed to undertake activities. An activity may require just a single resource, more than one resource of the same type, or multiple resources of different types.\n\n\n\n\n\n\nTip\n\n\n\nAn activity may not require a resource at all, but think carefully to ensure that it really is either “resourceless” or there is no constraint on the resource (and so doesn’t need to be modelled).\nResources can include - “staff” (e.g. doctors, nurses, officers etc) - “stuff” (beds, test equipment, detention cell etc)\n\n\nResources can (and often are) shared across a system, so may be required for more than one activity. Therefore, a resource drain in one part of the system can affect another.\nAll required resources are needed for an activity to take place.\nIn some activities, having optional additional resource may speed up the activity (though rarely linearly).\n\n\n\n2.4.6 Sinks\nSinks are how entities leave the system, or part of the system, being modelled. Sinks might include : - an entity physically leaving a system (e.g. discharge from hospital) - an entity no longer existing (e.g. death, use of sample, end of telephone call) - an entity no longer needing to access activities that we’re interested in (e.g. they leave the bit of the system that we’re modelling)\nThe most important thing to remember about a sink is that it doesn’t necessarily represent an entity leaving the system entirely.\nFor example, the scope of your model may only cover the triage aspect of an Emergency Department. Therefore, a valid sink might be placed after their triage - they’ve left the scope of our model\n\n\n\n2.4.7 Branching Paths\nReal world systems (and the models of those systems) are rarely linear. Often, different things will happen to different entities. In a Discrete Event Simulation, this means different entities flowing to different activities, or different sinks.\nWe might differentiate based on : - an attribute of the patient (e.g. patients with a higher priority value flow through a different set of activities) - probability (e.g. we know that approx 60% of these patients end up being admitted, so we’ll randomly select for them to be admitted 60% of the time) - time (e.g. after a certain time of day, entities flow through a different set of activities)\n\n\n\n2.4.8 Outputs\nAs with any type of model, it’s important to think about what outputs you need your DES model to generate to answer your modelling questions. As a DES model is used to model queuing and resourcing problems, typical DES model outputs include average, min, max, xth percentile of :\n\ntime entities are in system\nqueue length and duration for queues of interest\nrate of resource utilisation (ie % of time a resource is in use for activities in the model)\nprobability of exceeding a defined queue length / queue time / resource utilisation threshold (e.g. 4 hour wait in ED, overcrowding thresholds)",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to DES Concepts</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html",
    "href": "intro_to_simpy.html",
    "title": "3  An Introduction to SimPy",
    "section": "",
    "text": "3.1 Simulation Time\nSimPy simulations run in time units*. These units of time can represent any real world amount of time we like as long as we are consistent within the same model.\nOur time units should represent the lowest level of real world time that we need to represent in the model. In models of pathways where people arrive for a service, this will likely be minutes (seconds is too much, and hours is probably not enough, unless all the processes are slow). But we may have pathways where we measure time in days or weeks (e.g. referral pathways).\nFor example, in an ED model, our time units may represent minutes. So we specify everything in minutes - inter-arrival times, activity times etc.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html#simulation-time",
    "href": "intro_to_simpy.html#simulation-time",
    "title": "3  An Introduction to SimPy",
    "section": "",
    "text": "Strictly speaking, SimPy doesn’t run in time units ticking away one by one. Instead, it schedules events jumps to the next event. But don’t worry about that for your purposes. Just know that, because of this, you will see current simulation time as floating point numbers (eg the current time unit could be 3.6 etc).",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "intro_to_simpy.html#generator-functions",
    "href": "intro_to_simpy.html#generator-functions",
    "title": "3  An Introduction to SimPy",
    "section": "3.2 Generator Functions",
    "text": "3.2 Generator Functions\nSimPy is built around a special type of function in Python known as a Generator Function.\nSo let’s have a look at what we mean by a Generator Function.\nConventional functions in Python are called, then run with some (optional) inputs, and then finish (usually by returning some output). When we call the function again, it runs again, from scratch.\nGenerator functions remember where they were and what they did when control is passed back (they retain their local state), so that they can continue where they left off, and can be used as powerful iterators (for and while loops are other examples of iterators).\nThis is very useful where we want state to be maintained, so we can remember how long until we generate the next entity, or where an entity is in a pathway…\nLet’s look at a very simple example of a generator function to see how they work.\n\nIn SimPy, we use Generator Functions in two different places :\nTo model the DES generators (arrival points) To model the individual journey of each entity\nLet’s imagine we are modelling patients in a patient pathway.\nFor 1, the generator function basically creates a patient, sets them off on their pathway, then freezes in place for an amount of time representing the inter-arrival time to the next patient. Then it does it all over again.\nFor 2, the generator function requests a resource and freezes until that resource is available (the queue). When the resource is available it freezes in place for an amount of time with it (the activity). It will then either move on to the next activity (and request the resource for it, as above) or end if there are no further activities.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>An Introduction to SimPy</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html",
    "href": "recommended_structure_classes_for_des_models.html",
    "title": "4  The Recommended Structure for DES Models",
    "section": "",
    "text": "4.1 Class breakdown\nLet’s look at the purpose and recommended structure of each class in a bit more detail.\nHere, the example code given relates to a customer support helpline. Customers call a helpline, wait on hold until a customer support agent is ready to speak to them, speak to the agent for a period of time, and then the call ends and the agent connects to the next person who is waiting on hold. If there is no-one on hold at the time, the agent will get a break until someone else arrives!",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html#class-breakdown",
    "href": "recommended_structure_classes_for_des_models.html#class-breakdown",
    "title": "4  The Recommended Structure for DES Models",
    "section": "",
    "text": "4.1.1 g Class\nThe g Class stores our global parameter values for the model so we can easily change aspects of the model to test scenarios. This includes :\n\nValues to define inter-arrival time distributions (eg mean, standard deviation etc)\nValues to define activity time distributions (eg mean, standard deviation etc)\nNumber of each resource\nDuration of simulation runs\nNumber of runs in a trial\n\nWe do not create an instance of g class. Instead, we refer to it directly when we need to access something in it.\n\n\n\n\n\n\nExample g class\n\n\n\n\nclass g:\n    time_units_between_customer_arrivals = 5\n    mean_customer_service_time = 6\n    number_of_customer_support_agents = 1\n    sim_duration = 1440\n    number_of_runs = 10",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html#entity-class",
    "href": "recommended_structure_classes_for_des_models.html#entity-class",
    "title": "4  The Recommended Structure for DES Models",
    "section": "4.2 Entity class",
    "text": "4.2 Entity class\nThe entity class represents our entity in the model - which, for healthcare models, will often be patients.\nWe can store attributes here that entities carry with them that we may want to access (think of a person carrying a clipboard with them with information on it).\nIn a simple model, an entity may just carry their ID and how long they spent queuing for a resource (once known). But more advanced models could store things like their condition, their priority, probability of going down path x, etc.\n\n\n\n\n\n\nExample entity class\n\n\n\n\nclass Customer:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.queue_time_customer_support_agent = 0",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html#model-class",
    "href": "recommended_structure_classes_for_des_models.html#model-class",
    "title": "4  The Recommended Structure for DES Models",
    "section": "4.3 Model Class",
    "text": "4.3 Model Class\nThe Model Class represents the system we are modelling - this might be a clinic, for example. As such, there’s a lot more to unpack here, so let’s take this bit by bit.\nFirst, we’ll look at the constructor for our model.\nThe constructor will set up - a SimPy Environment (basically where everything lives) - an entity counter (which we’ll use to give entities - such as patients - a simple ID) - the resources we need (for example, our nurses) - a DataFrame to store per-entity results in a single run of the model - attributes to store things like how long the entities queued for each activity\nWhat the constructor sets up doesn’t have to be limited to these things - anything relating to the system as a whole that makes sense to store here could be included.\n\n4.3.1 DES generator - arrivals of entities to the system\nWithin the Model Class we have a generator function that will represent our DES generator for entities arriving into our process.\nHere’s basically how it works:\nKEEP REPEATING THE FOLLOWING FOREVER (until the simulation stops running) : 1. Increment the counter to get ID for next entity 2. Create a new entity and give them that ID 3. Start up an instance of the generator function for their journey through the process and chuck them in it 4. Sample the time until the next entity arrives 5. FREEZE this function until that time elapses 6. Return to 1\n\n\n4.3.2 DES Generator - the entity journey\nNow, let’s look at the big one. The other generator function - the one that represents an entity’s journey through the system (this is the one we lobbed the new entities generated by the previous generator).\nHere’s how this works : 1. Record time started queuing for first activity 2. Request resource for first activity 3. Wait until resource is free 4. Once resource is free, grab the resource and keep hold of the resource until finished with them. Record time finished queuing and calculate queue time. 5. Sample how long will spend in this activity. 6. FREEZE this instance of the function until that time elapses (freezing the resource with it, so it’s not available to anyone else) 7. If there’s another activity, do the same again for that one. If not, end (and therefore entity leaves the model).\n\n\n4.3.3 Running the model\nFinally, we need a run method in our Model class. Basically, the run method will : - Start up our DES generators (our arrival points) - we only have one here. - Tell the simulation to run for the duration specified in g Class. - Call the calculate run results method in the previous slide. - Print out the run number with the patient-level results from this run.\n\n\n\n\n\n\nFull Example model class\n\n\n\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a customer counter (which we'll use as a customer ID)\n        self.customer_counter = 0\n\n        # Create a SimPy resource to represent a customer support agent, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.customer_support_agent = simpy.Resource(self.env, capacity=number_of_customer_support_agents)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the customer ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Customer ID\"] = [1]\n        self.results_df[\"Queue Time\"] = [0.0]\n        self.results_df[\"Time with Customer Support Agent\"] = [0.0]\n        self.results_df.set_index(\"Customer ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the support agents\n        # across this run of the model\n        self.mean_queue_time_support_agent = 0\n\n    # A generator function that represents the DES generator for customer\n    # arrivals\n    def generator_customer_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the customer counter by 1 (this means our first customer\n            # will have an ID of 1)\n            self.customer_counter += 1\n\n            # Create a new customer - an instance of the customer Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # customer - so here we pass the customer counter to use as the ID.\n            c = Customer(self.customer_counter)\n\n            # Tell SimPy to start up the use_customer_service_helpline generator function with\n            # this customer (the generator function that will model the\n            # customer's journey through the system)\n            self.env.process(self.use_customer_service_helpline (c))\n\n            # Randomly sample the time to the next customer arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter_arrival_time = random.expovariate(1.0 / g.time_units_between_customer_arrivals)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter_arrival_time)\n\n    # A generator function that represents the pathway for a customer calling our helpline\n    # Here the pathway is extremely simple - a customer\n    # arrives in the call system, waits to be connected to a customer support agent,\n    # spends a varying amount of time being helped by the agent, and then leaves,\n    # meaning the agent is free to help the next person.\n    # The customer object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def use_customer_service_helpline(self, customer):\n        # Record the time the patient started queuing for a nurse\n        start_q_customer_support_agent = self.env.now\n\n        # This code says request a customer support agent resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.customer_support_agent.request() as req:\n            # Freeze the function until the request for a customer support agent can be met.\n            # The customer is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a customer support agent has\n            # been met.  We now have the customer support agent, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_customer_support_agent = self.env.now\n\n            # Calculate the time this patient was queuing for the customer support agent, and\n            # record it in the customer's attribute for this.\n            customer.queue_time_customer_support_agent = end_q_customer_support_agent - start_q_customer_support_agent\n\n            # Now we'll randomly sample the time this customer with the customer support agent.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_customer_support_agent_activity_time = random.expovariate(1.0 /\n                                                        g.mean_customer_service_time)\n\n            # Here we'll store the queuing time for the customer support agent and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this customer.\n            #\n            # In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            #\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[customer.id, \"Queue Time\"] = (\n                customer.queue_time_customer_support_agent)\n            self.results_df.at[customer.id, \"Time with Customer Support Agent\"] = (\n                sampled_customer_support_agent_activity_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the customer support\n            # agent.\n            yield self.env.timeout(sampled_customer_support_agent_activity_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_queue_time_support_agent = self.results_df[\"Time with Customer Support Agent\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new customers.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_customer_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the customer-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "recommended_structure_classes_for_des_models.html#trial-class",
    "href": "recommended_structure_classes_for_des_models.html#trial-class",
    "title": "4  The Recommended Structure for DES Models",
    "section": "4.4 Trial class",
    "text": "4.4 Trial class\nOur final class is the Trial class. This represents a batch of simulation runs, and will contain methods to run a batch of runs, as well as store, record and display results from the trial.\n\n\n\n\n\n\nExample trial class\n\n\n\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Customer Supoprt Agent\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_queue_time_support_agent]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\nWe can, of course, then take the means over the runs in the trial to get the average predicted queuing time etc. - and we should probably do that in a separate method in the Trial class.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>The Recommended Structure for DES Models</span>"
    ]
  },
  {
    "objectID": "exercise_des_design.html",
    "href": "exercise_des_design.html",
    "title": "5  Exercise - Designing a DES",
    "section": "",
    "text": "Design a Discrete Event Simulation for a system of your choosing.\nThink about some different possibilities (and these don’t have to be health-related, they can be anything! A restaurant? Airport? Customer service line?).\nYou should then draw up a design for the model. This should include : - The “what if?” question(s) you would use the model to answer - A process map of the system you are looking to model - A conceptual model for the proposed Discrete Event Simulation (which may not include everything in the process map).\nIdentify the types of entities, generators, activities, queues, resources and sinks.\nDescribe what each of your inter-arrival times and activity times represent, and from where you might draw the data.\nConsider the scope, level of detail etc when designing your model. What do you need to model to answer your question? How can you simplify your model?\n\n\n\n\n\n\nTip\n\n\n\nThe website draw.io (also known as diagrams.net) is a great free resource for creating process maps.",
    "crumbs": [
      "Part 1 - DES Concepts and Design",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Exercise - Designing a DES</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html",
    "href": "an_example_simpy_model.html",
    "title": "6  An example simpy model",
    "section": "",
    "text": "6.1 Import statements\nFirst we need our import statements. The libraries you import will vary depending on your model and what you need, but these three are likely going to always be in there (the first must be!)\nimport simpy\nimport random\nimport pandas as pd",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#import-statements",
    "href": "an_example_simpy_model.html#import-statements",
    "title": "6  An example simpy model",
    "section": "",
    "text": "Tip\n\n\n\nrandom gives us access to stochastic sampling from probability distributions",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#g-class",
    "href": "an_example_simpy_model.html#g-class",
    "title": "6  An example simpy model",
    "section": "6.2 g Class",
    "text": "6.2 g Class\nRemember - the g Class stores our global parameter values for the model so we can easily change aspects of the model to test scenarios.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#patient-entity-class",
    "href": "an_example_simpy_model.html#patient-entity-class",
    "title": "6  An example simpy model",
    "section": "6.3 Patient (entity) Class",
    "text": "6.3 Patient (entity) Class\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#model-class",
    "href": "an_example_simpy_model.html#model-class",
    "title": "6  An example simpy model",
    "section": "6.4 Model Class",
    "text": "6.4 Model Class\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model.html#trial-class",
    "href": "an_example_simpy_model.html#trial-class",
    "title": "6  An example simpy model",
    "section": "6.5 Trial Class",
    "text": "6.5 Trial Class\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nNow we just need to run the trial and print out the results!\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         2.018555\n2               0.000000         4.653931\n3               1.444187         5.966463\n4               6.418032         5.087512\n5               8.694685         9.334905\n6              17.482597         4.975999\n7              17.846697         1.105648\n8              14.370516        23.470179\n9              23.374100         1.799778\n10             17.993396         2.956492\n11             20.796070         2.002494\n12             15.852263         7.563553\n13             22.184441         6.544675\n14             28.049175         2.918265\n15             29.847819         8.517140\n16             35.118948         1.268178\n17             27.026110         4.652315\n18             30.485829        12.667368\n19             42.327543         0.106009\n20             37.481449         1.735628\n21             37.661323         4.522235\nRun Number 1\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.778788\n2               0.000000         6.650916\n3               0.000000         2.947400\n4               1.241983        16.099963\n5              15.506450         3.073671\n6              16.497501         3.460604\n7              17.277120         4.180688\n8              20.452306         1.098965\n9               0.000000         2.537461\n10              0.000000         2.794513\n11              0.000000         9.446761\n12              7.525694         4.161653\n13             11.450035        12.191787\n14             23.570225         1.990251\n15             21.896863        18.499377\n16             34.679097         7.650576\n17             39.542312         6.909604\nRun Number 2\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         1.114548\n2               0.000000         1.325246\n3               0.000000        19.185237\n4              13.095576         3.902676\n5              14.908228         1.018655\n6               6.572636         2.926946\n7               0.000000         2.266373\n8               0.000000         0.352110\n9               0.000000         9.858072\n10              7.079066         1.170359\n11              6.418489         7.319566\n12              6.989115        12.703231\nRun Number 3\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         1.697710\n2               0.000000        13.197633\n3              11.994616         8.650904\n4              17.693544         1.050428\n5              16.900052         3.291244\n6              18.585819        11.686332\n7              18.646465         2.092900\n8              19.521416         3.682071\n9              14.337986         6.179816\n10             16.029778         4.156232\n11             16.532797         4.614863\n12             15.737070         1.914453\n13             17.411843         5.987524\n14              8.204650        10.550827\n15             13.590385         0.229847\n16             11.375611        10.236743\n17             16.733157         6.880413\n18             19.492179         5.093005\n19             20.568286         2.349477\n20             22.293282         1.001535\n21             21.992360         0.684744\n22             22.427992         2.588714\n23             24.422766         1.173304\n24             21.876757        12.315608\nRun Number 4\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         1.146373\n2               0.000000         1.199417\n3               0.000000         1.899241\n4               1.825708         6.466988\n5               4.810488         5.240925\n6               7.043404         4.650036\n7              10.559472        13.761563\n8              21.012853         2.956369\n9              22.467018         8.523156\n10             29.852938        25.794391\n11             49.756755         7.049993\n12             45.413782         0.374311\n13             40.018041        15.480032\n14             48.097817         1.375745\n15             49.037560         0.866686\n16             47.974119         1.290523\n17             42.850254        34.535864\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                   20.688342\n1                   12.331740\n2                    4.588592\n3                   16.098700\n4                   24.748248",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>An example simpy model</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_multiple_steps.html",
    "href": "an_example_simpy_model_multiple_steps.html",
    "title": "7  Adding Multiple Activities",
    "section": "",
    "text": "Very often there will be more than one activity in a model.\nWhat if instead of this model\n\nWe wanted something more like this?\n\nIf we want patients to flow from one activity to another, we just write another one after the first one in the pathway generator function. That (aside from adding in any extra resources and results capture elsewhere) is it.\n\n\n\n\n\n\nWarning\n\n\n\nJust make sure you write the next bit outside of the with statement. Otherwise you’ll drag across the resource from the previous activity too…\nOf course, in some cases, you might want that - perhaps if you’re modelling a bed as a resource, for example, but then want to model using an additional resource like a nurse for some parts of the process.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThroughout the code, anything new that’s been added will be followed by the comment ##NEW - so look out for that in the following code chunks.\n\n\nFirst, lets add some additional parameters to our g class.\n\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5\n\nNext we’ll add an additional attribute - think of it as an extra box on their clipboard that they need to fill in - to record how long they are queuing for the receptionist.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n\nNow we move to our model class. Let’s start by looking at the init method - the list of things that are set up when we create an instance of our model class.\nFirst, we have added in a new type of resource - a receptionist, pulling in the number of receptionist to create from our g class.\nWe’ve then added two additional fields to our results dataframe - how long each patient queues for a receptionist, and how long each patient spends with the receptionist.\nFinally, we add in an attribute that we will use to store the mean average queuing time for receptionists across the whole model.\n\ndef __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n\nOur generator_patient_arrivals method remains unchanged as nothing has been tweaked about how patients turn up to the system.\nOur attend_clinic method is where we make the actual change to the process the patient goes through.\nNote that we have a new line with an indended section inside it.\n\nwith self.receptionist.request() as req:\n\nEverything at one level of indentation within this now relates to the use of the receptionist resource.\n\n # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\nBelow is the full code for our updated model. Look out for the lines that end with #NEW to find the bits we’ve added.\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean() ##NEW\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0] ##NEW\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW (added receptionist queuing mean as first item to list)\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nLet’s run the updated code and see the outputs.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         1.767842      0.000000         1.679726\n2               0.000000         3.107829      0.000000        27.471117\n3               1.649769         1.225535     26.245582         1.373895\n4               1.357297         0.766101     26.853376         1.458288\n5               1.937275         1.299327     27.012337         2.665274\n6               0.000000         2.222377     20.918167         2.939488\n7               0.000000         5.034041     16.724761         0.691365\n8               4.514515         1.662787     15.753339         5.415995\n9               1.982453         0.533617     20.635717         4.840259\n10              0.721427         0.869039     24.606937         0.092999\n11              1.509235         1.042998     23.656939        16.841265\n12              0.000000         1.292215     36.718642         6.064942\n13              0.000000         2.871975     36.392162         6.139251\n14              1.839730         0.717089     41.814324         5.560140\n15              0.000000         5.247238     42.068423         7.060352\n16              4.890467         2.979757     46.149018         7.512772\n17              0.000000         3.807921     40.286121        12.240179\n18              3.352931         0.739753     51.786547         0.037525\n19              1.766164         0.640045     51.184028         5.286963\n20              0.971824         1.296688           NaN              NaN\n21              0.000000         0.169566           NaN              NaN\n22              0.000000         3.152911           NaN              NaN\n23              0.000000         0.490457           NaN              NaN\n24              0.000000         0.840283           NaN              NaN\n25              0.000000         3.813176           NaN              NaN\n26              1.528034         0.856776           NaN              NaN\n27              0.210522         0.820092           NaN              NaN\n28              0.000000         7.185501           NaN              NaN\n29              5.666675         0.076786           NaN              NaN\n30              5.274615         0.223623           NaN              NaN\n31              4.758642         0.399674           NaN              NaN\n32              3.560953         0.532666           NaN              NaN\n33              2.519606         4.877121           NaN              NaN\n34              5.633149         6.025675           NaN              NaN\n35              7.602564         1.772281           NaN              NaN\nRun Number 1\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         0.290270      0.000000         2.423999\n2               0.000000         3.613175      0.000000        17.998482\n3               0.000000         7.375628      5.615488         1.189123\n4               4.405401         3.692582      3.112029         4.853030\n5               2.935239         0.089932      7.875127         0.579804\n6               0.832174         1.224068      7.230864         4.991442\n7               0.000000         0.330177      8.723072         4.686499\n8               0.000000         1.468485     11.900661        15.923257\n9               0.323323         0.016018     27.807900         3.717823\n10              0.000000         0.640837     24.622304         5.162087\n11              0.000301         0.520713     29.263678         8.040387\n12              0.000000         1.084328     31.412558         4.955419\n13              0.000000         2.132412     24.542999         1.167184\n14              0.000000         0.986252     23.376278         1.355327\n15              0.000000         0.286417     23.321847         3.598919\n16              0.000000         1.029682     25.015337         1.801899\n17              0.000000         0.622416     18.382083         0.746321\n18              0.000000         2.190401     13.225456         0.676415\n19              0.000000         0.999358     10.134637         2.361681\n20              0.000000         2.806774      0.000000         2.734668\n21              0.000000         0.907280      0.973092        14.608559\n22              0.044453         0.069807     15.511844         0.116474\n23              0.000000         3.268430      4.703174         8.986374\n24              2.600354         2.055387           NaN              NaN\n25              0.000000         0.593374           NaN              NaN\n26              0.330396         0.699199           NaN              NaN\nRun Number 2\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         1.121949      0.000000         0.667809\n2               0.000000         1.186580      0.000000         8.889585\n3               0.000000         0.995048      2.499673         4.501479\n4               0.248578         0.181879      6.819273         4.507544\n5               0.000000         4.603209      5.949180         4.429622\n6               0.268839         1.794195      8.584607         3.555139\n7               0.114054         0.559635     11.580111         0.431388\n8               0.000000         4.409979      6.294328         0.340179\n9               0.000000         2.967372      3.051427         2.656609\n10              0.000000         2.888703      0.000000         8.007272\n11              1.609400         0.463805      7.543467         1.098248\n12              0.000000         2.530563      5.722983         1.757468\n13              1.686863         1.127530      6.352921         2.255855\n14              0.000000         1.347294      2.529384         3.170542\n15              0.000000         2.051157      1.382621         0.719201\n16              0.000000         3.883522      0.000000         1.138643\n17              3.638397         4.360432      0.000000         9.765028\n18              7.403351         5.908676      3.856353         5.393137\n19             13.138670         0.074571      9.174918         1.763302\n20             12.550251         0.543904     10.394316         3.194418\n21              0.000000         6.417018      5.460681         7.132681\n22              6.159211         3.128651      9.464711         2.679167\n23              8.858319         0.087712     12.056167        19.416877\n24              0.984555         0.630903           NaN              NaN\n25              0.000000         5.164355           NaN              NaN\n26              0.523822         1.961149           NaN              NaN\n27              0.000000         0.924849           NaN              NaN\n28              0.000000         0.323380           NaN              NaN\nRun Number 3\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         0.859712      0.000000         2.107372\n2               0.312794         3.198046      0.000000         1.224042\n3               2.614839         7.459189      0.000000        15.512293\n4               4.870317         1.762941     13.749353        10.874682\n5               4.474104         2.087247     22.536788         3.192763\n6               0.000000         0.336934     20.749515        18.089851\n7               0.281473         0.593732     38.245633        26.069051\n8               0.000000         3.450940     59.408443        18.737327\n9               0.000000         9.540619     64.022932         7.281168\n10              4.635630         3.062424     68.241675         4.744234\n11              7.254282         2.721898     70.264011        16.457898\n12              4.385497         0.974645           NaN              NaN\n13              1.570748         0.883153           NaN              NaN\n14              0.000000         2.654534           NaN              NaN\n15              2.197659         2.074483           NaN              NaN\n16              0.000000         1.593970           NaN              NaN\n17              0.000000         0.648536           NaN              NaN\n18              0.000000         1.763486           NaN              NaN\n19              0.000000         0.050672           NaN              NaN\n20              0.000000         2.167380           NaN              NaN\n21              0.000000         5.074749           NaN              NaN\n22              3.337945         2.562998           NaN              NaN\n23              5.766125         3.827858           NaN              NaN\nRun Number 4\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         8.304891      0.000000         6.843837\n2               5.599501         6.913861      0.000000        16.910121\n3               4.776084         3.746469     13.163652         3.017152\n4               7.302518         0.729400     15.451404         3.729469\n5               7.497075         1.281533     17.899340        14.511548\n6               8.048431         1.644138     30.766750         0.152226\n7               0.000000         0.027955     18.505789         2.965608\n8               0.000000         2.030756     10.284936         2.226744\n9               0.000000         1.696868      7.476125         7.965361\n10              0.000000         0.975685     11.728487         6.822849\n11              0.000000         0.476689     15.239426         3.336270\n12              0.000000         0.401229     17.824752         5.139114\n13              0.000000         0.381837     21.875337        15.439784\n14              0.000000         2.069193     34.712818         4.285522\n15              1.760380         1.360104     37.638237         0.763446\n16              0.000000         0.391321     18.674124         5.376347\n17              0.000000         0.477095     21.805880         0.778283\n18              0.000000         2.941759      9.045567        13.587422\n19              0.000000         6.051440           NaN              NaN\n20              5.138287         0.015249           NaN              NaN\n21              1.594790         1.152747           NaN              NaN\n22              0.000000         3.044454           NaN              NaN\n23              0.523380         0.555391           NaN              NaN\n24              0.000000         4.888013           NaN              NaN\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse\nRun Number                                      \n0                    1.807081          28.884548\n1                    0.441217          13.771758\n2                    2.042297           5.161614\n3                    1.813105          32.474395\n4                    1.760019          16.782924",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding Multiple Activities</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html",
    "href": "an_example_simpy_model_branching.html",
    "title": "8  Adding Branching Paths",
    "section": "",
    "text": "8.1 Coding the model",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html#coding-the-model",
    "href": "an_example_simpy_model_branching.html#coding-the-model",
    "title": "8  Adding Branching Paths",
    "section": "",
    "text": "8.1.1 the g class\nWe need to add a few additional parameters to our g class.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20 ##NEW\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2 ##NEW\n    prob_seeing_doctor = 0.6 ##NEW\n    sim_duration = 120\n    number_of_runs = 5\n\n\n\n8.1.2 The Patient class\nWe want to add an additional attribute to record the time patients spend with the doctor if they see one.\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0 ##NEW\n\n\n\n8.1.3 The model class\n\n8.1.3.1 the init method\nIn the init method, we add a few additional atrributes to store additional outputs from the model.\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0] ##NEW\n        self.results_df[\"Time with Doctor\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW\n\n\n\n8.1.3.2 The generator_patient_arrivals method\nThis method is unchanged.\n\n\n8.1.3.3 The attend_clinic method\nHere, we need to add in a chance of patients seeing the doctor on their journey.\n\ndef attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        start_q_nurse = self.env.now\n\n        with self.nurse.request() as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.\n\n        ##NEW\n        ##\n        ## -----------------------------------------------------------\n        ## This is where our new code for seeing the doctor is\n        ## We use conditional logic to determine whether the patient goes\n        ## on to see the doctor or not\n        ## ------------------------------------------------------------\n        #\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        #\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\nLet’s try and understand a bit more about how we trigger the conditional logic.\nLet’s look at the output of the line random.uniform(0,1)\n\nrandom.uniform(0,1)\n\n0.6394267984578837\n\n\nWhat about if we run it multiple times?\n\nfor i in range(10):\n  print(random.uniform(0,1))\n\n0.025010755222666936\n0.27502931836911926\n0.22321073814882275\n0.7364712141640124\n0.6766994874229113\n0.8921795677048454\n0.08693883262941615\n0.4219218196852704\n0.029797219438070344\n0.21863797480360336\n\n\nSo how does this relate to our code?\nIn our g class, we set a probability threshold for patients being seen. Let’s pull that out:\n\nprint(g.prob_seeing_doctor)\n\n0.6\n\n\nThe code in the Model class tests whether the number generated by the random number generator is below the threshold we’ve set of seeing the doctor. If it is, the indented code where we actually see the doctor will be run for that patient. If it is not, that bit is bypassed - which in this case means they’ve reached the end of their journey and leave the system (a sink).\n\nfor i in range(10):\n  random_number = random.uniform(0,1)\n  is_below_threshold = random_number &lt; g.prob_seeing_doctor\n\n  if is_below_threshold:\n    print(f\"Random number {random_number:.2f} is LOWER than threshold ({g.prob_seeing_doctor}). \" +\n    \"Doctor code is triggered.\")\n  else:\n    print(f\"Random number {random_number:.2f} is HIGHER than threshold ({g.prob_seeing_doctor}). \" +\n    \"Doctor code is **not** triggered.\")\n\nRandom number 0.51 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.03 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.20 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.65 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\nRandom number 0.54 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.22 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.59 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.81 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\nRandom number 0.01 is LOWER than threshold (0.6). Doctor code is triggered.\nRandom number 0.81 is HIGHER than threshold (0.6). Doctor code is **not** triggered.\n\n\nIf we run this code a hundred thousand times and plot the results, we can start to see the pattern emerging despite the random element of the number generator.\n\nimport plotly.express as px\nimport pandas as pd\nimport numpy as np\n\nrandom_vals = [random.uniform(0,1) for i in range(100000)]\n\nrandom_vals_df = pd.DataFrame({\"value\" :random_vals})\n\nrandom_vals_df['threshold'] = np.where(random_vals_df[\"value\"]&lt;0.6, 'below', 'above')\n\nfig = px.histogram(random_vals_df, color=\"threshold\")\n\nfig.update_traces(xbins=dict(\n        start=0.0,\n        end=1.0,\n        size=0.1\n    ),\n    marker_line_width=1,marker_line_color=\"black\")\n\n\nfig.show()\n\n                                                \n\n\nSo for every 1000 patients, roughly 600 will see a doctor, and roughly 400 will leave the system straight after seeing the nurse.\n\n\n8.1.3.4 The calculate_run_results method\nIn this method, we just add an additional step to measure the mean time spent queueing for a doctor across all patients in this run.\n\n# This method calculates results over a single run.  Here we just calculate\n# a mean, but in real world models you'd probably want to calculate more.\ndef calculate_run_results(self):\n    # Take the mean of the queuing times across patients in this run of the\n    # model.\n    self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n    self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean() ##NEW\n\n\n\n8.1.3.5 The run method\nThe run method is unchanged\n\n\n\n8.1.4 The trial class\n\n8.1.4.1 The init method\nIn the init method, we just add a placeholder for measuring the mean queue time of a doctor.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n8.1.4.2 The run_trial method\nHere, we just add in the mean queue time for the doctor to the trial results dataframe.\n\n  def run_trial(self):\n      # Run the simulation for the number of runs specified in g class.\n      # For each run, we create a new instance of the Model class and call its\n      # run method, which sets everything else in motion.  Once the run has\n      # completed, we grab out the stored run results (just mean queuing time\n      # here) and store it against the run number in the trial results\n      # dataframe.\n      for run in range(g.number_of_runs):\n          my_model = Model(run)\n          my_model.run()\n\n          ##NEW - added mean queue time for doctor to end of list\n          self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                            my_model.mean_q_time_nurse,\n                                            my_model.mean_q_time_doctor]\n\n      # Once the trial (ie all runs) has completed, print the final results\n      self.print_trial_results()",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "an_example_simpy_model_branching.html#evaluating-the-outputs",
    "href": "an_example_simpy_model_branching.html#evaluating-the-outputs",
    "title": "8  Adding Branching Paths",
    "section": "8.2 Evaluating the outputs",
    "text": "8.2 Evaluating the outputs\nBelow is the full updated code for this model.\n\n\n\n\n\n\nClick here to view the code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20 ##NEW\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2 ##NEW\n    prob_seeing_doctor = 0.6 ##NEW\n    sim_duration = 120\n    number_of_runs = 1\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0 ##NEW\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors) ##NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0] ##NEW\n        self.results_df[\"Time with Doctor\"] = [0.0] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        ##NEW added conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean() ##NEW\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - added mean queue time for doctor to end of list\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse,\n                                              my_model.mean_q_time_doctor]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\nLet’s look at the outputs for a single run.\nWhen a patient doesn’t see a doctor, notice that their value for that row is NaN - which stands for “not a number”. This will be treated differently to 0 in calculations of the mean - i.e. it won’t be included at all, whereas a queue time of 0 will matter.\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse  \\\nPatient ID                                                                 \n1               0.000000         0.164455      0.000000        13.920914   \n2               0.000000         0.517079     12.717109         7.064436   \n3               0.000000         3.507019     13.651053         2.107220   \n4               1.791675         1.914879     13.843393         4.172893   \n5               2.942190         7.578821     10.437466         3.408435   \n6               0.000000         0.137868      5.492462         0.770591   \n7               0.000000         0.038824      4.238580         2.573929   \n8               0.000000         4.497553      0.000000         3.634398   \n9               0.632419         1.127904      2.506494        10.751089   \n10              0.000000         1.827010      9.859928         2.064096   \n11              0.000000         2.691982      0.000000         5.879487   \n12              0.000000         4.235160      0.000000         4.587604   \n13              0.677981         0.348057      4.239547         0.455397   \n14              0.000000         0.286387      0.000000        18.738572   \n15              0.000000         2.380793      0.000000        16.075224   \n16              1.274408         0.609359     15.465865         5.910793   \n17              0.335087         0.758238           NaN              NaN   \n18              0.000000         1.659091           NaN              NaN   \n19              1.568443         0.213691           NaN              NaN   \n20              0.074793         1.532815           NaN              NaN   \n21              0.000000         2.175654           NaN              NaN   \n\n            Q Time Doctor  Time with Doctor  \nPatient ID                                   \n1                0.000000          0.337148  \n2                0.000000         20.124791  \n3                0.000000         10.157277  \n4                5.984384         10.343443  \n5               10.436243          6.464671  \n6                     NaN               NaN  \n7                     NaN               NaN  \n8                0.000000         39.116816  \n9                0.000000         30.225136  \n10                    NaN               NaN  \n11                    NaN               NaN  \n12              14.854357          5.365691  \n13              16.258368          2.616966  \n14               0.000000          9.841665  \n15               0.000000          5.992586  \n16                    NaN               NaN  \n17                    NaN               NaN  \n18                    NaN               NaN  \n19                    NaN               NaN  \n20                    NaN               NaN  \n21                    NaN               NaN  \nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                          \n0                    0.442714           5.778244            4.321214",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Adding Branching Paths</span>"
    ]
  },
  {
    "objectID": "exercise_gp.html",
    "href": "exercise_gp.html",
    "title": "9  Exercise - Building Your First Model",
    "section": "",
    "text": "9.1 Required outputs\nThe surgery is only interested in queuing times for each of the queues in the system (you don’t need to worry about storing sampled activity times for example), but they would like to look at the results for patients and callers separately. You should give them mean results as a minimum, but you may consider providing additional results too.\nYou also need to calculate and provide them with the mean queuing times across the trial (eg mean queue for registration across all runs, for GP etc - so four numbers that you would report). You’ll need a new method in your Trial class to calculate this. You should find this a helpful output, as it’ll help you compare scenarios easily. Report these means to 1 decimal place.",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Exercise - Building Your First Model</span>"
    ]
  },
  {
    "objectID": "exercise_gp.html#goal",
    "href": "exercise_gp.html#goal",
    "title": "9  Exercise - Building Your First Model",
    "section": "9.2 Goal",
    "text": "9.2 Goal\nOnce you’ve built the model, use it to - a) identify where you think the problem is - b) provide proposals for how you would fix it (this can include anything you like - they are open to suggestions - more resources, changes to processes to cut activity times, having the GP book the test, anything you can think of!\nTry different things, different solutions.\n\n\n\n\n\n\nTip\n\n\n\nTake a copy of the original working file for the base case scenario first :)",
    "crumbs": [
      "Part 2 - Your First SimPy Model",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Exercise - Building Your First Model</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html",
    "href": "model_warm_up.html",
    "title": "10  Warm Up Periods",
    "section": "",
    "text": "10.1 How long should a warm-up period be?\nThe length of the warm up period is up to you as the modeller to define.\nYou could be very precise about analysing it and use statistical testing to identify when the system reaches equilibrium (see https://eudl.eu/pdf/10.4108/ICST.SIMUTOOLS2009.5603 as an example).\nOr you could plot what’s happening over time by eye and make an estimate.\nOr you could just set your warm up period long enough that it’ll be representative when it starts collecting results.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html#implementing-the-warm-up-period",
    "href": "model_warm_up.html#implementing-the-warm-up-period",
    "title": "10  Warm Up Periods",
    "section": "10.2 Implementing the warm-up period",
    "text": "10.2 Implementing the warm-up period\nImplementing a warm up period in SimPy is really easy.\nWe just simply check the current time whenever we go to calculate / store a result, and see if it’s beyond the warm up period. If it is, we do it. If it’s not, we don’t.\nLet’s look at an example. This is a slightly amended version of the model of patients coming in for a nurse consultation with a few tweaks (longer duration, more runs, added trial results calculation)\nWe’re going to assume this is a system that’s open 24 hours - let’s imagine this is a triage function at an emergency department.\nI’ve marked the bits I’ve added to include warm up with ##NEW\n\n10.2.1 The g class\nFirst we add in a new parameter - the length of the warm-up period.\nHere, the sim duration has been set to 2880, and the warm-up-period to half of this (1440). You don’t need to stick to this pattern - your warm-up could even be longer than your results collection if you want!\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    warm_up_period = 1440 ##NEW - this will be in addition to the sim_duration\n    number_of_runs = 100\n\n\n\n\n\n\n\nTip\n\n\n\nIf you find it easier to keep track of, you could define your warm-up like this instead.\n\nresults_collection_period = 2880\nwarm_up_period = 1440\ntotal_sim_duration = results_collection_period + warm_up_period\n\n\n\n\n\n10.2.2 The patient class\nOur patient class is unchanged.\n\n\n10.2.3 The model class\nIn the model class, the ‘attend_clinic’ method changes.\nWe look at the current elapsed simulation time with the attribute self.env.now\nThen, whenever a patient attends the clinic and is using a nurse resource, we check whether the current simulation time is later than the number of time units we’ve set as our warm-up.\n\n10.2.3.1 The attend_clinic method\n\n# Generator function representing pathway for patients attending the\n# clinic.\ndef attend_clinic(self, patient):\n    # Nurse consultation activity\n    start_q_nurse = self.env.now\n\n    with self.nurse.request() as req:\n        yield req\n\n        end_q_nurse = self.env.now\n\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        ##NEW - this checks whether the warm up period has passed before\n        # adding any results\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse\n            )\n\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        yield self.env.timeout(sampled_nurse_act_time)\n\nFor example, if the simulation time is at 840 and our warm_up is 1440, this bit of code - which adds the queuing time for this patient to our records - won’t run:\n\nself.results_df.at[patient.id, \"Q Time Nurse\"] = (\n    patient.q_time_nurse\n)\n\nHowever, if the simulation time is 1680, for example, it will.\n\n\n\n10.2.4 the calculate_run_results method\nAs we now won’t count the first patient, we need to remove the dummy first patient result entry we created when we set up the dataframe.\n\n# Method to calculate and store results over the run\ndef calculate_run_results(self):\n    self.results_df.drop([1], inplace=True) ##NEW\n\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n\n10.2.4.1 The run method\nNext we need to tweak the duration of our model to reflect the combination of the period we want to collect results for and the warm-up period.\n\n# Method to run a single run of the simulation\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    ##NEW - we need to tell the simulation to run for the specified duration\n    # + the warm up period if we still want the specified duration in full\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Print patient level results for this run\n    print (f\"Run Number {self.run_number}\")\n    print (self.results_df)\n\n\n\n\n10.2.5 The Trial class\nOur trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "model_warm_up.html#the-impact-of-the-warm-up-period",
    "href": "model_warm_up.html#the-impact-of-the-warm-up-period",
    "title": "10  Warm Up Periods",
    "section": "10.3 The impact of the warm-up period",
    "text": "10.3 The impact of the warm-up period\nLet’s compare the results we get with and without the warm-up period.\n\n10.3.1 Editing our results method\nTo make it easier to look at the outputs, I’m going to modify two methods slightly.\nFirst, we modify the run method of the Model class slightly to swap from print the patient level dataframes to returning them as an output.\n\n# Method to run a single run of the simulation\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    # We need to tell the simulation to run for the specified duration\n    # + the warm up period if we still want the specified duration in full\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Return patient level results for this run\n    return (self.results_df) ##NEW\n\nNext, we modify the run_trial method of the Trial class so that we get multiple outputs: the full patient level dataframes, a summary of results per trial, and an overall average figure for all of the trials.\n\n# Method to run a trial\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results and store it against\n    # the run number in the trial results dataframe. We also return the\n    # full patient-level dataframes.\n\n    # First, create an empty list for storing our patient-level dataframes.\n    results_dfs = []\n\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        patient_level_results = my_model.run()\n\n        print( self.df_trial_results)\n        # First let's record our mean wait time for this run\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Next let's work on our patient-level results dataframes\n        # We start by rounding everything to 2 decimal places\n        patient_level_results = patient_level_results.round(2)\n        # Add a new column recording the run\n        patient_level_results['run'] = run\n        # Now we're just going to add this to our empty list (or, after the first\n        # time we loop through, as an extra dataframe in our list)\n        results_dfs.append(patient_level_results)\n\n    all_results_patient_level = pd.concat(results_dfs)\n\n    # This calculates the attribute self.mean_q_time_nurse_trial\n    self.calculate_means_over_trial()\n\n    # Once the trial (ie all runs) has completed, return the results\n    return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n\n\n10.3.2 The full updated code\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 20\n    warm_up_period = 1440 ##NEW - this will be in addition to the sim_duration\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request() as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            ##NEW - this checks whether the warm up period has passed before\n            # adding any results\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        ##NEW - as we now won't count the first patient, we need to remove\n        # the dummy first patient result entry we created when we set up the\n        # dataframe\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        ##NEW - we need to tell the simulation to run for the specified duration\n        # + the warm up period if we still want the specified duration in full\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Return patient level results for this run\n        return (self.results_df)\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            print( self.df_trial_results)\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        # EDIT: We are omitting the printouts of the patient level data for now\n        # print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\ndf_trial_results_warmup, all_results_patient_level_warmup, means_over_trial_warmup = my_trial.run_trial()\n\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0\n            Mean Q Time Nurse\nRun Number                   \n0                   558.35894\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n14                 287.580146\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n14                 287.580146\n15                 409.656129\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n14                 287.580146\n15                 409.656129\n16                 470.974861\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n14                 287.580146\n15                 409.656129\n16                 470.974861\n17                 414.221186\n            Mean Q Time Nurse\nRun Number                   \n0                  558.358940\n1                  532.836085\n2                  573.793462\n3                  514.403025\n4                  650.898540\n5                  708.572653\n6                  534.451051\n7                  788.070492\n8                  470.513114\n9                  574.494761\n10                 501.143276\n11                 274.530241\n12                 421.316123\n13                 147.724029\n14                 287.580146\n15                 409.656129\n16                 470.974861\n17                 414.221186\n18                 428.326850\n\n\n\n\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0\n            Mean Q Time Nurse\nRun Number                   \n0                   453.87631\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n14                 458.299809\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n14                 458.299809\n15                 155.912617\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n14                 458.299809\n15                 155.912617\n16                 396.600735\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n14                 458.299809\n15                 155.912617\n16                 396.600735\n17                 299.698574\n            Mean Q Time Nurse\nRun Number                   \n0                  453.876310\n1                  326.485097\n2                  277.173787\n3                  431.625011\n4                  424.078108\n5                  439.360470\n6                  599.350969\n7                  281.765501\n8                  220.470619\n9                  231.750147\n10                 474.888494\n11                 330.704468\n12                 544.701185\n13                 441.875151\n14                 458.299809\n15                 155.912617\n16                 396.600735\n17                 299.698574\n18                 391.710019\n\n\n\n\n10.3.3 Comparing the results\n\n10.3.3.1 Patient-level dataframes\nFirst, let’s look at the first five rows of our patient dataframes.\nWithout the warm-up, our patient IDs start at 1.\n\n10.3.3.1.1 Without warm-up\n\nall_results_patient_level.head()\n\n\n\n\n\n\n\n\n\nQ Time Nurse\nTime with Nurse\nrun\n\n\nPatient ID\n\n\n\n\n\n\n\n1\n0.00\n1.45\n0\n\n\n2\n0.00\n4.22\n0\n\n\n3\n2.91\n3.55\n0\n\n\n4\n5.25\n6.45\n0\n\n\n5\n11.63\n5.47\n0\n\n\n\n\n\n\n\n\n\n\n10.3.3.1.2 With warm-up\nWith the warm-up, our patient IDs start later.\n\nall_results_patient_level_warmup.head()\n\n\n\n\n\n\n\n\n\nQ Time Nurse\nrun\n\n\nPatient ID\n\n\n\n\n\n\n235\n330.72\n0\n\n\n236\n329.23\n0\n\n\n237\n327.73\n0\n\n\n238\n322.11\n0\n\n\n239\n325.53\n0\n\n\n\n\n\n\n\n\n\n\n\n10.3.3.2 Per-run results\n\n10.3.3.2.1 Without warm-up\n\ndf_trial_results.round(2).head()\n\n\n\n\n\n\n\n\n\nMean Q Time Nurse\n\n\nRun Number\n\n\n\n\n\n0\n453.88\n\n\n1\n326.49\n\n\n2\n277.17\n\n\n3\n431.63\n\n\n4\n424.08\n\n\n\n\n\n\n\n\n\n\n10.3.3.2.2 With warm-up\nWith the warm-up, our patient IDs start later.\n\ndf_trial_results_warmup.round(2).head()\n\n\n\n\n\n\n\n\n\nMean Q Time Nurse\n\n\nRun Number\n\n\n\n\n\n0\n558.36\n\n\n1\n532.84\n\n\n2\n573.79\n\n\n3\n514.40\n\n\n4\n650.90\n\n\n\n\n\n\n\n\n\n\n\n10.3.3.3 Overall results\nWithout the warm up, our overall average wait time is\n\n\n'376.51 minutes'\n\n\nWith the warm up, our overall average wait time is\n\n\n'489.0 minutes'\n\n\nYou can see overall that the warm-up time can have a very significant impact on our waiting times!\nLet’s look at this in a graph.\n\n\n10.3.3.4 Results over time\n\nimport plotly.express as px\n\ndf_trial_results = df_trial_results.reset_index()\ndf_trial_results['Warm Up'] = 'No Warm Up'\n\ndf_trial_results_warmup = df_trial_results_warmup.reset_index()\ndf_trial_results_warmup['Warm Up'] = 'With Warm Up'\n\nfig = px.histogram(\n    pd.concat([df_trial_results, df_trial_results_warmup]).round(2).reset_index(),\n    x=\"Warm Up\",\n    color=\"Run Number\", y=\"Mean Q Time Nurse\",\n    barmode='group',\n    title='Average Queue Times per Run - With and Without Warmups')\n\nfig.show()",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Warm Up Periods</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html",
    "href": "priority_based_queueing.html",
    "title": "11  Priority-Based Queueing",
    "section": "",
    "text": "11.1 Implementing priority-based queueing",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#implementing-priority-based-queueing",
    "href": "priority_based_queueing.html#implementing-priority-based-queueing",
    "title": "11  Priority-Based Queueing",
    "section": "",
    "text": "11.1.1 g class\nThe g class is unchanged\n\n\n11.1.2 Patient class\nHere we add an attribute of the patient that determines their priority :::{.callout-tip} When using a priority resource\nLower value = higher priority :::\nIn this example, we just randomly pick a value between 1 and 5, but you can use whatever logic you like.\nIn reality, you’d likely have probabilities to determine what priority a patient is based on your data - maybe there’s a 20% chance they are a high priority and an 80% chance they are a low priority.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        ##NEW\n        self.priority = random.randint(1,5)\n\n\n\n11.1.3 Model class\n\n11.1.3.1 _init\nHere we set up the nurse as an instance of PriorityResource rather than Resource\n\ndef __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        ##NEW\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Priority\"] = [1] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n\n\n11.1.3.2 attend_clinic\nNear the beginning of the attend_clinic() method, we have added a print message so we can see how priority works.\n\n\n\n\n\n\nTip\n\n\n\nLogging in this way can help you check that your model is behaving as expected.\n\n\nNow that the nurse is set up as a PriorityResource, we can pass in the value that we want it to look at to determine who’s seen next when we request the resource (here, that’s the priority attribute of the patient we set up in the Patient class).\nWe have also added a step that records the patient priority to our dataframe of individual patient results.\n\n# Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        ##NEW\n        print (f\"Patient {patient.id} with priority {patient.priority} is\",\n               \"queuing for the nurse.\")\n\n        ##NEW\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            ##NEW\n            print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                   f\"being seen at minute {self.env.now}.\")\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n                ##NEW\n                self.results_df.at[patient.id, \"Priority\"] = (\n                    patient.priority\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n\n\n\n11.1.4 Trial class\nThe trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#the-full-code",
    "href": "priority_based_queueing.html#the-full-code",
    "title": "11  Priority-Based Queueing",
    "section": "11.2 The full code",
    "text": "11.2 The full code\nThe full code is given below.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - We've changed the parameters to have no warm-up\n    # Simulation meta parameters\n    sim_duration = 5000\n    number_of_runs = 1\n    warm_up_period = 0\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        ##NEW - here we add an attribute of the patient that determines their\n        # priority (lower value = higher priority).  In this example, we just\n        # randomly pick a value between 1 and 5, but you can use whatever logic\n        # you like (in reality, you'd likely have probabilities to determine\n        # what priority a patient is based on your data)\n        self.priority = random.randint(1,5)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        ##NEW - here we set up the nurse as an instance of PriorityResource\n        # rather than Resource\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Priority\"] = [1] ##NEW\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        ##NEW - added a print message so we can see how priority works\n        # I'm limiting it to the first 10 patients so we're not swamped by outputs!\n        if patient.id &lt;= 10:\n            print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                \"queuing for the nurse.\")\n\n        ##NEW - now that the nurse is set up as a PriorityResource, we can pass\n        # in the value that we want it to look at to determine who's seen next\n        # when we request the resource (here, that's the priority attribute of\n        # the patient we set up in the Patient class)\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            ##NEW - added a print message so we can see how priority works\n            # I'm limiting it to the first 10 patients so we're not swamped by outputs!\n            if patient.id &lt;= 10:\n                print (f\"Patient {patient.id} with priority {patient.priority} is\",\n                    f\"being seen at minute {self.env.now}\")\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n                self.results_df.at[patient.id, \"Priority\"] = (\n                    patient.priority\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        return self.results_df\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            print( self.df_trial_results)\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\ndf_trial_results, all_results_patient_level, means_over_trial  = my_trial.run_trial()\n\nPatient 1 with priority 2 is queuing for the nurse.\nPatient 1 with priority 2 is being seen at minute 0\nPatient 2 with priority 3 is queuing for the nurse.\nPatient 3 with priority 2 is queuing for the nurse.\nPatient 3 with priority 2 is being seen at minute 4.051975397099871\nPatient 2 with priority 3 is being seen at minute 8.128634916663529\nPatient 4 with priority 4 is queuing for the nurse.\nPatient 4 with priority 4 is being seen at minute 28.847854140820342\nPatient 5 with priority 3 is queuing for the nurse.\nPatient 5 with priority 3 is being seen at minute 30.76666370584145\nPatient 6 with priority 1 is queuing for the nurse.\nPatient 6 with priority 1 is being seen at minute 36.941199725353464\nPatient 7 with priority 4 is queuing for the nurse.\nPatient 8 with priority 5 is queuing for the nurse.\nPatient 9 with priority 1 is queuing for the nurse.\nPatient 9 with priority 1 is being seen at minute 42.92519458134357\nPatient 7 with priority 4 is being seen at minute 44.62292686834568\nPatient 10 with priority 2 is queuing for the nurse.\nPatient 10 with priority 2 is being seen at minute 45.926265404259155\nPatient 8 with priority 5 is being seen at minute 47.24540527647517\n            Mean Q Time Nurse\nRun Number                   \n0                         0.0",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "priority_based_queueing.html#evaluating-the-outputs",
    "href": "priority_based_queueing.html#evaluating-the-outputs",
    "title": "11  Priority-Based Queueing",
    "section": "11.3 Evaluating the outputs",
    "text": "11.3 Evaluating the outputs\nFirst let’s look at some sample patients.\n\nall_results_patient_level.head()\n\n\n\n\n\n\n\n\n\nQ Time Nurse\nPriority\nrun\n\n\nPatient ID\n\n\n\n\n\n\n\n1\n0.00\n1.0\n0\n\n\n3\n2.60\n2.0\n0\n\n\n2\n7.59\n3.0\n0\n\n\n4\n0.00\n4.0\n0\n\n\n5\n0.00\n3.0\n0\n\n\n\n\n\n\n\n\nLet’s calculate the mean queue time by priority.\n\n(all_results_patient_level\n    .groupby('Priority')\n    .agg({'Priority':'size', 'Q Time Nurse':'mean'}) \\\n    .rename(columns={'Priority':'count','Q Time Nurse':'mean queue time'})\n    .round(2)\n    )\n\n\n\n\n\n\n\n\n\ncount\nmean queue time\n\n\nPriority\n\n\n\n\n\n\n1.0\n166\n7.66\n\n\n2.0\n201\n12.84\n\n\n3.0\n196\n27.68\n\n\n4.0\n202\n115.01\n\n\n5.0\n90\n1037.86\n\n\n\n\n\n\n\n\nWe can see that the queueing time is shorter for the clients with a lower priority value (and therefore a higher actual priority in terms of the model - i.e. they will be seen first)\n\nRemember that we are only recording the queue time at the point at which someone exits the queue to be seen by a nurse.\nThis means that there may be lots of people - particularly those with a higher priority number (and therefore the least important to see as far as the model is concerned) who are still sitting waiting to be seen when our model stops running.\nThink about ways you might try to account for that.\n\n\nimport plotly.express as px\n\nfig = px.box(all_results_patient_level.reset_index(), x=\"Priority\", y=\"Q Time Nurse\", points=\"all\")\nfig.show()",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Priority-Based Queueing</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html",
    "href": "modelling_resource_unavailability.html",
    "title": "12  Modelling Resource Unavailability",
    "section": "",
    "text": "12.1 The approach\nBasically, we will : - Set up the frequency and duration of unavailability as parameter values in g class - Make sure that the nurse is set up as a PriorityResource - Create a new entity generator whose sole purpose is to demand the nurse resource with a higher priority than any patient every 2 hours, and will freeze the nurse with them for 15 minutes (this means the nurse will complete the current patient, they won’t walk out midway through!) - Start this new generator running in our run method of the Model class.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#coding-the-approach",
    "href": "modelling_resource_unavailability.html#coding-the-approach",
    "title": "12  Modelling Resource Unavailability",
    "section": "12.2 Coding the approach",
    "text": "12.2 Coding the approach\n\n12.2.1 The g class\nIn the g class, we have added values to specify how long nurse is unavailable and at what frequency. Un this example, every 2 hours, the nurse will be unavailable for 15 minutes.\n\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    unav_time_nurse = 15 ##NEW\n    unav_freq_nurse = 120 ##NEW\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n\n\n\n12.2.2 The Patient class\nThe patient class is unchanged.\n\n\n12.2.3 The Model class\n\n12.2.3.1 The obstruct_nurse method\nWe create a new method within the model class called obstruct_nurse.\n\n\n\n\n\n\nTip\n\n\n\nNote that here we are using a priority value of -1.\nNegative priorities are higher (i.e. are seen first) compared to higher priorities; a priority value of -1 will be seen before a priority value of 1, but a priority value of 1 will be seen before a priority value of 2.\nThis is a very helpful feature to use to keep your breaktime functions from clashing with high-priority patients.\n\n\n\n##NEW\n# Generator function to obstruct a nurse resource at specified intervals\n# for specified amounts of time\ndef obstruct_nurse(self):\n    while True:\n        print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n        # The generator first pauses for the frequency period\n        yield self.env.timeout(g.unav_freq_nurse)\n\n        # Once elapsed, the generator requests (demands?) a nurse with\n        # a priority of -1.  This ensure it takes priority over any patients\n        # (whose priority values start at 1).  But it also means that the\n        # nurse won't go on a break until they've finished with the current\n        # patient\n        with self.nurse.request(priority=-1) as req:\n            yield req\n\n            print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                    f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n            # Freeze with the nurse held in place for the unavailability\n            # time (ie duration of the nurse's break).  Here, both the\n            # duration and frequency are fixed, but you could randomly\n            # sample them from a distribution too if preferred.\n            yield self.env.timeout(g.unav_time_nurse)\n\n\n\n12.2.3.2 The run method\nIn our run method, we now start up the obstruct_nurse process in addition to the generator_patient_arrivals process.\n\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n    ##NEW - we also need to start up the obstructor generator now too\n    self.env.process(self.obstruct_nurse())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    return self.results_df\n\n\n\n\n12.2.4 The Trial class\nThe trial class is unchanged.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "modelling_resource_unavailability.html#evaluating-the-outputs",
    "href": "modelling_resource_unavailability.html#evaluating-the-outputs",
    "title": "12  Modelling Resource Unavailability",
    "section": "12.3 Evaluating the outputs",
    "text": "12.3 Evaluating the outputs\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - added values to specify how long nurse is unavailable and at what\n    # frequency (in this example, every 2 hours, the nurse will be unavailable\n    # for 15 minutes)\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        random.seed(42)\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    ##NEW\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                   f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                       f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        ##NEW - we also need to start up the obstructor generator now too\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        return self.results_df\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\nLet’s look at the printed output showing when our nurses were obstructed.\nThe first number in each line of output shows the simulation time when the message was generated.\n\n\n0.00: The nurse will go on a break at around time 120.00\n120.15: The nurse is now on a break and will be back at 135.15\n135.15: The nurse will go on a break at around time 255.15\n258.44: The nurse is now on a break and will be back at 273.44\n273.44: The nurse will go on a break at around time 393.44\n404.26: The nurse is now on a break and will be back at 419.26\n419.26: The nurse will go on a break at around time 539.26\n540.82: The nurse is now on a break and will be back at 555.82\n555.82: The nurse will go on a break at around time 675.82\n680.63: The nurse is now on a break and will be back at 695.63\n695.63: The nurse will go on a break at around time 815.63\n827.06: The nurse is now on a break and will be back at 842.06\n842.06: The nurse will go on a break at around time 962.06\n968.91: The nurse is now on a break and will be back at 983.91\n983.91: The nurse will go on a break at around time 1103.91\n1106.20: The nurse is now on a break and will be back at 1121.20\n1121.20: The nurse will go on a break at around time 1241.20\n1242.30: The nurse is now on a break and will be back at 1257.30\n1257.30: The nurse will go on a break at around time 1377.30\n1389.51: The nurse is now on a break and will be back at 1404.51\n1404.51: The nurse will go on a break at around time 1524.51\n1532.18: The nurse is now on a break and will be back at 1547.18\n1547.18: The nurse will go on a break at around time 1667.18\n1672.09: The nurse is now on a break and will be back at 1687.09\n1687.09: The nurse will go on a break at around time 1807.09\n1807.86: The nurse is now on a break and will be back at 1822.86\n1822.86: The nurse will go on a break at around time 1942.86\n1947.64: The nurse is now on a break and will be back at 1962.64\n1962.64: The nurse will go on a break at around time 2082.64\n2084.27: The nurse is now on a break and will be back at 2099.27\n2099.27: The nurse will go on a break at around time 2219.27\n2221.93: The nurse is now on a break and will be back at 2236.93\n2236.93: The nurse will go on a break at around time 2356.93\n2359.05: The nurse is now on a break and will be back at 2374.05\n2374.05: The nurse will go on a break at around time 2494.05\n2494.42: The nurse is now on a break and will be back at 2509.42\n2509.42: The nurse will go on a break at around time 2629.42\n2635.29: The nurse is now on a break and will be back at 2650.29\n2650.29: The nurse will go on a break at around time 2770.29\n2776.28: The nurse is now on a break and will be back at 2791.28\n2791.28: The nurse will go on a break at around time 2911.28\n2911.72: The nurse is now on a break and will be back at 2926.72\n2926.72: The nurse will go on a break at around time 3046.72\n3050.18: The nurse is now on a break and will be back at 3065.18\n3065.18: The nurse will go on a break at around time 3185.18\n3203.13: The nurse is now on a break and will be back at 3218.13\n3218.13: The nurse will go on a break at around time 3338.13\n3350.63: The nurse is now on a break and will be back at 3365.63\n3365.63: The nurse will go on a break at around time 3485.63\n3486.03: The nurse is now on a break and will be back at 3501.03\n3501.03: The nurse will go on a break at around time 3621.03\n3623.49: The nurse is now on a break and will be back at 3638.49\n3638.49: The nurse will go on a break at around time 3758.49\n3768.95: The nurse is now on a break and will be back at 3783.95\n3783.95: The nurse will go on a break at around time 3903.95\n3908.67: The nurse is now on a break and will be back at 3923.67\n3923.67: The nurse will go on a break at around time 4043.67\n4045.96: The nurse is now on a break and will be back at 4060.96\n4060.96: The nurse will go on a break at around time 4180.96\n4184.07: The nurse is now on a break and will be back at 4199.07\n4199.07: The nurse will go on a break at around time 4319.07\n\n\nNow let’s look at some of the other outputs and compare them with a version without the nurse obstruction.\nNow let’s look at some of the other outputs and compare them with a version without the nurse obstruction.\n\n\nThe average wait when there are no nurse breaks is 143.18 minutes\n\n\n\n\nThe average wait when there are nurse breaks is 299.7 minutes",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modelling Resource Unavailability</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html",
    "href": "choosing_distributions.html",
    "title": "13  Choosing Distributions",
    "section": "",
    "text": "13.1 A bit of background",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Choosing Distributions</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#a-bit-of-background",
    "href": "choosing_distributions.html#a-bit-of-background",
    "title": "13  Choosing Distributions",
    "section": "",
    "text": "Tip\n\n\n\nThe good news is that we will be using some prewritten code to specify our lognormal, and all we will need to know to do this is the mean (average) time for our activity, and the standard deviation (a measure of how much the times vary across the dataset that python can calculate for us if given a list of activity times).\nHowever - it’s useful to have a bit more of an idea about what a lognormal is - so do have a read of the section below, but if you don’t quite get it just yet, don’t fret - just remember that lognormal is good for activity times in general, and the exponential distribution is good for inter-arrival times (the time between patients arriving).\n\n\n\n13.1.1 The normal distribution\nA normal distribution is a bell shaped curve that is symmetrical. It is defined by two parameters : μ (Mu) and σ (Sigma), which represent the mean and standard deviation of the distribution. So it’s easy to plug in such values from our own data.\n\n\n\n13.1.2 Logarithms\nBefore we proceed, let’s remind ourselves about something many of us learned at school (and then promptly forgot) : Logarithms.\nLogarithms are basically the opposite of exponentials.\nEffectively, lognormals relate to how many copies of one number multiply together to make another number.\nHow many 4s multiply together to make 64?\n4 x 4 x 4 = 64 We had to multiply 3 copies of the number 4 to get 64.\nThis means that the logarithm is 3.\nWe’d write this as \\[\nY = log_4(64) = 3\n\\]\n\n\n13.1.3 Bringing it all together - lognormal distributions\nHow does this relate to the distribution?\nWell, a Lognormal distribution is one in which the logarithm of the random variable we’re modelling is normally distributed.\nThis means that the the two parameters μ (Mu) and σ (Sigma) used to specify a Lognormal distribution do not represent the mean and standard deviation, unlike the normal distribution; rather, they represent what are known as the location and scale of the distribution respectively.\n\nμ (Mu) and σ (Sigma) represent the mean and standard deviation once the data in the log normal distribution has been transformed using logarithms.\n\nIt’s easy to get the mean and standard deviation of our data.\nIf we used the Normal distribution, we could do that.\n\n\n\n\n\n\nWarning\n\n\n\nThe Normal distribution often isn’t good for activity times - it allows negative values - activity distributions are rarely symmetrical - they’re more likely to be a bit ‘wonky’ (skewed), with just a few activities being much longer\n\n\nThe probalm is we can’t just give a Lognormal distribution the mean and standard deviation, because in a Lognormal distribution, the mean and standard deviation of our data is represented in the underlying normal distribution not the Lognormal distribution (remember, it’s the logarithms of the values that are normally distributed).\n\n\n\n\n\n\nTip\n\n\n\nSo what do we do?\nWe need to convert our mean and standard deviation values (that we get from our real world data) into Mu and Sigma for a Lognormal distribution.\nThis is the key bit you need to understand!",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Choosing Distributions</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#code-for-the-lognormal-distribution",
    "href": "choosing_distributions.html#code-for-the-lognormal-distribution",
    "title": "13  Choosing Distributions",
    "section": "13.2 Code for the lognormal distribution",
    "text": "13.2 Code for the lognormal distribution\nThis code was written by Tom Monks.\n\nimport numpy as np\nimport math\n\nclass Lognormal:\n    \"\"\"\n    Encapsulates a lognormal distirbution\n    \"\"\"\n    def __init__(self, mean, stdev, random_seed=None):\n        \"\"\"\n        Params:\n        -------\n        mean = mean of the lognormal distribution\n        stdev = standard dev of the lognormal distribution\n        \"\"\"\n        self.rand = np.random.default_rng(seed=random_seed)\n        mu, sigma = self.normal_moments_from_lognormal(mean, stdev**2)\n        self.mu = mu\n        self.sigma = sigma\n\n    def normal_moments_from_lognormal(self, m, v):\n        '''\n        Returns mu and sigma of normal distribution\n        underlying a lognormal with mean m and variance v\n        source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal\n        -data-with-specified-mean-and-variance.html\n\n        Params:\n        -------\n        m = mean of lognormal distribution\n        v = variance of lognormal distribution\n\n        Returns:\n        -------\n        (float, float)\n        '''\n        phi = math.sqrt(v + m**2)\n        mu = math.log(m**2/phi)\n        sigma = math.sqrt(math.log(phi**2/m**2))\n        return mu, sigma\n\n    def sample(self):\n        \"\"\"\n        Sample from the normal distribution\n        \"\"\"\n        return self.rand.lognormal(self.mu, self.sigma)\n\nWe will add this into our model code.\nThen we just need to make sure we have both a mean and standard deviation (SD) for activity times that we want to represent on Lognormal distributions\nWhen we need to sample an activity time, we create an instance of the Lognormal class with our mean and SD, and call the sample method.\nWe are going to do this in the attend_clinic method of the Model class.\n\ndef attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            ##NEW - we now use a lognormal distribution for the activity time,\n            # so we create an instance of our Lognormal class with the mean\n            # and standard deviations specified in g class, and then sample\n            # from it (we do this in a single line of code here, much as we\n            # did when sampling from the exponential distribution before).\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Choosing Distributions</span>"
    ]
  },
  {
    "objectID": "choosing_distributions.html#additional-distributions",
    "href": "choosing_distributions.html#additional-distributions",
    "title": "13  Choosing Distributions",
    "section": "13.3 Additional distributions",
    "text": "13.3 Additional distributions\nIn fact, there are many different distributions available.\nThe sim-tools package makes it easy to make use of them without having to write lots of classes yourself.\nThe source code for the package can be investigated in its Github Repository.\nTo install the package, run\n\npip install sim-tools\n\nYou can then import a class with\n\nfrom sim_tools.distributions import Exponential\n\nreplacing Exponential with any of the supported distribution classes.\nAn overview of how to use the classes, and of the different distributions included, is embedded below:",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Choosing Distributions</span>"
    ]
  },
  {
    "objectID": "reproducibility.html",
    "href": "reproducibility.html",
    "title": "14  Reproducibility",
    "section": "",
    "text": "14.1 Exploring ways of coding in reproducibility\nThe best place to do this is in our trial class.\nIn our run_trial method within that class, we can set the seed so that it matches the run number.\nThis will ensure each run has a different seed, but that the seed is the same across different runs.\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                          my_model.mean_q_time_nurse,\n                                          my_model.mean_q_time_doctor]\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.print_trial_results()\nLet’s look at the output now.\nLet’s run 100 trials and look at the outputs.\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nNow let’s run 100 trials again. Are the results the same?\nLet’s run 100 trials and look at the outputs.\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nYes!\nNow let’s compare this when we start changing the number of nurses.\nThis is going to change the queue times for nurses and, by extension, for doctors (as people will be turning up to the doctors at different times).\nHowever, the number of arrivals should remain unchanged.\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              105.0               0.48               6.77               51.94\n1              117.0               0.90              89.23               10.82\n2              110.0               1.86              27.21               33.57\n3              115.0               0.92              78.11               55.77\n4              104.0               1.52              46.56               94.60\n...              ...                ...                ...                 ...\n95             127.0               0.62              96.29               69.36\n96             132.0               1.01              54.03               34.93\n97             126.0               2.20              67.00               76.15\n98             152.0               1.67              89.61               10.58\n99             112.0               0.70              22.13               82.26\n\n[100 rows x 4 columns]\nArrivals              120.44\nMean Q Time Recep       1.31\nMean Q Time Nurse      64.46\nMean Q Time Doctor     35.10\ndtype: float64\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              106.0               0.96               0.78               52.59\n1               99.0               0.43               2.29               22.72\n2              116.0               2.96               2.84               93.46\n3              123.0               0.86               1.27               57.58\n4              114.0               2.40               3.53               68.42\n...              ...                ...                ...                 ...\n95             123.0               1.39               3.73               45.02\n96             138.0               0.97               1.95              102.04\n97             116.0               1.33               2.34               24.49\n98             125.0               1.07               1.59               40.84\n99             129.0               1.47               5.90               17.22\n\n[100 rows x 4 columns]\nArrivals              118.39\nMean Q Time Recep       1.23\nMean Q Time Nurse       2.98\nMean Q Time Doctor     53.23\ndtype: float64\nUnfortunately, what we wanted (and needed) to happen, hasn’t.\nInstead, we are seeing that the number of arrivals are changing too.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#exploring-ways-of-coding-in-reproducibility",
    "href": "reproducibility.html#exploring-ways-of-coding-in-reproducibility",
    "title": "14  Reproducibility",
    "section": "",
    "text": "Warning\n\n\n\nThe method shown in this section has limitations - but reading through this section will help you understand more about seeds and why the method in Section 14.2 (“A robust way to ensure controlled randomness”) is better.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis is because of the way random number generation occurs.\nThe order the random numbers are generated in matters - and as the order of events changes (in this case, as we have more nurses, they can see more patients quicker, changing the order that subsequent events happen in).\nLet’s investigate this with two examples.\n\nrandom.seed(42)\n\nprint(f\"1: inter-arrival time 1 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"3: inter-arrival time 2 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"2: reception consult time 1 {random.expovariate(1.0 / g.mean_reception_time):.2f}\")\nprint(f\"4: inter-arrival time 3 {random.expovariate(1.0 / g.patient_inter):.2f}\")\n\n1: inter-arrival time 1 5.10\n3: inter-arrival time 2 0.13\n2: reception consult time 1 0.64\n4: inter-arrival time 3 1.26\n\n\n\nrandom.seed(42)\n\nprint(f\"1: inter-arrival time 1 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"2: inter-arrival time 2 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"4: inter-arrival time 3 {random.expovariate(1.0 / g.patient_inter):.2f}\")\nprint(f\"3: reception consult time  1 {random.expovariate(1.0 / g.mean_reception_time):.2f}\")\n\n1: inter-arrival time 1 5.10\n2: inter-arrival time 2 0.13\n4: inter-arrival time 3 1.61\n3: reception consult time  1 0.51\n\n\nWe can see that the first two inter-arrival times are consistent. However, when we swap the order of generating the next inter-arrival time and generating a length of time for someone to spend with a receptionist, we see that the times are different.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nSo while this method is ok just to ensure that a single output remains consistent when you rerun your analysis, it’s no good for ensuring you’re making good comparisons across different simulation scenarios.\nSo how can we do this?",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reproducibility.html#sec-robust",
    "href": "reproducibility.html#sec-robust",
    "title": "14  Reproducibility",
    "section": "14.2 A robust way to ensure controlled randomness",
    "text": "14.2 A robust way to ensure controlled randomness\nEffectively, we want separate seeds for the random number generator for each separate type of event we are generating random numbers for.\nThis means that we have separate random number streams for the different parts of our process - our inter-arrival times - our consult times - our probabilities\nThe easiest way to implement this is to switch from using the random library to using the distributions provided in simtools.\nWe will replace random.expovariate with the Exponential class.\nFirst, we need to import this class.\n\nfrom sim_tools.distributions import Exponential\n\nWe now set up the distributions when initialising the model.\n\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        ##NEW - initialise distributions\n        self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(mean = g.mean_reception_time, random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(mean = g.mean_d_consult_time, random_seed = self.run_number*5)\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that the value we pass to initialise the Exponential variable here is just the mean time.\nWhen we were using random.expovariate, we passed 1 dividided by the mean time.\n\n\nNext, everywhere we have previously used random.expovariate, we replace this with the .sample() method of our newly initialised distributions.\nFor example\n\nsampled_doctor_act_time = random.expovariate(\n    1.0 / g.mean_d_consult_time\n)\n\nbecomes\n\nsampled_doctor_act_time = self.doctor_consult_time_dist.sample()\n\nLet’s update all the code and run our previous experiment again.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Exponential ##NEW\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        )\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(\n            self.env, capacity=g.number_of_doctors)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.patient_inter, random_seed = self.run_number*2)\n        self.patient_reception_time_dist = Exponential(mean = g.mean_reception_time, random_seed = self.run_number*3)\n        self.nurse_consult_time_dist = Exponential(mean = g.mean_n_consult_time, random_seed = self.run_number*4)\n        self.doctor_consult_time_dist = Exponential(mean = g.mean_d_consult_time, random_seed = self.run_number*5)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample() ##NEW\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = self.patient_reception_time_dist.sample() ##NEW\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = self.nurse_consult_time_dist.sample() ##NEW\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = self.nurse_consult_time_dist.sample() ##NEW\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        return (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results.round(2))\n        print(self.df_trial_results.mean().round(2))\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\") ## NEW\n        print(\"\") ## NEW: Print a blank line\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n14.2.1 Evaluating the outputs\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00              57.19                1.15\n1              125.0               1.84             144.69                0.02\n2              112.0               0.85              15.30                1.13\n3              120.0               1.08              82.67                0.04\n4              132.0               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n95              91.0               0.35               9.08                0.15\n96             122.0               1.09              63.11                0.32\n97              97.0               0.58              21.86                0.10\n98             133.0               1.86             124.94                0.09\n99             122.0               0.57              63.14                0.66\n\n[100 rows x 4 columns]\nArrivals              122.39\nMean Q Time Recep       1.27\nMean Q Time Nurse      61.35\nMean Q Time Doctor      0.48\ndtype: float64\n\n\n\n\n1 receptionists, 2 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00               2.49                1.01\n1              125.0               1.84               3.55                1.56\n2              112.0               0.85               3.61                0.59\n3              120.0               1.08               3.43                0.19\n4              132.0               1.94               4.20                0.91\n...              ...                ...                ...                 ...\n95              91.0               0.35               1.08                0.07\n96             122.0               1.09               2.20                0.73\n97              97.0               0.58               1.09                1.04\n98             133.0               1.86               4.19                1.41\n99             122.0               0.57               1.86                0.85\n\n[100 rows x 4 columns]\nArrivals              122.39\nMean Q Time Recep       1.27\nMean Q Time Nurse       2.97\nMean Q Time Doctor      0.89\ndtype: float64\n\n\nWith these changes made, we can see that the number of arrivals and the queue time for the receptionists across the trials has remained consistent, while the waits for nurses and doctors have changed, but we can now be confident that this is because of alterations to the parameters - not uncontrolled randomness.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Reproducibility</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html",
    "href": "reneging_balking_jockeying.html",
    "title": "15  Reneging, balking and jockeying",
    "section": "",
    "text": "15.1 Reneging\nLet’s imagine that each of our patients has a patience level - an amount of time they’re prepared to wait for the nurse.\nTo model this, we : - Add patience level as an attribute to each patient, with some way of determining what a patient’s patience is - When we request a resource, we’ll tell SimPy to either wait until the request can be met OR until the patient’s patience has expired (whichever comes first) - We’ll then check what happened - did the patient wait or did they renege? If they waited, we’ll proceed as before. If they reneged, then they won’t see the nurse, and we’ll record that they reneged - We’ll add the number of patients that reneged to our outputs from each run, and take the average number of patients who reneged per run over the trial.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, balking and jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#reneging",
    "href": "reneging_balking_jockeying.html#reneging",
    "title": "15  Reneging, balking and jockeying",
    "section": "",
    "text": "15.1.1 Coding a reneging examaple\n\n15.1.1.1 The g class\nThe g class is unchanged.\n\n\n15.1.1.2 The patient class\nIn the patient class, we add a patience attribute.\nThis determines how long the patient is prepared to wait for the nurse.\nHere we just randomly sample an integer between 5 and 50 (so the patient will be prepared to wait for somewhere between 5 and 50 minutes in the queue), but in a real world application you would probably want to have a more refined way of allocating patience to patients (e.g basing probabilities off prior data, or using a non-uniform named distribution).\nYou could have different patience levels for different queues, or just a general patience level. Or even get creative and have a patience level that decreases the longer they’ve been in the system if your system has multiple steps!\nIf we want to see the effect of this, we can try changing the patience levels - but you’ll need to make the patience levels MUCH higher as this system is in bad shape (after 3 days patients are waiting on average over 3 hours… and a lot are waiting much longer!)\nMaybe try adding another nurse in to get the system under control first!\n\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        self.patience_nurse = random.randint(5, 50) ##NEW\n\n\n\n15.1.1.3 The model class\n\n15.1.1.3.1 The init method\nIn the init method, we set up an additional attribute to track the number of people reneging.\n\ndef __init__(self, run_number):\n    # Set up SimPy environment\n    self.env = simpy.Environment()\n\n    # Set up counters to use as entity IDs\n    self.patient_counter = 0\n\n    # Set up resources\n    self.nurse = simpy.PriorityResource(self.env,\n                                        capacity=g.number_of_nurses)\n\n    # Set run number from value passed in\n    self.run_number = run_number\n\n    # Set up DataFrame to store patient-level results\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Q Time Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Set up attributes that will store mean queuing times across the run\n    self.mean_q_time_nurse = 0\n\n    ##NEW - we'll set up a new attribute that will store the number of\n    # people that reneged from queues in the run (we only have one queue in\n    # this model)\n    self.num_reneged_nurse = 0\n\n    random.seed(42)\n\n\n\n\n15.1.1.4 The attend_clinic method\nIn the attend clinic, we now add in an OR statement (the vertical line | , also known as a pipe) to our request for the nurse.\n\nresult_of_queue = (yield req | self.env.timeout(patient.patience_nurse))\n\nIt basically says “Wait for the request for the nurse to be fulfilled OR until the patient’s patience level has passed, whichever comes first, and then store whatever the outcome was.\nWe then need to check whether we got our req - the resource we requested - or whether the timeout occurred.\nWe do this with conditional logic:\n\nif req in result_of_queue:\n\nThe indented code after this statement will only take place if the resource became available before the patient’s patience ran out (i.e. if the resource became available before the patience period elapsed).\n\ndef attend_clinic(self, patient):\n    # Nurse consultation activity\n    start_q_nurse = self.env.now\n\n    with self.nurse.request(priority=patient.priority) as req:\n        ##NEW\n        result_of_queue = (yield req |\n                            self.env.timeout(patient.patience_nurse))\n\n        ##NEW - we now need to check whether the patient waited or reneged,\n        # as we could have got to this point of the generator function\n        # either way.  We'll now only get them to see the nurse if they\n        # waited.  If they didn't wait, we'll add to our counter of how\n        # many patients reneged from the queue.\n        if req in result_of_queue:\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)\n        else:\n            self.num_reneged_nurse += 1\n\n            print (f\"Patient {patient.id} reneged after waiting\",\n                    f\"{patient.patience_nurse} minutes\")\n\n\n\n15.1.1.5 The run method\nThe only change to the run method is adding a print statement to the end of it to print the patients who reneged.\n\nprint (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n\n\n\n15.1.1.6 The Trial class\n\n15.1.1.6.1 The init method\nIn the init method, we add in an addiitonal attribute that is a placeholder column for the number of people in each run who reneged.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    ##NEW - additional column of trial results to store the number of\n    # patients that reneged in each run\n    self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n15.1.1.6.2 The calculate_means_over_trial method\nWe also now need to calculate the mean number of patients reneging per run.\n\ndef calculate_means_over_trial(self):\n    self.mean_q_time_nurse_trial = (\n        self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n    )\n\n    ##NEW\n    self.mean_reneged_q_nurse = (\n        self.df_trial_results[\"Reneged Q Nurse\"].mean()\n    )\n\n\n\n15.1.1.6.3 The print_trial_results method\n\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n    ##NEW - we will also now print out the mean number of patients who\n    # reneged from the nurse's queue per run\n    print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n\n\n\n15.1.1.6.4 The run_trial method\nWe also need to add the number of patients who reneged from the nurse’s queue as one of the results against each run.\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_reneged_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n\n\n\n\n\n15.1.2 Exploring the outputs\nThe full code can be seen below:\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 120\n    number_of_runs = 1\n    warm_up_period = 360\n\n    random.seed(42)\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        ##NEW - added a new patience attribute of the patient.  This determines\n        # how long the patient is prepared to wait for the nurse.  Here we just\n        # randomly sample an integer between 5 and 50 (so the patient will be\n        # prepared to wait for somewhere between 5 and 50 minutes in the queue),\n        # but in a real world application you would probably want to have a\n        # more refined way of allocating patience to patients (e.g basing\n        # probabilities off prior data, or using a non-uniform named\n        # distribution).  You could have different patience levels for different\n        # queues, or just a general patience level.  Or even get creative and\n        # have a patience level that decreases the longer they've been in the\n        # system!\n        # If we want to see the effect of this, we can try changing the patience\n        # levels - but you'll need to make the patience levels MUCH higher as\n        # this system is in bad shape (remember, after 3 days patients are\n        # waiting on average over 3 hours... and a lot are waiting much longer!)\n        # Maybe try adding another nurse in to get the system under control\n        # first!\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        ##NEW - we'll set up a new attribute that will store the number of\n        # people that reneged from queues in the run (we only have one queue in\n        # this model)\n        self.num_reneged_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            ##NEW - this statement now uses a vertical bar (|) / pipe as an \"or\"\n            # statement.  It basically says \"Wait for the request for the nurse\n            # to be fulfilled OR until the patient's patience level has passed,\n            # whichever comes first, and then store whatever the outcome was.\n            result_of_queue = (yield req |\n                               self.env.timeout(patient.patience_nurse))\n\n            ##NEW - we now need to check whether the patient waited or reneged,\n            # as we could have got to this point of the generator function\n            # either way.  We'll now only get them to see the nurse if they\n            # waited.  If they didn't wait, we'll add to our counter of how\n            # many patients reneged from the queue.\n            if req in result_of_queue:\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n            else:\n                self.num_reneged_nurse += 1\n\n                print (f\"Patient {patient.id} reneged after waiting\",\n                       f\"{patient.patience_nurse} minutes\")\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - we'll print out the number of patients that reneged from the\n        # nurse queue in this run of the model.\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - additional column of trial results to store the number of\n        # patients that reneged in each run\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - we also now need to calculate the mean number of patients\n        # reneging per run\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - we will also now print out the mean number of patients who\n        # reneged from the nurse's queue per run\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - we also need to add the number of patients who reneged from\n            # the nurse's queue as one of the results against each run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\nWhat are the outputs?\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n\nPatient 4 reneged after waiting 10 minutes\nPatient 9 reneged after waiting 22 minutes\nPatient 12 reneged after waiting 11 minutes\nPatient 17 reneged after waiting 28 minutes\nPatient 21 reneged after waiting 15 minutes\nPatient 41 reneged after waiting 5 minutes\nPatient 34 reneged after waiting 32 minutes\nPatient 35 reneged after waiting 28 minutes\nPatient 51 reneged after waiting 6 minutes\nPatient 61 reneged after waiting 12 minutes\nPatient 57 reneged after waiting 43 minutes\nPatient 63 reneged after waiting 19 minutes\nPatient 67 reneged after waiting 22 minutes\nPatient 75 reneged after waiting 11 minutes\nPatient 80 reneged after waiting 5 minutes\nPatient 78 reneged after waiting 9 minutes\nPatient 70 reneged after waiting 31 minutes\nPatient 79 reneged after waiting 11 minutes\nPatient 77 reneged after waiting 16 minutes\nPatient 69 reneged after waiting 41 minutes\nPatient 87 reneged after waiting 17 minutes\nPatient 92 reneged after waiting 10 minutes\nPatient 91 reneged after waiting 15 minutes\nPatient 95 reneged after waiting 20 minutes\nPatient 101 reneged after waiting 25 minutes\nPatient 97 reneged after waiting 41 minutes\nRun Number 0\n            Q Time Nurse\nPatient ID              \n72             29.540149\n81              0.000000\n82              3.770348\n83              2.707999\n84              5.064181\n85              0.000000\n86              4.052063\n88              1.470184\n89              0.292494\n90              8.546540\n93              0.592263\n96              1.576777\n94             12.271693\n100             0.609262\n98             13.622271\n99             13.994560\n102             1.164986\n104             3.650494\n105             6.703284\n26 patients reneged from nurse queue\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse\nRun Number                                    \n0                    5.769976               26\nMean Q Nurse : 5.8 minutes\nMean Reneged Q Nurse : 26.0 patients\n\n\nWe can see that not every patient is reneging.\nWe can also see that some patients who arrived in the system later balk earlier than patients who have been there longer (i.e. a patient with a later ID balks before a patient with an earlier ID). This is due to the randomly set reneging threshold for each patient - some people aren’t willing to wait as long.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, balking and jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#balking",
    "href": "reneging_balking_jockeying.html#balking",
    "title": "15  Reneging, balking and jockeying",
    "section": "15.2 Balking",
    "text": "15.2 Balking\nFor balking, there are two different ways in which balking can occur (and both could occur in the same model) :\n\nAn entity may choose not to join a queue because it is too long for their preferences / needs\nAn entity may not be able to join a queue because there is no capacity for them\n\nWe will look at the latter, but the way we approach it is the same for both - the only difference is that, in the former, the maximum queue length is likely to be an attribute of the patient (and may be individual per patient) just like in the reneging example, rather than an attribute of the model.\nHere, we’ll imagine that in our clinic, there is only space for 3 people to wait to see the nurse, and if there is no space, they cannot wait.\nTo model our balking requirements, we will : - Add a parameter to g class to store the maximum queue length allowed (if this were patient-decided balking, we’d put this in the patient class instead) - Add a list to our model attributes that will store all the patient objects currently in the queue for the nurse. This is really useful as it allows us to see who is in the queue at any time, as well as how many etc - Whenever a patient joins or leaves the queue, we’ll update the list of patients in the queue - Before we ask for the nurse resource, we’ll first check if the queue is at maximum size. If it is, the patient will never join the queue and we’ll record that. If not, we’ll proceed as before. We’ll add results of number of patients who balked to our results\n\n15.2.1 Coding a balking example\n\n15.2.1.1 The g Class\nWe’ll add a parameter value that will store the maximum length of the queue we allow for the nurse.\nLet’s imagine there’s only space for 3 people in the waiting room and so no more than 3 people can wait at any time.\n\n\n\n\n\n\nNote\n\n\n\nNote - we could simulate balking from the perspective of the patient instead (or as well) - e.g. the patient will only wait if there are no more than x people waiting etc. If we did this, we’d probably want to make this level an attribute of the patient, as it may vary between patients.\n\n\n\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    ##NEW\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 100\n    warm_up_period = 1440\n\n\n\n15.2.1.2 The Patient Class\nThis class is unchanged.\n\n\n15.2.1.3 The Model Class\n\n15.2.1.3.1 The init method\nHere we add in an additional attribute to count the number of people who balk.\nWe also we add a list that will store patient objects queuing for the nurse consultation. This will allow us to see who is in the queue at any time, as well as the length of the queue etc.\n\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW\n\n        self.q_for_nurse_consult = [] ##NEW\n\n\n\n15.2.1.3.2 The generator_patient_arrival method\nThis method is unchanged.\n\n\n15.2.1.3.3 The attend_clinic method\n\ndef attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) &lt; g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n\n\n\n15.2.1.3.4 The calculate_run_results method\nThis method is unchanged.\n\n\n15.2.1.3.5 The run method\nHere we have added a print message displaying how many patients balked in this run.\n\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Print patient level results for this run\n    print (f\"Run Number {self.run_number}\")\n    print (self.results_df)\n    print (f\"{self.num_balked_nurse} patients balked at the nurse queue\") ## NEW\n\n\n\n\n15.2.1.4 The Trial Class\n\n15.2.1.4.1 The init method\nFirst we add in a column to store the number who balked at the nurse queue in each run.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Balked Q Nurse\"] = [0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n15.2.1.4.2 The calculate_means_over_trial method\nWe add a calculation of mean number of patients who balked at the nurse queue per run.\n\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n\n\n15.2.1.4.3 The print_trial_results method\nWe add in a print message of mean number of patients balking at nurse queue per run.\n\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n    print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\") ##NEW\n\n\n\n15.2.1.4.4 The run_trial method\nFinally we add the number that balked at the nurse queue to results in the run.\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_balked_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n\n\n\n\n\n15.2.2 Exploring the outputs\nThe full code can be seen below:\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - we'll add a parameter value that will store the maximum length of\n    # the queue we allow for the nurse.  Let's imagine there's only space for 3\n    # people in the waiting room and so no more than 3 people can wait at any\n    # time.  Note - we could simulate balking from the perspective of the\n    # patient instead (or as well) - e.g. the patient will only wait if there\n    # are no more than x people waiting etc.  If we did this, we'd probably\n    # want to make this level an attribute of the patient, as it may vary\n    # between patients.\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 3\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW - added to record number balking\n\n        ##NEW - we add a list that will store patient objects queuing for the\n        # nurse consultation.  This will allow us to see who is in the queue at\n        # any time, as well as the length of the queue etc\n        self.q_for_nurse_consult = []\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) &lt; g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - added print message displaying how many patients balked in this\n        # run\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store the number who balked at the nurse queue\n        # in each run\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - added calculation of mean number of patients who balked at the\n        # nurse queue per run\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - added print message of mean number of patients balking at nurse\n        # queue per run\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - added number balked at nurse queue to results in the run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_balked_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\nWhat are the outputs?\nWe are doing three runs in this case.\n\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse\nPatient ID              \n285             3.140249\n286            10.349927\n284            28.226781\n289             0.000000\n291             2.701697\n...                  ...\n875            12.768719\n879             2.261475\n876            16.139470\n881             2.753824\n880            14.680950\n\n[459 rows x 1 columns]\n204 patients balked at the nurse queue\nRun Number 1\n            Q Time Nurse\nPatient ID              \n268             0.079416\n267             9.068225\n271             0.785271\n270             8.939292\n272            11.045918\n...                  ...\n836             4.989480\n837             2.139559\n838             5.041488\n839             3.394398\n840             8.081262\n\n[452 rows x 1 columns]\n163 patients balked at the nurse queue\nRun Number 2\n            Q Time Nurse\nPatient ID              \n296             5.074676\n297             9.088910\n295            22.675854\n300             4.342604\n302             1.337186\n...                  ...\n907             2.210570\n897            46.092776\n908             4.797286\n909             0.369347\n910             1.051325\n\n[465 rows x 1 columns]\n214 patients balked at the nurse queue\nTrial Results\n            Mean Q Time Nurse  Balked Q Nurse\nRun Number                                   \n0                   10.366464           204.0\n1                   10.228188           163.0\n2                   10.297362           214.0\nMean Q Nurse : 10.3 minutes\nMean Balked Q Nurse : 193.66666666666666 patients\n\n\nWe can see that we have patients reneging, but due to the random variation across the arrivals and consult times, the size of the queue is different at different points in time, so we get variation in the patients balking each time.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, balking and jockeying</span>"
    ]
  },
  {
    "objectID": "reneging_balking_jockeying.html#jockeying",
    "href": "reneging_balking_jockeying.html#jockeying",
    "title": "15  Reneging, balking and jockeying",
    "section": "15.3 Jockeying",
    "text": "15.3 Jockeying\nTrue jockeying involves entities switching from one queue to another, typically because they make a decision that they will likely be seen faster if they do.\nIn over 13 years, the author has never used jockeying to model a healthcare system. SimPy documentation does not cover it either and makes a point of saying they won’t (which implies it’s complicated, though fundamentally you’d need a model of the behaviour in making that decision combined with removing the entity from one queue and placing it in another).\nThere are likely to be few systems that you will model that would use jockeying. However, you might encounter systems where entities pick which queue to join in the first place based on queue length (eg patients deciding which Minor Injury Unit or Emergency Department to attend based on live waiting time data online).\nFor that reason, the example here will be based on this kind of model.\n\n15.3.1 A ‘choosing queues’ example\nLet’s imagine a slight change to our nurse clinic model.\nLet’s imagine that, as well as the nurse, there is also a doctor that patients can see that offers the same service. Patients can choose to join whichever queue they prefer - and they do this by joining the nurse queue if it’s shorter (and the nurse has capacity), and otherwise joining the doctor’s queue.\nThe doctor’s queue has no limits on capacity, and the doctor does not take a break (or rather, there is always a doctor available).\nConsultation times with the doctor are slightly shorter on average (5 mins vs 6 mins for the nurse), but more variable (with a standard deviation of 3 mins vs 1 min for the nurse).\nWe’re also going to imagine that word has got out that there’s now a doctor available too, and demand has more than doubled - patients are now arriving at the clinic every 2 minutes on average, compared to an average of every 5 minutes before.\nDue to the new logic, there should never be any patients balking (as they’d join the doctor’s queue if the nurse queue is full, and the doctor’s queue doesn’t have a capacity constraint), but we’ll still record these numbers so we can check that.\n\n\n15.3.2 Coding the ‘choosing queues’ example\nThe full code can be seen below.\nThis example brings together code for - nurse breaks - reneging - balking - queue choosing\n\n\n\n\n\n\nNote\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 2 ##NEW - decreased time to generate more frequent arrivals\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    mean_d_consult_time = 5 ##NEW - added mean consult time for doctor\n    sd_d_consult_time = 3 ##NEW - added SD consult time for doctor\n\n    # Resource numbers\n    number_of_nurses = 1\n    number_of_doctors = 1 ##NEW - added parameter to store number of doctors\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Maximum allowable queue lengths\n    max_q_nurse = 10\n\n    # Simulation meta parameters\n    sim_duration = 480 ##NEW significantly shortened so can see clear queue plot\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.q_time_doc = 0 ##NEW - attribute to store queuing time for doctor\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n        ##NEW - added random allocation of patience level to see doctor\n        self.patience_doctor = random.randint(20, 100)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        ##NEW - added doctor resource also as PriorityResource\n        self.doctor = simpy.PriorityResource(self.env,\n                                             capacity=g.number_of_doctors)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store queuing time for doctor for each patient\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW - store mean q time for doctor\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_reneged_nurse = 0\n        self.num_balked_nurse = 0\n\n        ##NEW - added equivalent queuing behaviour attributes for doctor\n        # though no balking should occur for the doctor or the nurse in this\n        # scenario - if there is no capacity in the nurse queue, the patient\n        # will join the doctor queue, which has no limit\n        self.num_reneged_doctor = 0\n        self.num_balked_doctor = 0\n\n        # Set up lists to store patient objects in each queue\n        self.q_for_nurse_consult = []\n        self.q_for_doc_consult = [] ##NEW - list to store queue for doctor\n\n        # Pandas dataframe to record number in queue(s) over time\n        self.queue_df = pd.DataFrame()\n        self.queue_df[\"Time\"] = [0.0]\n        self.queue_df[\"Num in Q Nurse\"] = [0]\n        self.queue_df[\"Num in Q Doctor\"] = [0] ##NEW added column for doctor\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n\n        ##NEW - check whether queue for the nurse is shorter than the queue for\n        # the doctor AND that there is space in the nurse's queue (which is\n        # constrained).  If both of these are true, then join the queue for the\n        # nurse, otherwise join the queue for the doctor.\n        if ((len(self.q_for_nurse_consult) &lt; len(self.q_for_doc_consult)) and\n            (len(self.q_for_nurse_consult) &lt; g.max_q_nurse)):\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            self.q_for_nurse_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            ##NEW need to also add length of current queue for doctor to the\n            # list (need to add both even though this is just an update to the\n            # length of the nurse list)\n            if self.env.now &gt; g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.nurse.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_nurse))\n\n                self.q_for_nurse_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                ##NEW need to also add length of current queue for doctor to the\n                # list (need to add both even though this is just an update to\n                # the length of the nurse list)\n                if self.env.now &gt; g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_nurse = self.env.now\n\n                    patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                    if self.env.now &gt; g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                            patient.q_time_nurse\n                        )\n\n                    sampled_nurse_act_time = Lognormal(\n                        g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                    yield self.env.timeout(sampled_nurse_act_time)\n                else:\n                    self.num_reneged_nurse += 1\n        else:\n            ##NEW - logic for patient to join queue for the doctor instead.\n            # In this system, there should be no balking as if the queue for the\n            # nurse has no more capacity, they'll just see the doctor which\n            # doesn't have a limit.\n\n            # Doctor consultation activity\n            start_q_doc = self.env.now\n\n            self.q_for_doc_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            if self.env.now &gt; g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.doctor.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_doctor))\n\n                self.q_for_doc_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                if self.env.now &gt; g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_doc = self.env.now\n\n                    patient.q_time_doc = end_q_doc - start_q_doc\n\n                    if self.env.now &gt; g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                            patient.q_time_doc\n                        )\n\n                    sampled_doc_act_time = Lognormal(\n                        g.mean_d_consult_time, g.sd_d_consult_time).sample()\n\n                    yield self.env.timeout(sampled_doc_act_time)\n                else:\n                    self.num_reneged_doctor += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        ##NEW - added calculation for mean queuing time for doctor\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n        ##NEW added print statements for reneging and balking from doctor queue\n        print (f\"{self.num_reneged_doctor} patients reneged from the doctor\",\n               \"queue\")\n        print (f\"{self.num_balked_doctor} patients balked at the doctor queue\")\n        # Print queues over time dataframe for this run\n        print (\"Queues over time\")\n        print (self.queue_df)\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        ##NEW added columns to store number trial results relating to doctor\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Doctor\"] = [0]\n        self.df_trial_results[\"Balked Q Doctor\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n        ##NEW added calculations for doctor queue and activity across trial\n        self.mean_q_time_doc_trial = (\n            self.df_trial_results[\"Mean Q Time Doctor\"].mean()\n        )\n\n        self.mean_reneged_q_doc = (\n            self.df_trial_results[\"Reneged Q Doctor\"].mean()\n        )\n\n        self.mean_balked_q_doc = (\n            self.df_trial_results[\"Balked Q Doctor\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n        ##NEW added print statements for trial results related to doctor\n        print (f\"Mean Q Doctor : {self.mean_q_time_doc_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Doctor : {self.mean_reneged_q_doc} patients\")\n        print (f\"Mean Balked Q Doctor : {self.mean_balked_q_doc} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW added doctor results to end of list of results to add for this\n            # run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse,\n                                              my_model.num_balked_nurse,\n                                              my_model.mean_q_time_doctor,\n                                              my_model.num_reneged_doctor,\n                                              my_model.num_balked_doctor]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n\n\n\n\n\n15.3.3 Exploring the outputs\n\nmy_trial = Trial()\nmy_trial.run_trial()\n\nRun Number 0\n            Q Time Nurse  Q Time Doctor\nPatient ID                             \n696                  NaN      52.747166\n712            23.500060            NaN\n705                  NaN      43.294422\n727             1.113440            NaN\n726                  NaN       2.233787\n...                  ...            ...\n953                  NaN      27.066169\n966             2.709667            NaN\n968                  NaN       0.669621\n970                  NaN       0.010199\n969                  NaN      11.648855\n\n[164 rows x 2 columns]\n209 patients reneged from nurse queue\n0 patients balked at the nurse queue\n102 patients reneged from the doctor queue\n0 patients balked at the doctor queue\nQueues over time\n            Time  Num in Q Nurse  Num in Q Doctor\n0       0.000000             0.0              0.0\n1    1440.550052             5.0              6.0\n2    1441.816771             4.0              6.0\n3    1443.550145             5.0              6.0\n4    1443.826158             5.0              5.0\n..           ...             ...              ...\n507  1914.375700             4.0              5.0\n508  1914.919764             5.0              5.0\n509  1915.435042             5.0              6.0\n510  1916.332824             4.0              6.0\n511  1919.745037             4.0              5.0\n\n[512 rows x 3 columns]\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse  Balked Q Nurse  \\\nRun Number                                                       \n0                   11.570637              209               0   \n\n            Mean Q Time Doctor  Reneged Q Doctor  Balked Q Doctor  \nRun Number                                                         \n0                    12.248308               102                0  \nMean Q Nurse : 11.6 minutes\nMean Reneged Q Nurse : 209.0 patients\nMean Balked Q Nurse : 0.0 patients\nMean Q Doctor : 12.2 minutes\nMean Reneged Q Doctor : 102.0 patients\nMean Balked Q Doctor : 0.0 patients",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Reneging, balking and jockeying</span>"
    ]
  },
  {
    "objectID": "exercise_des_advanced.html",
    "href": "exercise_des_advanced.html",
    "title": "16  Exercise - Practicing Advanced Concepts",
    "section": "",
    "text": "In this section we’ve looked at how we can implement the following DES features in SimPy : - Simulation warm-up - Priority-based queuing - Resource unavailability - Use of the alternative distributions - Reneging - Balking - Entities choosing queues based on queue length\nDesign and build a DES model in SimPy that uses at least four of the features above.\nThe model can be of anything you like - you may choose to try to build the conceptual model you designed in the DES Design exercise at the end of section 1, or you might choose something completely different.",
    "crumbs": [
      "Part 3 - Extending Your Model",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exercise - Practicing Advanced Concepts</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html",
    "href": "tracking_resource_utilisation.html",
    "title": "17  Tracking Resource Utilisation",
    "section": "",
    "text": "17.1 Looking at average resource utilisation across a run\nTo calculate the percentage of time a resource was being utilised overall, we need to start tracking how long each entity in our model spent using a resource.\nWhat we can then do is - add this up across every entity who passes through our model - divide it by the total amount of time that has elapsed in the model, multiplied by the number of resources in the model\nWe can track this by adding an additional attribute to our patient class.\nLet’s return to the very simplest version of the model for this.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html#looking-at-average-resource-utilisation-across-a-run",
    "href": "tracking_resource_utilisation.html#looking-at-average-resource-utilisation-across-a-run",
    "title": "17  Tracking Resource Utilisation",
    "section": "",
    "text": "17.1.1 A code example\n\n17.1.1.1 The g class\nThe g class is unchanged.\n\n\n17.1.1.2 The patient class\nFirst, we add an attribute to the patient class.\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.time_with_nurse = 0 ## NEW\n\n\n\n17.1.1.3 The model class\n\n17.1.1.3.1 The init method\nHere we’re just going to add an empty list to store our patient objects.\nWe’re also going to add a space to store the utilisation in that run.\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n        self.patient_objects = [] ##NEW\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n        self.nurse_utilisation = 0.0 ##NEW\n\n\n\n17.1.1.3.2 The generate_patient_arrivals method\nHere we just want to add a line to add the patient objects to our patient_objects list when they are created.\nDon’t worry that we haven’t yet set the attributes of the patient throughout their journeys - when we access the patient list at the very end of the model runs, we will get the most up-to-date version of the attribute for each patient.\n\ndef generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\n17.1.1.3.3 The attend_clinic method\nIn here, we will add in a step to set the value of the time_with_nurse attribute of the patient class.\n\ndef attend_clinic(self, patient):\n    # Record the time the patient started queuing for a nurse\n    start_q_nurse = self.env.now\n\n    # This code says request a nurse resource, and do all of the following\n    # block of code with that nurse resource held in place (and therefore\n    # not usable by another patient)\n    with self.nurse.request() as req:\n        # Freeze the function until the request for a nurse can be met.\n        # The patient is currently queuing.\n        yield req\n\n        # When we get to this bit of code, control has been passed back to\n        # the generator function, and therefore the request for a nurse has\n        # been met.  We now have the nurse, and have stopped queuing, so we\n        # can record the current time as the time we finished queuing.\n        end_q_nurse = self.env.now\n\n        # Calculate the time this patient was queuing for the nurse, and\n        # record it in the patient's attribute for this.\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        # Now we'll randomly sample the time this patient with the nurse.\n        # Here, we use an Exponential distribution for simplicity, but you\n        # would typically use a Log Normal distribution for a real model\n        # (we'll come back to that).  As with sampling the inter-arrival\n        # times, we grab the mean from the g class, and pass in 1 / mean\n        # as the lambda value.\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        # Here we'll store the queuing time for the nurse and the sampled\n        # time to spend with the nurse in the results DataFrame against the\n        # ID for this patient.  In real world models, you may not want to\n        # bother storing the sampled activity times - but as this is a\n        # simple model, we'll do it here.\n        # We use a handy property of pandas called .at, which works a bit\n        # like .loc.  .at allows us to access (and therefore change) a\n        # particular cell in our DataFrame by providing the row and column.\n        # Here, we specify the row as the patient ID (the index), and the\n        # column for the value we want to update for that patient.\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n\n        patient.time_with_nurse = sampled_nurse_act_time ##NEW\n\n        # Freeze this function in place for the activity time we sampled\n        # above.  This is the patient spending time with the nurse.\n        yield self.env.timeout(sampled_nurse_act_time)\n\n        # When the time above elapses, the generator function will return\n        # here.  As there's nothing more that we've written, the function\n        # will simply end.  This is a sink.  We could choose to add\n        # something here if we wanted to record something - e.g. a counter\n        # for number of patients that left, recording something about the\n        # patients that left at a particular sink etc.\n\n\n\n17.1.1.3.4 A new method: audit_utilisation\nIn our model class, we can now create a new method.\nRemember that thanks to the additional attribute we added to the model class, we have now stored the time_with_nurse for each patient and can easily access it.\nAs we are only tracking a single resource in this model, we could write our function like this:\n\ndef audit_utilisation(self):\n    activity_durations = [i.time_with_nurse for i in self.patient_objects]\n\n    return (sum(activity_durations) / (g.number_of_nurses * g.sim_duration))\n\n\n\n\n\n\n\nTip\n\n\n\nA more generalisable form of this function is given below.\n\ndef audit_utilisation(self, activity_attribute, resource_attribute):\n    activity_durations = [i.getattr(activity_attribute) for i in self.patient_objects]\n\n    return (sum(activity_durations) / (g.getattr(resource_attribute) * g.sim_duration))\n\nThis will then be called like this.\n\nself.audit_utilisation(\"time_with_nurse\", \"number_of_nurses\")\n\nIf we were also recording time with a doctor, we might call that as\n\nself.audit_utilisation(\"time_with_doctor\", \"number_of_doctors\")\n\n\n\n\n\n17.1.1.3.5 The calculate_run_results method\nNow we are going to use this new method to add the utilisation metric to our results dataframe.\n\ndef calculate_run_results(self):\n    # Take the mean of the queuing times for the nurse across patients in\n    # this run of the model.\n    self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # This assumes we're not using the generalised version of the function\n    # which doesn't take any arguments\n    self.nurse_utilisation = self.audit_utilisation() ##NEW\n\nFinally, we can put this all together when we run the model.\n\n\n\n17.1.1.4 The trial class\n\n17.1.1.4.1 The init method\nFirst we add a\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Average Nurse Utilisation\"] = [0.0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n17.1.1.4.2 The run_trial class\nFinally, we add this to the output dataframe.\nNote that we have had to tweak the step for adding results to our dataframe as there are now two possible columns for the result to go in - previously we could get away with just specifying the row in loc, but now we have to pass the column name too.\n\ndef run_trial(self):\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run, \"Mean Q Time Nurse\"] = [my_model.mean_q_time_nurse] ##EDITED\n        self.df_trial_results.loc[run, \"Average Nurse Utilisation\"] = [my_model.nurse_utilisation] ##NEW\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.print_trial_results()\n\n\n\n\n\n\n\nImportant\n\n\n\nThis method may slightly overestimate the utilisation.\nWhy?\nBecause we record the time spent with the resource prior to that time elapsing.\nIf we have a model run time of 600 time units, and someone reaches the nurse at unit 595 but has an activity time of 30, we will record that and use it in our calculations - even though only 5 minutes of that time actually took place during our model run.\nYou could adapt the code above to account for that - for example, you could check whether the time remaining in the model run (g.sim_duration - self.env.now) is greater than the activity time that is sampled, and record whichever is the smaller of the two as the patient attribute.\n\n\n\n\n\n\n17.1.2 Evaluating the output\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 2\n    sim_duration = 1200\n    number_of_runs = 5\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.time_with_nurse = 0 ## NEW\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n        self.patient_objects = [] ## NEW\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n        self.nurse_utilisation = 0.0 ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p) ##NEW\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            patient.time_with_nurse = sampled_nurse_act_time ##NEW\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    def audit_utilisation(self):\n        activity_durations = [i.time_with_nurse for i in self.patient_objects]\n\n        return (sum(activity_durations) / (g.number_of_nurses * g.sim_duration))\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n        self.nurse_utilisation = self.audit_utilisation() ##NEW\n\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # We are not printing the patient-level results in this case\n        # so this code has been removed\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Average Nurse Utilisation\"] = [0.0] ##NEW\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run, \"Mean Q Time Nurse\"] = [my_model.mean_q_time_nurse] ##EDITED\n            self.df_trial_results.loc[run, \"Average Nurse Utilisation\"] = [my_model.nurse_utilisation] ##NEW\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\n\n\n\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\nTrial Results\n            Mean Q Time Nurse  Average Nurse Utilisation\nRun Number                                              \n0                    3.078365                   0.592369\n1                    2.579088                   0.570795\n2                    2.526303                   0.606631\n3                    3.102026                   0.570578\n4                    7.423224                   0.681257\n\n\n\n\n\n\n\n\nTip\n\n\n\nA nice enhancement to this output would be to format the average nurse utilisation column as a percentage rather than keeping it in decimal format.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "tracking_resource_utilisation.html#interval-audits",
    "href": "tracking_resource_utilisation.html#interval-audits",
    "title": "17  Tracking Resource Utilisation",
    "section": "17.2 Interval Audits",
    "text": "17.2 Interval Audits\nAnother option for monitoring resource usage is to set up a new interval audit process.\nWe create a new interval_audit_utilisation() function that we pass - a list of resources we want to monitor - a time interval at which to snapshot the utilisation in the process\n\n17.2.1 A code example\n\n17.2.1.1 The g class\nWe add a parameter to the g class which will tell us how often to record the current utilisation.\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 35\n    number_of_nurses = 9\n    sim_duration = 600\n    number_of_runs = 5\n    audit_interval = 5 ##NEW\n\n\n\n17.2.1.2 The Model Class\n\n17.2.1.2.1 The init method\nFirst, we create an empty list to hold our utilisation audit in our Model class.\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create a SimPy resource to represent a nurse, that will live in the\n    # environment created above.  The number of this resource we have is\n    # specified by the capacity, and we grab this value from our g class.\n    self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results against\n    # the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Q Time Nurse\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing time for the nurse\n    # across this run of the model\n    self.mean_q_time_nurse = 0\n\n    self.utilisation_audit = [] ##NEW\n\n\n\n17.2.1.2.2 A new method - interval_audit_utilisation\nThen we add the interval_audit_utilisation function to our Model class.\nWe set it up so either a list of resources can be passed as a dictionary, or just a single simpy resource object.\n\ndef interval_audit_utilisation(self, resources, interval=1):\n    '''\n    Record utilisation at defined intervals.\n\n    Needs to be passed to env.process when running model.\n\n    Parameters:\n    ------\n    resource: SimPy resource object\n        The resource to monitor\n        OR\n        a list of dictionaries containing simpy resource objects in the format\n        [{'resource_name':'my_resource', 'resource_object': resource},\n        {'resource_name':'my_second_resource', 'resource_object': resource_2}\n        ]\n        where resource and resource_2 in the examples above are simpy resources.\n\n    interval: int:\n        Time between audits.\n        In simpy time units\n        Default: 1\n    '''\n\n    # Keep doing the below as long as the simulation is running\n    while True:\n\n        # Code for what to do if we pass in a list of resources\n        if isinstance(resources, list):\n            for i in range(len(resources)):\n                self.utilisation_audit.append({\n                    'resource_name': resources[i]['resource_name'], # The provided name for the resource\n                    'simulation_time': self.env.now,  # The current simulation time\n                    'number_utilised': len(resources[i]['resource_object'].count), # The number of users\n                    'number_available': resources[i]['resource_object'].capacity, # The total resource available,\n                    'queue_length': len(resources[i]['resource_object'].queue)\n                })\n\n        else:\n\n            # Code for what to do if we just pass in a single resource to monitor\n            self.utilisation_audit.append({\n                'simulation_time': self.env.now,  # The current simulation time\n                'number_utilised': resources.count,  # The number of users\n                'number_available': resources.capacity, # The total resource available\n                'queue_length': len(resources.queue)\n            })\n\n\n        # Trigger next audit after desired interval has passed.\n        yield self.env.timeout(interval)\n\n\n\n\n\n\n\nTip\n\n\n\nIf you are using a simpy PriorityResource instead of a standard resource, the code should work the same.\nIf you are using a simpy store instead of a simpy resource, it’s possibly to adapt by using len(resources.items) to get the number of resources currently being utilised, and resources.capacity will still return the total number of resources that are in the system.\n\n\n\n\n17.2.1.2.3 the run method\nWe now add the interval audit process to our run.\nRemember - this will update the self.utilisation_audit in our method class.\nHere we have passed in the nurse resource that gets created during the init method of the model class.\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n        def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(\n          self.generator_patient_arrivals()\n        )\n\n        self.env.process(\n          self.interval_audit_utilisation(resources=self.nurse,interval=g.audit_interval) ##NEW\n        )\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # EDIT: We've skipped printing the individual-level results here\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n\n\n\n\n\n\nTip\n\n\n\nIf we wanted to conduct an interval audit of multiple resources, we could do it like this:\n\nself.env.process(\n    self.interval_audit_utilisation(\n      resources= [\n        {'resource_name':'receptionists', 'resource_object': self.receptionist},\n        {'resource_name':'nurses', 'resource_object': self.nurse},\n        {'resource_name':'doctors', 'resource_object': self.doctor}\n        ],\n      interval=g.audit_interval) ##NEW\n  )\n\nThis assumes our additional resources were set up in the init method of the model class like so:\n\n  self.receptionist = simpy.Resource(\n      self.env, capacity=g.number_of_receptionists\n  )\n\n  self.nurse = simpy.Resource(\n    self.env, capacity=g.number_of_nurses\n    )\n\n  self.doctor = simpy.Resource(\n      self.env, capacity=g.number_of_doctors\n  )\n\n\n\n\n\n\n17.2.1.3 The trial class\n\n17.2.1.3.1 The init method\nWe can add an empty list where we will store all of the interval audits\n\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.interval_audit_list = [] ##NEW\n\n\n\n17.2.1.3.2 The run_trial method\n\n# Method to run a trial\ndef run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run() ##EDITED\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            interval_audit_df = pd.DataFrame(my_model.utilisation_audit)\n            interval_audit_df[\"run\"] = run\n            interval_audit_df[\"perc_utilisation\"] = (\n              interval_audit_df[\"number_utilised\"]/interval_audit_df[\"number_available\"]\n            )\n\n            self.interval_audit_list.append(interval_audit_df)\n\n        # For now, we're going to skip printing the trial results, so the line\n        # below has been commented out\n        # self.print_trial_results()\n\n\n\n17.2.1.3.3 New method - get_interval_audits\nFinally we are going to create a new method that just joins all of the interval audit dataframes together and returns them as a single dataframe.\n\ndef get_interval_audits(self):\n  return pd.concat(self.interval_audit_list)\n\n\n\n\n\n17.2.2 Evaluating the outputs\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 35\n    number_of_nurses = 9\n    sim_duration = 600\n    number_of_runs = 5\n    audit_interval = 5 ##NEW\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n        self.utilisation_audit = [] ##NEW\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    def interval_audit_utilisation(self, resources, interval=1):\n        '''\n        Record utilisation at defined intervals.\n\n        Needs to be passed to env.process when running model.\n\n        Parameters:\n        ------\n        resource: SimPy resource object\n            The resource to monitor\n            OR\n            a list of dictionaries containing simpy resource objects in the format\n            [{'resource_name':'my_resource', 'resource_object': resource},\n            {'resource_name':'my_second_resource', 'resource_object': resource_2}\n            ]\n            where resource and resource_2 in the examples above are simpy resources.\n\n        interval: int:\n            Time between audits.\n            In simpy time units\n            Default: 1\n        '''\n\n        # Keep doing the below as long as the simulation is running\n        while True:\n\n            # Code for what to do if we pass in a list of resources\n            if isinstance(resources, list):\n                for i in range(len(resources)):\n                    self.utilisation_audit.append({\n                        'resource_name': resources[i]['resource_name'], # The provided name for the resource\n                        'simulation_time': self.env.now,  # The current simulation time\n                        'number_utilised': len(resources[i]['resource_object'].count), # The number of users\n                        'number_available': resources[i]['resource_object'].capacity, # The total resource available,\n                        'queue_length': len(resources[i]['resource_object'].queue)\n                    })\n\n            else:\n\n                # Code for what to do if we just pass in a single resource to monitor\n                self.utilisation_audit.append({\n                    'simulation_time': self.env.now,  # The current simulation time\n                    'number_utilised': resources.count,  # The number of users\n                    'number_available': resources.capacity, # The total resource available\n                    'queue_length': len(resources.queue)\n                })\n\n\n            # Trigger next audit after desired interval has passed.\n            yield self.env.timeout(interval)\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(\n          self.generator_patient_arrivals()\n        )\n\n        self.env.process(\n          self.interval_audit_utilisation(resources=self.nurse,interval=g.audit_interval) ##NEW\n        )\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        # EDIT: We've skipped printing the individual-level results here\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.interval_audit_list = [] ##NEW\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run() ##EDITED\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            interval_audit_df = pd.DataFrame(my_model.utilisation_audit)\n            interval_audit_df[\"run\"] = run\n            interval_audit_df[\"perc_utilisation\"] = (\n              interval_audit_df[\"number_utilised\"]/interval_audit_df[\"number_available\"]\n            )\n\n            self.interval_audit_list.append(interval_audit_df)\n\n        # For now, we're going to skip printing the trial results, so the line\n        # below has been commented out\n        # self.print_trial_results()\n\n    def get_interval_audits(self):\n      return pd.concat(self.interval_audit_list)\n\n\n\n\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\ninterval_audits = my_trial.get_interval_audits()\n\ninterval_audits\n\n\n\n\n\n\n\n\n\nsimulation_time\nnumber_utilised\nnumber_available\nqueue_length\nrun\nperc_utilisation\n\n\n\n\n0\n0\n0\n9\n0\n0\n0.000000\n\n\n1\n5\n2\n9\n0\n0\n0.222222\n\n\n2\n10\n3\n9\n0\n0\n0.333333\n\n\n3\n15\n2\n9\n0\n0\n0.222222\n\n\n4\n20\n3\n9\n0\n0\n0.333333\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n115\n575\n9\n9\n1\n4\n1.000000\n\n\n116\n580\n9\n9\n0\n4\n1.000000\n\n\n117\n585\n8\n9\n0\n4\n0.888889\n\n\n118\n590\n7\n9\n0\n4\n0.777778\n\n\n119\n595\n5\n9\n0\n4\n0.555556\n\n\n\n\n600 rows × 6 columns\n\n\n\n\nWe can explore this output as a graph, with the vertical axis showing the % utilisation over time and the horizontal axis showing the progression of simulation time. Each coloured line represents a different run. We can see that the % utilisation is different at a given time point across different runs, which we would expect due to the randomness.\n\nimport plotly.express as px\n\nfig = px.line(interval_audits, x=\"simulation_time\", y=\"perc_utilisation\", color=\"run\")\n\nfig.show()\n\n                                                \n\n\nWe could look at the median utilisation across different runs.\nIf we get to a high enough number of runs, we may expect the average utilisation to become quite consistent over time.\n\n\n\n\n\n\nTip\n\n\n\nThis may be of more use when running a model with variable arrival rates at different times of day - as we would then expect to see some variation.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis can also form part of your strategy for working out how long the warm-up period of a model should be.\n\n\n\ng.number_of_runs = 1000\n\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n\ninterval_audits = my_trial.get_interval_audits()\n\ninterval_audits_median = interval_audits.groupby(\"simulation_time\").median().reset_index()\n\ninterval_audits_median\n\n\n\n\n\n\n\n\n\nsimulation_time\nnumber_utilised\nnumber_available\nqueue_length\nrun\nperc_utilisation\n\n\n\n\n0\n0\n0.0\n9.0\n0.0\n499.5\n0.000000\n\n\n1\n5\n2.0\n9.0\n0.0\n499.5\n0.222222\n\n\n2\n10\n2.0\n9.0\n0.0\n499.5\n0.222222\n\n\n3\n15\n3.0\n9.0\n0.0\n499.5\n0.333333\n\n\n4\n20\n3.0\n9.0\n0.0\n499.5\n0.333333\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n115\n575\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n116\n580\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n117\n585\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n118\n590\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n119\n595\n7.0\n9.0\n0.0\n499.5\n0.777778\n\n\n\n\n120 rows × 6 columns\n\n\n\n\n\nimport plotly.express as px\n\nfig = px.line(interval_audits_median, x=\"simulation_time\", y=\"perc_utilisation\")\n\nfig.show()",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tracking Resource Utilisation</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html",
    "href": "other_model_metrics.html",
    "title": "18  Other Model Metrics",
    "section": "",
    "text": "18.1 Arrivals\nMonitoring the number of arrivals can be useful to see how much variation we may expect in our system.\nThis can also be helpful to ensure the model is running as expected - we already did this in the Reproducibility section (Chapter 14).",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html#of-entities-meeting-a-target",
    "href": "other_model_metrics.html#of-entities-meeting-a-target",
    "title": "18  Other Model Metrics",
    "section": "18.2 % of entities meeting a target",
    "text": "18.2 % of entities meeting a target\nWhile there is a lot of controversy around the value of targets like the 4 hour wait from arrival to admission, transfer or discharge for A&E departments, they do have some value and can be a useful metric to consider as part of a wider package of metrics.\nOther examples of this may relate to length of stay - for example, mental health wards may have a target for the maximum length of stay.\n\n\n\n\n\n\nWarning\n\n\n\nConsider whether there may be anything in the historical data patterns that may be due to trying to meet targets.\nFor example, this article from the PSC refers to some NHS England analysis that shows “17% of all admissions to Type 1 A&Es between January and December 2018 occurred between 3 hours 50 minutes and 4 hours, prompting criticism that the 4-hour target has encouraged the NHS to ‘treat the target rather than the patient’. Evidence suggests that hospital processes, rather than clinical judgement, are responsible for this spike in admissions or discharge in the immediate period before a patient breaches the standard.”\n Source: NHS England analysis of Secondary Uses Services (SUS) data, via The PSC\nIf the target was removed, would this result in a change in behaviour? How might the predictions of our model be affected by this?",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "other_model_metrics.html#throughput",
    "href": "other_model_metrics.html#throughput",
    "title": "18  Other Model Metrics",
    "section": "18.3 Throughput",
    "text": "18.3 Throughput\nThroughput refers to the % of people entering our system who have left by the time our model stops running.\nA very low throughput suggests a severe bottleneck somewhere in the system.\nThis can be a useful measure to track as a quick way of assessing whether different scenarios are leading to severe bottlenecks, but it is not that useful as a standalone measure.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Other Model Metrics</span>"
    ]
  },
  {
    "objectID": "modelling_variable_arrival_rates.html",
    "href": "modelling_variable_arrival_rates.html",
    "title": "21  Modelling Variable Arrival Rates",
    "section": "",
    "text": "It is often the case that arrivals to a system do not occur completely regularly throughout the day.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Modelling Variable Arrival Rates</span>"
    ]
  },
  {
    "objectID": "requesting_multiple_resources.html",
    "href": "requesting_multiple_resources.html",
    "title": "22  Requesting Multiple Resources Simultaneously",
    "section": "",
    "text": "22.1 Code example\nLet’s return to our branching model from before.\nRemember, in this, patients - see a receptionist - see a nurse - have a chance of going on to see a doctor\nIn the original version of the model, we assumed that there was always a room available for patients to be seen in. Maybe each nurse and doctor in this example clinic has their own designated room they are always in.\nBut let’s imagine the setup is slightly different - patients see a receptionist and go to a waiting area - once both a cubicle and a nurse are available, the patient is seen by a nurse - if the patient then needs to see a doctor (which, as before, only a certain % of patients will) then they will remain in the same cubicle while waiting for a doctor - the doctor will see them in the cubicle\nThe cubicle is released for the next patient after seeing the nurse IF the patient leaves at this point. Otherwise, it will be released after seeing the doctor.\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 2\n    number_of_doctors = 2\n    number_of_cubicles = 5\n    prob_seeing_doctor = 0.6\n    sim_duration = 1200\n    number_of_runs = 10\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0\n        self.q_time_nurse = 0\n        self.q_time_doctor = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(self.env, capacity=g.number_of_receptionists)\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.doctor = simpy.Resource(self.env, capacity=g.number_of_doctors)\n        self.cubicles = simpy.Resource(self.env, capacity=g.number_of_cubicles) ## NEW\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0]\n        self.results_df[\"Time with Recep\"] = [0.0]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df[\"Time with Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n        # NEW: They will also be queueing for a cubicle at this point.\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n        start_q_cubicle = self.env.now\n\n        # NEW: As we are going to require the cubicle for the entire time period from\n        # here on, and won't release it until they exit the system, we will request\n        # the cubicle here and indent all of the existing code by one level.\n\n        with self.cubicle.request() as req:\n          yield req\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n        # Conditional logic to see if patient goes on to see doctor\n        # We sample from the uniform distribution between 0 and 1.  If the value\n        # is less than the probability of seeing a doctor (stored in g Class)\n        # then we say the patient sees a doctor.\n        # If not, this block of code won't be run and the patient will just\n        # leave the system (we could add in an else if we wanted a branching\n        # path to another activity instead)\n        if random.uniform(0,1) &lt; g.prob_seeing_doctor:\n            start_q_doctor = self.env.now\n\n            with self.doctor.request() as req:\n                yield req\n\n                end_q_doctor = self.env.now\n\n                patient.q_time_doctor = end_q_doctor - start_q_doctor\n\n                sampled_doctor_act_time = random.expovariate(\n                    1.0 / g.mean_d_consult_time\n                )\n\n                self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                    patient.q_time_doctor\n                )\n                self.results_df.at[patient.id, \"Time with Doctor\"] = (\n                    sampled_doctor_act_time\n                )\n\n                yield self.env.timeout(sampled_doctor_act_time)\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean()\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean() ##NEW\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse,\n                                              my_model.mean_q_time_doctor]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Requesting Multiple Resources Simultaneously</span>"
    ]
  },
  {
    "objectID": "testing_large_numbers_scenarios.html",
    "href": "testing_large_numbers_scenarios.html",
    "title": "26  Testing Large Numbers of Scenarios",
    "section": "",
    "text": "Credit for this solution goes to Anna Laws and Mike Allen of the PenCHORD team.\n\nWhen working out the best possible configuration for a service, you may wish to try out a large number of scenarios.\nLet’s return to our branching model (with the reproducibility set via sim-tools as described in chapter Chapter 14).\nWe have a number of parameters available to us in this model:\n\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 2\n\nWe can first create a python dictionary of the possible parameter values.\n\n\n\n\n\n\nWarning\n\n\n\nBe careful - the total number of possible permutations starts to grow very rapidly when you have lots of parameters with multiple options for each!\n\n\n\nscenarios = {\n    'patient_inter': [4, 8, 12],\n    'mean_reception_time': [2, 3],\n    'mean_n_consult_time': [6, 10, 14],\n    'mean_d_consult_time': [10, 20],\n    'number_of_receptionists': [1, 2],\n    'number_of_nurses': [1, 2, 3],\n    'number_of_doctors': [2, 3, 4],\n    'prob_seeing_doctor': [0.6, 0.8]\n}\n\n\n\n\n\n\n\nTip\n\n\n\nMake sure to use exactly the same naming for the dictionary keys as is used in your g class.\nThis is because we will reset the values of the g class for each Trial programmatically.\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor a small number of possibilities, setting the variables by hand will be fine.\nFor a larger number, you may want to use the range function.\ne.g. to get 6, 10, 14 you would do\n\n[i for i in range(6, 15, 4)]\n\n[6, 10, 14]\n\n\n\n\nNext we use the itertools package to create every possible permutation of the scenarios.\n\nimport itertools\n\n# Generate all scenarios:\nall_scenarios_tuples = [\n    x for x in itertools.product(*scenarios.values())]\n# Convert list of tuples back to list of dictionaries:\nall_scenarios_dicts = [\n    dict(zip(scenarios.keys(), p)) for p in all_scenarios_tuples]\n\nLet’s take a look at the first 3 scenario dictionaries.\n\nall_scenarios_dicts[0:3]\n\n[{'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 2,\n  'prob_seeing_doctor': 0.6},\n {'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 2,\n  'prob_seeing_doctor': 0.8},\n {'patient_inter': 4,\n  'mean_reception_time': 2,\n  'mean_n_consult_time': 6,\n  'mean_d_consult_time': 10,\n  'number_of_receptionists': 1,\n  'number_of_nurses': 1,\n  'number_of_doctors': 3,\n  'prob_seeing_doctor': 0.6}]\n\n\nWe can see that all that has changed is the probability of seeing a doctor (the last key-value pair in each dictionary).\nHow many scenarios have we created?\n\nlen(all_scenarios_dicts)\n\n1296\n\n\nNow let’s update our g class. We’ll just modify it to add in a space to add a scenario name.\n\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2\n    mean_n_consult_time = 6\n    mean_d_consult_time = 20\n    number_of_receptionists = 1\n    number_of_nurses = 1\n    number_of_doctors = 2\n    prob_seeing_doctor = 0.6\n    sim_duration = 600\n    number_of_runs = 2\n    scenario_name = 0 ## New\n\nLet’s now create all of the scenario objects.\n\nresults = []\n\nfor index, scenario_to_run in enumerate(all_scenarios_dicts):\n    g.scenario_name = index\n\n    # Overwrite defaults from the passed dictionary\n\n    for key in scenario_to_run:\n        setattr(g, key, scenario_to_run[key])\n\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    results.append(my_trial.run_trial())\n\npd.concat(results).groupby(\"scenario\").mean().head(20)\n\n\n\n\n\n\n\n\n\naverage_inter_arrival\nnum_recep\nnum_nurses\nnum_doctors\naverage_reception_time\naverage_nurse_time\naverage_doctor_time\nprob_need_doctor\nArrivals\nMean Q Time Recep\nMean Q Time Nurse\nMean Q Time Doctor\n\n\nscenario\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n4.0\n1.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n133.505891\n0.676479\n\n\n1.0\n4.0\n1.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n105.505442\n1.263302\n\n\n2.0\n4.0\n1.0\n1.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n129.216818\n0.014072\n\n\n3.0\n4.0\n1.0\n1.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n107.602443\n0.147246\n\n\n4.0\n4.0\n1.0\n1.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n129.216818\n0.000000\n\n\n5.0\n4.0\n1.0\n1.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n95.026033\n0.032971\n\n\n6.0\n4.0\n1.0\n2.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n5.215946\n2.477255\n\n\n7.0\n4.0\n1.0\n2.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n7.497472\n1.842969\n\n\n8.0\n4.0\n1.0\n2.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n4.266968\n0.592513\n\n\n9.0\n4.0\n1.0\n2.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n9.260408\n0.089449\n\n\n10.0\n4.0\n1.0\n2.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n5.405535\n0.063385\n\n\n11.0\n4.0\n1.0\n2.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n8.370422\n0.015803\n\n\n12.0\n4.0\n1.0\n3.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n0.833707\n1.786491\n\n\n13.0\n4.0\n1.0\n3.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.871273\n2.689420\n\n\n14.0\n4.0\n1.0\n3.0\n3.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n1.155603\n0.142991\n\n\n15.0\n4.0\n1.0\n3.0\n3.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.697876\n0.615490\n\n\n16.0\n4.0\n1.0\n3.0\n4.0\n2.0\n6.0\n10.0\n0.6\n144.0\n1.099929\n0.925463\n0.009072\n\n\n17.0\n4.0\n1.0\n3.0\n4.0\n2.0\n6.0\n10.0\n0.8\n144.0\n1.099929\n0.540083\n0.186033\n\n\n18.0\n4.0\n2.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.6\n144.0\n0.091630\n134.540431\n0.676479\n\n\n19.0\n4.0\n2.0\n1.0\n2.0\n2.0\n6.0\n10.0\n0.8\n144.0\n0.091630\n106.515917\n1.263302\n\n\n\n\n\n\n\n\nFinally the following will give you a nice dictionary of all of your scenarios.\n\npd.DataFrame.from_dict(all_scenarios_dicts)\n\n\n\n\n\n\n\n\n\npatient_inter\nmean_reception_time\nmean_n_consult_time\nmean_d_consult_time\nnumber_of_receptionists\nnumber_of_nurses\nnumber_of_doctors\nprob_seeing_doctor\n\n\n\n\n0\n4\n2\n6\n10\n1\n1\n2\n0.6\n\n\n1\n4\n2\n6\n10\n1\n1\n2\n0.8\n\n\n2\n4\n2\n6\n10\n1\n1\n3\n0.6\n\n\n3\n4\n2\n6\n10\n1\n1\n3\n0.8\n\n\n4\n4\n2\n6\n10\n1\n1\n4\n0.6\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1291\n12\n3\n14\n20\n2\n3\n2\n0.8\n\n\n1292\n12\n3\n14\n20\n2\n3\n3\n0.6\n\n\n1293\n12\n3\n14\n20\n2\n3\n3\n0.8\n\n\n1294\n12\n3\n14\n20\n2\n3\n4\n0.6\n\n\n1295\n12\n3\n14\n20\n2\n3\n4\n0.8\n\n\n\n\n1296 rows × 8 columns",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Testing Large Numbers of Scenarios</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html",
    "href": "running_parallel_cpus.html",
    "title": "27  Parallelisation",
    "section": "",
    "text": "27.1 A simple joblib example\nFirst, it may be helpful to see a simpler example of joblib.\nLet’s start by looking at a for loop to square the numbers 1 to 10.\nsquared_numbers = []\nfor i in range(1, 11, 1):\n  squared_numbers.append(i * i)\n\nprint(squared_numbers)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nWe can simplify the code above into a list comprehension.\n[i*i for i in range(1, 11, 1)]\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nWhy is this important? Well, to use joblib, it’s easiest to write our loop as a list comprehension.\nInstead of doing i * i to square our number, we have made a new function that does the same thing.\nfrom joblib import Parallel, delayed\n\ndef multiply_by_self(input_number):\n  return input_number * input_number\n\nParallel(n_jobs=2)(delayed(multiply_by_self)(i) for i in range(1, 11, 1))\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#a-code-example",
    "href": "running_parallel_cpus.html#a-code-example",
    "title": "27  Parallelisation",
    "section": "27.2 A code example",
    "text": "27.2 A code example\n\n\n\n\n\n\nNote\n\n\n\nThanks go to Michael Allen for providing an example of how this can be achieved in SimPy. His repository can be found here.\n\n\nWe will make use of the Joblib package to easily split our SimPy code to run across multiple processor cores.\nWe will take the model created in the Reproducibility chapter (Chapter 14) and add parallelisation to it.\n\n27.2.1 Library imports\nWe will need to import Parallel and delayed from the joblib library.\nYou will need to run !pip install joblib if you have not previously made use of this library.\n\nfrom joblib import Parallel, delayed\n\n\n\n27.2.2 The g, Patient and Model classes\nOur g, patient and model classes are unchanged.\n\n\n27.2.3 The trial class\nIn the trial class, we need to change a number of functions, tweak our attributes, and make use of the joblib library.\n\n\n\n\n\n\nWarning\n\n\n\nBecause of the way joblib executes things, if we try to keep track of our results in the same way we have so far - setting up a dummy dataframe and then using the .loc accessor to write our results to the correct row of the dataframe for each run - we will end up with an empty results list.\nInstead, we will create an empty list. Into this list we will place a dictionary of results from the run.\n\n\n\n27.2.3.1 The init method\nLet’s start by adjusting our __init__ method for our new way of carrying out the results collection.\n\ndef  __init__(self):\n    self.df_trial_results = []\n\n\n\n27.2.3.2 The process_trial_results method\nNext we want to create a new method that will turn our list of dictionaries into a Python dataframe.\nAll we need to do is call pd.DataFrame on that object. In this case, we overwrite the original df_trial_results object.\nNext we set the index of the dataframe to the run number, which is how it was set up in the original code.\n\ndef process_trial_results(self):\n  self.df_trial_results = pd.DataFrame(self.df_trial_results)\n  self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n27.2.3.3 the print_trial_results method\nBecause we went to the effort of setting the index in the step above, this method can remain unchanged.\n\n\n27.2.3.4 the run_single method\nFirst, let’s look back at how our run_trial function was written before.\n\ndef run_trial(self):\n        print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\")\n        print(\"\") # Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_recep,\n                my_model.mean_q_time_nurse,\n                my_model.mean_q_time_doctor\n                ]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n\nTo use parallelisation, we now split this out into two separate functions. The first is the run_single method.\nNote that it’s very similar to the indented part of the for loop from the code above.\nThe main change is how the results are stored - they are now put into a dictionary. Remember, dictionaries use the format {“key”:value} - here we have made our column names the ‘keys’ and our results the ‘values’.\nFinally, it’s important to return the results object from the function.\n\ndef run_single(self, run):\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results (just mean queuing time\n    # here) and store it against the run number in the trial results\n    # dataframe.\n    random.seed(run)\n\n    my_model = Model(run)\n    patient_level_results = my_model.run()\n\n    results = {\"Run Number\":run,\n        \"Arrivals\": len(patient_level_results),\n        \"Mean Q Time Recep\": my_model.mean_q_time_recep,\n        \"Mean Q Time Nurse\": my_model.mean_q_time_nurse,\n        \"Mean Q Time Doctor\": my_model.mean_q_time_doctor\n        }\n\n    return results\n\n\n\n27.2.3.5 the run_trial method\nFinally, we need to do a few things.\nThe key one is making our trial now use the Parallel class and delayed function.\nWe set up an instance of the Parallel class and set the number of jobs to -1.\n\n\n\n\n\n\nTip\n\n\n\n-1 just means that the joblib library will use every available core to run the code.\nYou can instead specify a particular number of cores to use as a positive integer value.\n\n\nWe then pass in the self.run_single function to the delayed function.\nFinally, we pass in the arguments that are required for the self.run_single function, which is just the run number.\nThe syntax can appear a little bit strange - just take a close look at the full line below and try and understand it.\n\nself.df_trial_results = Parallel(n_jobs=-1)(delayed(self.run_single)(run) for run in range(g.number_of_runs))\n\nWe assign all of this to the self.df_trial_results attribute of our class.\nNow the only additional step is to run our new process_trial_results() function before we run print_trial_results().\n\ndef run_trial(self):\n    print(f\"{g.number_of_receptionists} receptionists, {g.number_of_nurses} nurses, {g.number_of_doctors} doctors\")\n    print(\"\") # Print a blank line\n\n    # Run the simulation for the number of runs specified in g class.\n    self.df_trial_results = Parallel(n_jobs=-1)(delayed(self.run_single)(run) for run in range(g.number_of_runs))\n\n    # Once the trial (ie all runs) has completed, print the final results\n    self.process_trial_results()\n    self.print_trial_results()\n\nVoila! Our model is now set up to use parallelisation. Let’s take a look at how much faster this can make things.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#evaluating-the-code-outputs",
    "href": "running_parallel_cpus.html#evaluating-the-code-outputs",
    "title": "27  Parallelisation",
    "section": "27.3 Evaluating the code outputs",
    "text": "27.3 Evaluating the code outputs\nFirst, let’s run this the original way and time how long it takes.\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0              102.0               0.00              57.19                1.15\n1              125.0               1.84             144.69                0.02\n2              112.0               0.85              15.30                1.13\n3              120.0               1.08              82.67                0.04\n4              132.0               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n995             97.0               0.59              36.91                0.00\n996            111.0               1.10              68.32                0.18\n997            129.0               0.99             122.27                0.06\n998            140.0               1.73              92.57                0.30\n999            109.0               0.67              45.83                0.39\n\n[1000 rows x 4 columns]\nArrivals              120.98\nMean Q Time Recep       1.31\nMean Q Time Nurse      62.75\nMean Q Time Doctor      0.50\ndtype: float64\n\nIt took 33.9753 seconds to do 10 runs without parallelisation\n\n\nNow let’s run it again with parallisation.\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\n\n\n\n\n\n1 receptionists, 1 nurses, 2 doctors\n\nTrial Results\n            Arrivals  Mean Q Time Recep  Mean Q Time Nurse  Mean Q Time Doctor\nRun Number                                                                    \n0                102               0.00              57.19                1.15\n1                125               1.84             144.69                0.02\n2                112               0.85              15.30                1.13\n3                120               1.08              82.67                0.04\n4                132               1.94             107.47                0.51\n...              ...                ...                ...                 ...\n995               97               0.59              36.91                0.00\n996              111               1.10              68.32                0.18\n997              129               0.99             122.27                0.06\n998              140               1.73              92.57                0.30\n999              109               0.67              45.83                0.39\n\n[1000 rows x 4 columns]\nArrivals              120.98\nMean Q Time Recep       1.31\nMean Q Time Nurse      62.75\nMean Q Time Doctor      0.50\ndtype: float64\n\nIt took 5.5678 seconds to do 10 runs **with** parallelisation",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "running_parallel_cpus.html#evaluating-speed-gains",
    "href": "running_parallel_cpus.html#evaluating-speed-gains",
    "title": "27  Parallelisation",
    "section": "27.4 Evaluating speed gains",
    "text": "27.4 Evaluating speed gains\nLet’s run the model a few times, specifying a different number of cores to run it on each time.\nThis book is being compiled on a machine with a 14 core processor.\nAn argument has been added to the run_trial function to allow us to pass in the number of cores to use.\nThe results below all relate to 100 runs of the simulation.\n\nspeed = []\n\ng.number_of_runs = 100\n\nfor i in range(1, 15, 1):\n    start_time = time.time()\n    # Create an instance of the Trial class\n    my_trial = Trial()\n\n    # Call the run_trial method of our Trial object\n    my_trial.run_trial(cores=i)\n\n    run_time = round((time.time() - start_time), 3)\n\n    speed.append({\"Cores\":i, \"Run Time (seconds)\": run_time})\n\ntiming_results = pd.DataFrame(speed)\n\nprint(timing_results)\n\n    Cores  Run Time (seconds)\n0       1               3.426\n1       2               2.255\n2       3               1.606\n3       4               1.382\n4       5               1.210\n5       6               1.112\n6       7               1.070\n7       8               0.744\n8       9               0.717\n9      10               0.679\n10     11               1.047\n11     12               0.612\n12     13               0.598\n13     14               0.587\n\n\n\n\n                                                \n\n\nLet’s run it again and look at the speed gains when doing 1000 runs of the simulation.\nNotice that doubling the number of cores doesn’t halve the time - there is fixed overhead that will take a certain amount of time. This can be even more noticeable with a smaller number of runs.\nWe make big gains at the beginning, but the fixed overheads mean that higher numbers of cores start to have less and less of an effect.\n\n\n    Cores  Run Time (seconds)\n0       1              33.056\n1       2              17.977\n2       3              13.033\n3       4              10.535\n4       5               8.910\n5       6               7.845\n6       7               7.298\n7       8               6.645\n8       9               6.406\n9      10               6.072\n10     11               6.202\n11     12               5.715\n12     13               5.530\n13     14               5.396",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Parallelisation</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html",
    "href": "intro_creating_web_apps.html",
    "title": "28  Creating Web Apps",
    "section": "",
    "text": "28.1 Video guide: creating a streamlit web app interface for a DES model\nThis video is the masterclass on Streamlit interfaces from the fifth round of the HSMA programme. This is delivered by Tom Monks, another member of the PenCHORD team.\n{{ &lt; video https://youtu.be/6e0OPsjRYQ8?si=YxA80wwKm5J-UjAb &gt;}}\nThe classes and structure used for the model are very slightly different to the style used in this book, but overall the techniques are very applicable.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html#video-guide-creating-a-streamlit-web-app-interface-for-a-des-model",
    "href": "intro_creating_web_apps.html#video-guide-creating-a-streamlit-web-app-interface-for-a-des-model",
    "title": "28  Creating Web Apps",
    "section": "",
    "text": "28.1.1 Book\nA book has also been written to accompany the above tutorial.\nThe book can be accessed (here)[https://health-data-science-or.github.io/simpy-streamlit-tutorial/content/03_streamlit/01_intro.html].",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "intro_creating_web_apps.html#example-apps",
    "href": "intro_creating_web_apps.html#example-apps",
    "title": "28  Creating Web Apps",
    "section": "28.2 Example apps",
    "text": "28.2 Example apps\n\n28.2.1 The DES Playground\nThe following app contains a range of pages that allow users to explore a DES model of growing complexity.\nYou can see the range of sliders and inputs that you can make available to your end users.\n\n:::{.callout-warning} Note that this link will not work if you are viewing this book in Firefox. All other major browsers should work, including mobile browsers. ::\nThe full code can be seen here.\nLook at the code within the pages subfolder to see how different features are implemented.\nOther features that may be useful to adapt for your own use include - the ability to save and compare the results from multiple scenarios - a range of interactive visualisations of simulation metrics\n\n\n28.2.2 The HSMA SimPy Example Library\nAs part of the SimPy visualisation library project, a range of different SimPy models have been created with a Streamlit frontend.\n\nThe code for all of these examples can be explored in this Github Repository.\nIn each case, the code for the model classes, simulation execution and simulation summary functions can be found inside a subfolder within the examples folder.\nNote that again the classes and format used for these models differs slightly from the examples given in this book, but are fundamentally very similar so should be possible to adapt.",
    "crumbs": [
      "Part 4 - Advanced Concepts",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Creating Web Apps</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html",
    "href": "alternative_foss_simulation_libraries_software.html",
    "title": "29  Alternative FOSS Simulation Libraries and Software",
    "section": "",
    "text": "29.1 Python Libraries",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#python-libraries",
    "href": "alternative_foss_simulation_libraries_software.html#python-libraries",
    "title": "29  Alternative FOSS Simulation Libraries and Software",
    "section": "",
    "text": "29.1.1 ciw\n\n\n29.1.2 salabim",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#r-libraries",
    "href": "alternative_foss_simulation_libraries_software.html#r-libraries",
    "title": "29  Alternative FOSS Simulation Libraries and Software",
    "section": "29.2 R Libraries",
    "text": "29.2 R Libraries\n\n29.2.1 simmeR",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "alternative_foss_simulation_libraries_software.html#gui-software",
    "href": "alternative_foss_simulation_libraries_software.html#gui-software",
    "title": "29  Alternative FOSS Simulation Libraries and Software",
    "section": "29.3 GUI Software",
    "text": "29.3 GUI Software\n\n29.3.1 JaamSim",
    "crumbs": [
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Alternative FOSS Simulation Libraries and Software</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "30  Further Reading",
    "section": "",
    "text": "30.1 SimPy Examples\nA list of additional SimPy examples is kept up-to-date here.",
    "crumbs": [
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Further Reading</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]