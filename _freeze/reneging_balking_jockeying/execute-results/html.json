{
  "hash": "2485aa4dcca831e94a8a1ec01b54dfbe",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Reneging, Balking and Jockeying'\nauthor:\n  - name: Sammi Rosser\n    orcid: 0000-0002-9552-8988\n    url: 'https://github.com/Bergam0t'\n  - name: Dan Chalk\n    orcid: 0000-0002-4165-4364\n    url: 'https://github.com/hsma-chief-elf'\nexecute:\n  eval: false\n---\n\nNot all queues run “as planned”. We may wish to model behaviours where entities stop waiting, switch queues, or never join the queue in the first place.\n\n**Reneging** refers to an entity removing themselves from a queue after a certain amount of time has elapsed (eg person not willing to wait any longer, or test sample no longer being viable)\n\n**Balking** refers to an entity not entering a queue in the first place because of the length and / or capacity of the queue (eg person seeing long queue or no capacity in waiting room)\n\n**Jockeying** refers to an entity switching queues in the hope of reducing queuing time. (eg switching till queues at the supermarket)\n\n![](images/reneging_balking_jockeying_overview.png)\n\n## Reneging\n\nLet’s imagine that each of our patients has a patience level - an amount of time they’re prepared to wait for the nurse.\n\nTo model this, we:\n\n- Add patience level as an attribute to each patient, with some way of determining what a patient’s patience is.\n- When we request a resource, we’ll tell SimPy to either wait until the request can be met OR until the patient’s patience has expired (whichever comes first).\n- We’ll then check what happened - did the patient wait or did they renege?  If they waited, we’ll proceed as before.  If they reneged, then they won’t see the nurse, and we’ll record that they reneged.\n- We’ll add the number of patients that reneged to our outputs from each run, and take the average number of patients who reneged per run over the trial.\n\n### Coding a reneging example\n\n:::{.callout-tip}\nThroughout the code, anything new that's been added will be followed by the comment `##NEW` - so look out for that in the following code chunks.\n:::\n\n#### g class\nThe g class is unchanged.\n\n#### Patient class\n\nIn the patient class, we add a patience attribute.\n\nThis determines how long the patient is prepared to wait for the nurse.\n\nHere we just randomly sample an integer between 5 and 50 (so the patient will be\nprepared to wait for somewhere between 5 and 50 minutes in the queue),  but in a real world application you would probably want to have a  more refined way of allocating patience to patients (e.g basing probabilities off prior data, or using a non-uniform named distribution).\n\nYou could have different patience levels for different queues, or just a general patience level.  Or even get creative and have a patience level that decreases the longer they've been in the system if your system has multiple steps!\n\nIf we want to see the effect of this, we can try changing the patience levels - but you'll need to make the patience levels MUCH higher as this system is in bad shape (after 3 days patients are waiting on average over 3 hours... and a lot are waiting much longer!)\n\nMaybe try adding another nurse in to get the system under control first!\n\n::: {#32af1537 .cell execution_count=1}\n``` {.python .cell-code}\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        self.patience_nurse = random.randint(5, 50) ##NEW\n```\n:::\n\n\n#### Model class\n\n##### The __init__ method\n\nIn the init method, we set up an additional attribute to track the number of people reneging.\n\n::: {#0924bd7c .cell execution_count=2}\n``` {.python .cell-code}\ndef __init__(self, run_number):\n    # Set up SimPy environment\n    self.env = simpy.Environment()\n\n    # Set up counters to use as entity IDs\n    self.patient_counter = 0\n\n    # Set up resources\n    self.nurse = simpy.PriorityResource(self.env,\n                                        capacity=g.number_of_nurses)\n\n    # Set run number from value passed in\n    self.run_number = run_number\n\n    # Set up DataFrame to store patient-level results\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Q Time Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Set up attributes that will store mean queuing times across the run\n    self.mean_q_time_nurse = 0\n\n    ##NEW - we'll set up a new attribute that will store the number of\n    # people that reneged from queues in the run (we only have one queue in\n    # this model)\n    self.num_reneged_nurse = 0\n\n    random.seed(42)\n```\n:::\n\n\n##### The attend_clinic method\n\nIn the attend clinic, we now add in an OR statement (the vertical line | , also known as a pipe) to our request for the nurse.\n\n::: {#b3408bc4 .cell execution_count=3}\n``` {.python .cell-code}\nresult_of_queue = (yield req | self.env.timeout(patient.patience_nurse))\n```\n:::\n\n\nIt basically says \"Wait for the request for the nurse to be fulfilled OR until the patient's patience level has passed, whichever comes first, and then store whatever the outcome was.\n\nWe then need to check whether we got our req - the resource we requested - or whether the timeout occurred.\n\nWe do this with conditional logic:\n\n::: {#3f531003 .cell execution_count=4}\n``` {.python .cell-code}\nif req in result_of_queue:\n```\n:::\n\n\nThe indented code after this statement will only take place if the resource became available before the patient's patience ran out (i.e. if the resource became available before the patience period elapsed).\n\n::: {#82a6df46 .cell execution_count=5}\n``` {.python .cell-code}\ndef attend_clinic(self, patient):\n    # Nurse consultation activity\n    start_q_nurse = self.env.now\n\n    with self.nurse.request(priority=patient.priority) as req:\n        ##NEW\n        result_of_queue = (yield req |\n                            self.env.timeout(patient.patience_nurse))\n\n        ##NEW - we now need to check whether the patient waited or reneged,\n        # as we could have got to this point of the generator function\n        # either way.  We'll now only get them to see the nurse if they\n        # waited.  If they didn't wait, we'll add to our counter of how\n        # many patients reneged from the queue.\n        if req in result_of_queue:\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now > g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)\n        else:\n            self.num_reneged_nurse += 1\n\n            print (f\"Patient {patient.id} reneged after waiting\",\n                    f\"{patient.patience_nurse} minutes\")\n```\n:::\n\n\n##### The run method\n\nThe only change to the run method is adding a print statement to the end of it to print the patients who reneged.\n\n::: {#1d2fb51f .cell execution_count=6}\n``` {.python .cell-code}\nprint (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n```\n:::\n\n\n#### Trial class\n\n##### The __init__ method\n\nIn the init method, we add in an addiitonal attribute that is a placeholder column for the number of people in each run who reneged.\n\n::: {#ccbcba14 .cell execution_count=7}\n``` {.python .cell-code}\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    ##NEW - additional column of trial results to store the number of\n    # patients that reneged in each run\n    self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n```\n:::\n\n\n##### The calculate_means_over_trial method\n\nWe also now need to calculate the mean number of patients reneging per run.\n\n::: {#b716dd77 .cell execution_count=8}\n``` {.python .cell-code}\ndef calculate_means_over_trial(self):\n    self.mean_q_time_nurse_trial = (\n        self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n    )\n\n    ##NEW\n    self.mean_reneged_q_nurse = (\n        self.df_trial_results[\"Reneged Q Nurse\"].mean()\n    )\n```\n:::\n\n\n##### The print_trial_results method\n\n::: {#7ffdf078 .cell execution_count=9}\n``` {.python .cell-code}\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n    ##NEW - we will also now print out the mean number of patients who\n    # reneged from the nurse's queue per run\n    print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n```\n:::\n\n\n##### The run_trial method\n\nWe also need to add the number of patients who reneged from the nurse's queue as one of the results against each run.\n\n::: {#e49eeb92 .cell execution_count=10}\n``` {.python .cell-code}\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_reneged_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n```\n:::\n\n\n### The full code\n\nThe full updated code for the model is given below.\n\n::: {.callout-note collapse=\"true\"}\n#### Click here to view the full code\n\n::: {#458fcb0c .cell execution_count=11}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 120\n    number_of_runs = 1\n    warm_up_period = 360\n\n    random.seed(42)\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n        ##NEW - added a new patience attribute of the patient.  This determines\n        # how long the patient is prepared to wait for the nurse.  Here we just\n        # randomly sample an integer between 5 and 50 (so the patient will be\n        # prepared to wait for somewhere between 5 and 50 minutes in the queue),\n        # but in a real world application you would probably want to have a\n        # more refined way of allocating patience to patients (e.g basing\n        # probabilities off prior data, or using a non-uniform named\n        # distribution).  You could have different patience levels for different\n        # queues, or just a general patience level.  Or even get creative and\n        # have a patience level that decreases the longer they've been in the\n        # system!\n        # If we want to see the effect of this, we can try changing the patience\n        # levels - but you'll need to make the patience levels MUCH higher as\n        # this system is in bad shape (remember, after 3 days patients are\n        # waiting on average over 3 hours... and a lot are waiting much longer!)\n        # Maybe try adding another nurse in to get the system under control\n        # first!\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        ##NEW - we'll set up a new attribute that will store the number of\n        # people that reneged from queues in the run (we only have one queue in\n        # this model)\n        self.num_reneged_nurse = 0\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            ##NEW - this statement now uses a vertical bar (|) / pipe as an \"or\"\n            # statement.  It basically says \"Wait for the request for the nurse\n            # to be fulfilled OR until the patient's patience level has passed,\n            # whichever comes first, and then store whatever the outcome was.\n            result_of_queue = (yield req |\n                               self.env.timeout(patient.patience_nurse))\n\n            ##NEW - we now need to check whether the patient waited or reneged,\n            # as we could have got to this point of the generator function\n            # either way.  We'll now only get them to see the nurse if they\n            # waited.  If they didn't wait, we'll add to our counter of how\n            # many patients reneged from the queue.\n            if req in result_of_queue:\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now > g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n            else:\n                self.num_reneged_nurse += 1\n\n                print (f\"Patient {patient.id} reneged after waiting\",\n                       f\"{patient.patience_nurse} minutes\")\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - we'll print out the number of patients that reneged from the\n        # nurse queue in this run of the model.\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - additional column of trial results to store the number of\n        # patients that reneged in each run\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - we also now need to calculate the mean number of patients\n        # reneging per run\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - we will also now print out the mean number of patients who\n        # reneged from the nurse's queue per run\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - we also need to add the number of patients who reneged from\n            # the nurse's queue as one of the results against each run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\nWhat are the outputs?\n\n::: {#041ce465 .cell execution_count=12}\n``` {.python .cell-code}\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 4 reneged after waiting 10 minutes\nPatient 9 reneged after waiting 22 minutes\nPatient 12 reneged after waiting 11 minutes\nPatient 8 reneged after waiting 31 minutes\nPatient 16 reneged after waiting 10 minutes\nPatient 21 reneged after waiting 15 minutes\nPatient 41 reneged after waiting 5 minutes\nPatient 34 reneged after waiting 32 minutes\nPatient 35 reneged after waiting 28 minutes\nPatient 51 reneged after waiting 6 minutes\nPatient 61 reneged after waiting 12 minutes\nPatient 57 reneged after waiting 43 minutes\nPatient 63 reneged after waiting 19 minutes\nPatient 67 reneged after waiting 22 minutes\nPatient 74 reneged after waiting 8 minutes\nPatient 75 reneged after waiting 11 minutes\nPatient 80 reneged after waiting 5 minutes\nPatient 78 reneged after waiting 9 minutes\nPatient 70 reneged after waiting 31 minutes\nPatient 79 reneged after waiting 11 minutes\nPatient 77 reneged after waiting 16 minutes\nPatient 69 reneged after waiting 41 minutes\nPatient 92 reneged after waiting 10 minutes\nPatient 91 reneged after waiting 15 minutes\nPatient 95 reneged after waiting 20 minutes\nPatient 98 reneged after waiting 18 minutes\nPatient 97 reneged after waiting 41 minutes\nRun Number 0\n            Q Time Nurse\nPatient ID              \n72             29.775128\n81              0.000000\n82              2.882096\n83              0.497733\n84              3.535558\n85              0.000000\n86              4.253027\n88              1.246385\n89              0.975995\n87             15.898992\n90             13.091388\n93              5.540775\n96              4.973317\n94             14.738309\n100             4.846364\n99             12.956481\n101            11.904287\n102             3.337391\n104             4.246539\n27 patients reneged from nurse queue\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse\nRun Number                                    \n0                    7.089461               27\nMean Q Nurse : 7.1 minutes\nMean Reneged Q Nurse : 27.0 patients\n```\n:::\n:::\n\n\nWe can see that not every patient is reneging.\n\nWe can also see that some patients who arrived in the system later balk earlier than patients who have been there longer (i.e. a patient with a later ID balks before a patient with an earlier ID). This is due to the randomly set reneging threshold for each patient - some people aren't willing to wait as long.\n\n## Balking\n\nFor balking, there are two different ways in which balking can occur (and both could occur in the same model):\n\n- An entity may choose not to join a queue because it is too long for their preferences / needs.\n- An entity may not be able to join a queue because there is no capacity for them.\n\nWe will look at the latter, but the way we approach it is the same for both - the only difference is that, in the former, the maximum queue length is likely to be an attribute of the patient (and may be individual per patient) just like in the reneging example, rather than an attribute of the model.\n\nHere, we’ll imagine that in our clinic, there is only space for 3 people to wait to see the nurse, and if there is no space, they cannot wait.\n\nTo model our balking requirements, we will:\n\n- Add a parameter to g class to store the maximum queue length allowed (if this were patient-decided balking, we’d put this in the patient class instead).\n- Add a list to our model attributes that will store all the patient objects currently in the queue for the nurse.  This is really useful as it allows us to see who is in the queue at any time, as well as how many etc.\n- Whenever a patient joins or leaves the queue, we’ll update the list of patients in the queue.\n- Before we ask for the nurse resource, we’ll first check if the queue is at maximum size.  If it is, the patient will never join the queue and we’ll record that.  If not, we’ll proceed as before.\n\nWe’ll add results of number of patients who balked to our results.\n\n### Coding a balking example\n\n#### g class\n\nWe'll add a parameter value that will store the maximum length of the queue we allow for the nurse.\n\nLet's imagine there's only space for 3 people in the waiting room and so no more than 3 people can wait at any\ntime.\n\n:::{.callout-note}\nNote - we could simulate balking from the perspective of the patient instead (or as well) - e.g. the patient will only wait if there  are no more than x people waiting etc.  If we did this, we'd probably want to make this level an attribute of the patient, as it may vary between patients.\n:::\n\n::: {#4901b36a .cell execution_count=13}\n``` {.python .cell-code}\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    ##NEW\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 100\n    warm_up_period = 1440\n```\n:::\n\n\n#### Patient class\n\nThis class is unchanged.\n\n#### Model class\n\n##### The __init__ method\n\nHere we add in an additional attribute to count the number of people who balk.\n\nWe also we add a list that will store patient objects queuing for the nurse consultation.  This will allow us to see who is in the queue at any time, as well as the length of the queue etc.a reneging example\n\n::: {#60a17230 .cell execution_count=14}\n``` {.python .cell-code}\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW\n\n        self.q_for_nurse_consult = [] ##NEW\n```\n:::\n\n\n##### The generator_patient_arrival method\n\nThis method is unchanged.\n\n##### The attend_clinic method\n\n::: {#241d48b7 .cell execution_count=15}\n``` {.python .cell-code}\ndef attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) < g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now > g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n```\n:::\n\n\n##### The calculate_run_results method\n\nThis method is unchanged.\n\n##### The run method\n\nHere we have added a print message displaying how many patients balked in this run.\n\n::: {#95e412cc .cell execution_count=16}\n``` {.python .cell-code}\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    # Print patient level results for this run\n    print (f\"Run Number {self.run_number}\")\n    print (self.results_df)\n    print (f\"{self.num_balked_nurse} patients balked at the nurse queue\") ##NEW\n```\n:::\n\n\n#### Trial class\n\n##### The __init__ method\n\nFirst we add in a column to store the number who balked at the nurse queue in each run.\n\n::: {#b4a8afa9 .cell execution_count=17}\n``` {.python .cell-code}\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n    self.df_trial_results[\"Balked Q Nurse\"] = [0] ##NEW\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n```\n:::\n\n\n##### The calculate_means_over_trial method\n\nWe add a calculation of mean number of patients who balked at the nurse queue per run.\n\n::: {#2f42fd1e .cell execution_count=18}\n``` {.python .cell-code}\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n```\n:::\n\n\n##### The print_trial_results method\n\nWe add in a print message of mean number of patients balking at nurse queue per run.\n\n::: {#28e40405 .cell execution_count=19}\n``` {.python .cell-code}\ndef print_trial_results(self):\n    print (\"Trial Results\")\n    print (self.df_trial_results)\n\n    print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n\n    print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\") ##NEW\n```\n:::\n\n\n##### The run_trial method\n\nFinally we add the number that balked at the nurse queue to results in the run.\n\n::: {#b6999f0f .cell execution_count=20}\n``` {.python .cell-code}\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                            my_model.num_balked_nurse] ##NEW\n\n    self.calculate_means_over_trial()\n    self.print_trial_results()\n```\n:::\n\n\n### The full code\n\nThe full updated code for the model is given below.\n\n::: {.callout-note collapse=\"true\"}\n#### Click here to view the full code\n\n::: {#d4583c64 .cell execution_count=21}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - we'll add a parameter value that will store the maximum length of\n    # the queue we allow for the nurse.  Let's imagine there's only space for 3\n    # people in the waiting room and so no more than 3 people can wait at any\n    # time.  Note - we could simulate balking from the perspective of the\n    # patient instead (or as well) - e.g. the patient will only wait if there\n    # are no more than x people waiting etc.  If we did this, we'd probably\n    # want to make this level an attribute of the patient, as it may vary\n    # between patients.\n    max_q_nurse = 3\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 3\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_balked_nurse = 0 ##NEW - added to record number balking\n\n        ##NEW - we add a list that will store patient objects queuing for the\n        # nurse consultation.  This will allow us to see who is in the queue at\n        # any time, as well as the length of the queue etc\n        self.q_for_nurse_consult = []\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        ##NEW - we now first check whether there is room for the patient to\n        # wait.  If there is, then proceed as before.  If not, then the patient\n        # never joins the queue, and we record that a patient balked.\n        if len(self.q_for_nurse_consult) < g.max_q_nurse:\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            ##NEW - add the patient object to the list of patients queuing for\n            # the nurse\n            self.q_for_nurse_consult.append(patient)\n\n            with self.nurse.request(priority=patient.priority) as req:\n                yield req\n\n                ##NEW - remove the patient object from the list of patients\n                # queuing for the nurse (by putting it here, the patient will\n                # be removed whether they waited or reneged)\n                self.q_for_nurse_consult.remove(patient)\n\n                end_q_nurse = self.env.now\n\n                patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                if self.env.now > g.warm_up_period:\n                    self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                        patient.q_time_nurse\n                    )\n\n                sampled_nurse_act_time = Lognormal(\n                    g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                yield self.env.timeout(sampled_nurse_act_time)\n\n        else:\n            self.num_balked_nurse += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        ##NEW - added print message displaying how many patients balked in this\n        # run\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store the number who balked at the nurse queue\n        # in each run\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        ##NEW - added calculation of mean number of patients who balked at the\n        # nurse queue per run\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        ##NEW - added print message of mean number of patients balking at nurse\n        # queue per run\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW - added number balked at nurse queue to results in the run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_balked_nurse]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\nWhat are the outputs?\n\nWe are doing three runs in this case.\n\n::: {#a1bce2aa .cell execution_count=22}\n``` {.python .cell-code}\n# Create new instance of Trial and run it\nmy_trial = Trial()\nmy_trial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Number 0\n            Q Time Nurse\nPatient ID              \n285             1.187896\n286             6.171316\n287             8.404058\n284            27.968353\n289             0.000000\n...                  ...\n874            10.401421\n875            15.042325\n879             3.874218\n876            18.374498\n881             4.260767\n\n[448 rows x 1 columns]\n215 patients balked at the nurse queue\nRun Number 1\n            Q Time Nurse\nPatient ID              \n266             3.427072\n267             2.909220\n268             4.149866\n270             1.517552\n271             4.371772\n...                  ...\n836             5.166214\n837             3.093724\n831            43.525229\n839             2.747625\n840             8.486514\n\n[453 rows x 1 columns]\n165 patients balked at the nurse queue\nRun Number 2\n            Q Time Nurse\nPatient ID              \n298             6.192226\n297            14.968568\n300             5.139509\n302             2.315511\n303             4.039407\n...                  ...\n907             9.574678\n908             3.791233\n909             2.115460\n910             0.588321\n911             5.172178\n\n[464 rows x 1 columns]\n216 patients balked at the nurse queue\nTrial Results\n            Mean Q Time Nurse  Balked Q Nurse\nRun Number                                   \n0                   10.743632           215.0\n1                   10.645624           165.0\n2                   10.539909           216.0\nMean Q Nurse : 10.6 minutes\nMean Balked Q Nurse : 198.66666666666666 patients\n```\n:::\n:::\n\n\nWe can see that we have patients reneging, but due to the random variation across the arrivals and consult times, the size of the queue is different at different points in time, so we get variation in the patients balking each time.\n\n## Jockeying\n\nTrue jockeying involves entities switching from one queue to another, typically because they make a decision that they will likely be seen faster if they do.\n\nIn over 13 years, the author has never used jockeying to model a healthcare system.  SimPy documentation does not cover it either and makes a point of saying they won’t (which implies it’s complicated, though fundamentally you’d need a model of the behaviour in making that decision combined with removing the entity from one queue and placing it in another).\n\nThere are likely to be few systems that you will model that would use jockeying.  However, you might encounter systems where entities pick which queue to join in the first place based on queue length (eg patients deciding which Minor Injury Unit or Emergency Department to attend based on live waiting time data online).\n\nFor that reason, the example here will be based on this kind of model.\n\n### A 'choosing queues' example\n\nLet’s imagine a slight change to our nurse clinic model.\n\nLet’s imagine that, as well as the nurse, there is also a doctor that patients can see that offers the same service.  Patients can choose to join whichever queue they prefer - and they do this by joining the nurse queue if it’s shorter (and the nurse has capacity), and otherwise joining the doctor’s queue.\n\nThe doctor’s queue has no limits on capacity, and the doctor does not take a break (or rather, there is always a doctor available).\n\nConsultation times with the doctor are slightly shorter on average (5 mins vs 6 mins for the nurse), but more variable (with a standard deviation of 3 mins vs 1 min for the nurse).\n\nWe’re also going to imagine that word has got out that there’s now a doctor available too, and demand has more than doubled - patients are now arriving at the clinic every 2 minutes on average, compared to an average of every 5 minutes before.\n\nDue to the new logic, there should never be any patients balking (as they’d join the doctor’s queue if the nurse queue is full, and the doctor’s queue doesn’t have a capacity constraint), but we’ll still record these numbers so we can check that.\n\n### Coding the 'choosing queues' example\n\nThe full updated code for the model is given below.\n\nThis example brings together code for:\n\n- Nurse breaks.\n- Reneging.\n- Balking.\n- Queue choosing.\n\n::: {.callout-note collapse=\"true\"}\n\n#### Click here to view the full code\n\n::: {#671b301c .cell execution_count=23}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\nfrom sim_tools.distributions import Lognormal\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 2 ##NEW - decreased time to generate more frequent arrivals\n\n    # Activity times\n    mean_n_consult_time = 6\n    sd_n_consult_time = 1\n\n    mean_d_consult_time = 5 ##NEW - added mean consult time for doctor\n    sd_d_consult_time = 3 ##NEW - added SD consult time for doctor\n\n    # Resource numbers\n    number_of_nurses = 1\n    number_of_doctors = 1 ##NEW - added parameter to store number of doctors\n\n    # Resource unavailability duration and frequency\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Maximum allowable queue lengths\n    max_q_nurse = 10\n\n    # Simulation meta parameters\n    sim_duration = 480 ##NEW significantly shortened so can see clear queue plot\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.q_time_doc = 0 ##NEW - attribute to store queuing time for doctor\n        self.priority = random.randint(1,5)\n        self.patience_nurse = random.randint(5, 50)\n        ##NEW - added random allocation of patience level to see doctor\n        self.patience_doctor = random.randint(20, 100)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        ##NEW - added doctor resource also as PriorityResource\n        self.doctor = simpy.PriorityResource(self.env,\n                                             capacity=g.number_of_doctors)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        ##NEW - added column to store queuing time for doctor for each patient\n        self.results_df[\"Q Time Doctor\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n        self.mean_q_time_doctor = 0 ##NEW - store mean q time for doctor\n\n        # Set up attributes that will store queuing behaviour results across\n        # run\n        self.num_reneged_nurse = 0\n        self.num_balked_nurse = 0\n\n        ##NEW - added equivalent queuing behaviour attributes for doctor\n        # though no balking should occur for the doctor or the nurse in this\n        # scenario - if there is no capacity in the nurse queue, the patient\n        # will join the doctor queue, which has no limit\n        self.num_reneged_doctor = 0\n        self.num_balked_doctor = 0\n\n        # Set up lists to store patient objects in each queue\n        self.q_for_nurse_consult = []\n        self.q_for_doc_consult = [] ##NEW - list to store queue for doctor\n\n        # Pandas dataframe to record number in queue(s) over time\n        self.queue_df = pd.DataFrame()\n        self.queue_df[\"Time\"] = [0.0]\n        self.queue_df[\"Num in Q Nurse\"] = [0]\n        self.queue_df[\"Num in Q Doctor\"] = [0] ##NEW added column for doctor\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n\n        ##NEW - check whether queue for the nurse is shorter than the queue for\n        # the doctor AND that there is space in the nurse's queue (which is\n        # constrained).  If both of these are true, then join the queue for the\n        # nurse, otherwise join the queue for the doctor.\n        if ((len(self.q_for_nurse_consult) < len(self.q_for_doc_consult)) and\n            (len(self.q_for_nurse_consult) < g.max_q_nurse)):\n            # Nurse consultation activity\n            start_q_nurse = self.env.now\n\n            self.q_for_nurse_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            ##NEW need to also add length of current queue for doctor to the\n            # list (need to add both even though this is just an update to the\n            # length of the nurse list)\n            if self.env.now > g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.nurse.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_nurse))\n\n                self.q_for_nurse_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                ##NEW need to also add length of current queue for doctor to the\n                # list (need to add both even though this is just an update to\n                # the length of the nurse list)\n                if self.env.now > g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_nurse = self.env.now\n\n                    patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n                    if self.env.now > g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                            patient.q_time_nurse\n                        )\n\n                    sampled_nurse_act_time = Lognormal(\n                        g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n                    yield self.env.timeout(sampled_nurse_act_time)\n                else:\n                    self.num_reneged_nurse += 1\n        else:\n            ##NEW - logic for patient to join queue for the doctor instead.\n            # In this system, there should be no balking as if the queue for the\n            # nurse has no more capacity, they'll just see the doctor which\n            # doesn't have a limit.\n\n            # Doctor consultation activity\n            start_q_doc = self.env.now\n\n            self.q_for_doc_consult.append(patient)\n\n            # Record number in queue alongside the current time\n            if self.env.now > g.warm_up_period:\n                self.queue_df.loc[len(self.queue_df)] = [\n                    self.env.now,\n                    len(self.q_for_nurse_consult),\n                    len(self.q_for_doc_consult)\n                ]\n\n            with self.doctor.request(priority=patient.priority) as req:\n                result_of_queue = (yield req |\n                                self.env.timeout(patient.patience_doctor))\n\n                self.q_for_doc_consult.remove(patient)\n\n                # Record number in queue alongside the current time\n                if self.env.now > g.warm_up_period:\n                    self.queue_df.loc[len(self.queue_df)] = [\n                        self.env.now,\n                        len(self.q_for_nurse_consult),\n                        len(self.q_for_doc_consult)\n                    ]\n\n                if req in result_of_queue:\n                    end_q_doc = self.env.now\n\n                    patient.q_time_doc = end_q_doc - start_q_doc\n\n                    if self.env.now > g.warm_up_period:\n                        self.results_df.at[patient.id, \"Q Time Doctor\"] = (\n                            patient.q_time_doc\n                        )\n\n                    sampled_doc_act_time = Lognormal(\n                        g.mean_d_consult_time, g.sd_d_consult_time).sample()\n\n                    yield self.env.timeout(sampled_doc_act_time)\n                else:\n                    self.num_reneged_doctor += 1\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n        ##NEW - added calculation for mean queuing time for doctor\n        self.mean_q_time_doctor = self.results_df[\"Q Time Doctor\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        # Print patient level results for this run\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n        print (f\"{self.num_reneged_nurse} patients reneged from nurse queue\")\n        print (f\"{self.num_balked_nurse} patients balked at the nurse queue\")\n        ##NEW added print statements for reneging and balking from doctor queue\n        print (f\"{self.num_reneged_doctor} patients reneged from the doctor\",\n               \"queue\")\n        print (f\"{self.num_balked_doctor} patients balked at the doctor queue\")\n        # Print queues over time dataframe for this run\n        print (\"Queues over time\")\n        print (self.queue_df)\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Nurse\"] = [0]\n        self.df_trial_results[\"Balked Q Nurse\"] = [0]\n        ##NEW added columns to store number trial results relating to doctor\n        self.df_trial_results[\"Mean Q Time Doctor\"] = [0.0]\n        self.df_trial_results[\"Reneged Q Doctor\"] = [0]\n        self.df_trial_results[\"Balked Q Doctor\"] = [0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n        self.mean_reneged_q_nurse = (\n            self.df_trial_results[\"Reneged Q Nurse\"].mean()\n        )\n\n        self.mean_balked_q_nurse = (\n            self.df_trial_results[\"Balked Q Nurse\"].mean()\n        )\n\n        ##NEW added calculations for doctor queue and activity across trial\n        self.mean_q_time_doc_trial = (\n            self.df_trial_results[\"Mean Q Time Doctor\"].mean()\n        )\n\n        self.mean_reneged_q_doc = (\n            self.df_trial_results[\"Reneged Q Doctor\"].mean()\n        )\n\n        self.mean_balked_q_doc = (\n            self.df_trial_results[\"Balked Q Doctor\"].mean()\n        )\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Nurse : {self.mean_reneged_q_nurse} patients\")\n        print (f\"Mean Balked Q Nurse : {self.mean_balked_q_nurse} patients\")\n\n        ##NEW added print statements for trial results related to doctor\n        print (f\"Mean Q Doctor : {self.mean_q_time_doc_trial:.1f} minutes\")\n        print (f\"Mean Reneged Q Doctor : {self.mean_reneged_q_doc} patients\")\n        print (f\"Mean Balked Q Doctor : {self.mean_balked_q_doc} patients\")\n\n    # Method to run trial\n    def run_trial(self):\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW added doctor results to end of list of results to add for this\n            # run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse,\n                                              my_model.num_reneged_nurse,\n                                              my_model.num_balked_nurse,\n                                              my_model.mean_q_time_doctor,\n                                              my_model.num_reneged_doctor,\n                                              my_model.num_balked_doctor]\n\n        self.calculate_means_over_trial()\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\n::: {#79589597 .cell execution_count=24}\n``` {.python .cell-code}\nmy_trial = Trial()\nmy_trial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Number 0\n            Q Time Nurse  Q Time Doctor\nPatient ID                             \n715                  NaN      10.769071\n722             4.944191            NaN\n717                  NaN      15.113367\n716            17.308768            NaN\n729                  NaN       0.770431\n...                  ...            ...\n961                  NaN       9.896039\n962             9.591018            NaN\n959                  NaN      16.960930\n958            18.176180            NaN\n969             4.431502            NaN\n\n[166 rows x 2 columns]\n198 patients reneged from nurse queue\n0 patients balked at the nurse queue\n95 patients reneged from the doctor queue\n0 patients balked at the doctor queue\nQueues over time\n            Time  Num in Q Nurse  Num in Q Doctor\n0       0.000000             0.0              0.0\n1    1440.447541             3.0              5.0\n2    1440.550052             4.0              5.0\n3    1441.801075             4.0              4.0\n4    1441.816771             3.0              4.0\n..           ...             ...              ...\n502  1913.508621             5.0              6.0\n503  1914.375700             6.0              6.0\n504  1914.919764             6.0              7.0\n505  1915.435042             7.0              7.0\n506  1916.332824             6.0              7.0\n\n[507 rows x 3 columns]\nTrial Results\n            Mean Q Time Nurse  Reneged Q Nurse  Balked Q Nurse  \\\nRun Number                                                       \n0                   10.942746              198               0   \n\n            Mean Q Time Doctor  Reneged Q Doctor  Balked Q Doctor  \nRun Number                                                         \n0                    10.254885                95                0  \nMean Q Nurse : 10.9 minutes\nMean Reneged Q Nurse : 198.0 patients\nMean Balked Q Nurse : 0.0 patients\nMean Q Doctor : 10.3 minutes\nMean Reneged Q Doctor : 95.0 patients\nMean Balked Q Doctor : 0.0 patients\n```\n:::\n:::\n\n\n",
    "supporting": [
      "reneging_balking_jockeying_files"
    ],
    "filters": [],
    "includes": {}
  }
}