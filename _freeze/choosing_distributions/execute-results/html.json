{
  "hash": "5c58fd970825711d53ee17a11f6f0216",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor:\n  - name: Sammi Rosser\n    orcid: 0000-0002-9552-8988\n    url: 'https://github.com/Bergam0t'\n  - name: Dan Chalk\n    orcid: 0000-0002-4165-4364\n    url: 'https://github.com/hsma-chief-elf'\nexecute:\n  eval: false\n---\n\n# Choosing Distributions {#sec-distributions}\n\n:::{.callout-note title=\"Acknowledgements\"}\n\nThe `LogNormal` class in this section is taken from the package [sim-tools](https://github.com/TomMonks/sim-tools), which was written by [Tom Monks](https://github.com/TomMonks) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0003-2631-4481) from the PenCHORD team at the University of Exeter.\n:::\n\nIn the previous session, we mentioned that whilst it’s a useful tip to start by having all of the distributions in our model be Exponential (because it’s easy to tweak an Exponential Distribution), for real world models we probably want to then adapt them to use a Lognormal Distribution for activity times.\n\nA Lognormal Distribution is commonly used in Discrete Event simulation to model the time to perform a task.  It is **right-skewed**, which basically means it has a long tail.  To put it in more understandable terms, it suggests that most activity times will be similar, but some will be longer, and some will be MUCH longer.  This tends to capture activity times in patient pathways well.\n\n![](images/lognormal.png)\n\n## A bit of background\n\n:::{.callout-tip}\nThe good news is that we will be using some prewritten code to specify our lognormal, and all we will need to know to do this is the mean (average) time for our activity, and the standard deviation (a measure of how much the times vary across the dataset that python can calculate for us if given a list of activity times).\n\nHowever - it's useful to have a bit more of an idea about what a lognormal is - so do have a read of the section below, but if you don't quite get it just yet, don't fret - just remember that lognormal is good for activity times in general, and the exponential distribution is good for inter-arrival times (the time between patients arriving).\n:::\n\n### The normal distribution\n\nA normal distribution is a bell shaped curve that is symmetrical.  It is defined by two parameters : μ (Mu) and σ (Sigma), which represent the mean and standard deviation of the distribution.  So it’s easy to plug in such values from our own data.\n\n![](images/normal_dist.png)\n\n### Logarithms\n\nBefore we proceed, let’s remind ourselves about something many of us learned at school (and then promptly forgot) : Logarithms.\n\nLogarithms are basically the opposite of exponentials.\n\nEffectively, lognormals relate to how many copies of one number multiply together to make another number.\n\nHow many 4s multiply together to make 64?\n\n```\n4 x 4 x 4 = 64\n```\n\nWe had to multiply 3 copies of the number 4 to get 64.\n\nThis means that the logarithm is 3.\n\nWe'd write this as\n$$\nY = log_4(64) = 3\n$$\n\n### Bringing it all together - lognormal distributions\n\nHow does this relate to the distribution?\n\nWell, a Lognormal distribution is one in which the **logarithm** of the random variable we’re modelling is normally distributed.\n\nThis means that the the two parameters μ (Mu) and σ (Sigma) used to specify a Lognormal distribution do not represent the mean and standard deviation, unlike the normal distribution; rather, they represent what are known as the location and scale of the distribution respectively.\n\n:::{.callout-note}\nμ (Mu) and σ (Sigma) represent the mean and standard deviation once the data in the log normal distribution has been transformed using logarithms.\n:::\n\nIt’s easy to get the mean and standard deviation of our data.\n\nIf we used the Normal distribution, we could do that.\n\n:::{.callout-warning}\nThe Normal distribution often isn’t good for activity times\n- it allows negative values\n- activity distributions are rarely symmetrical - they're more likely to be a bit 'wonky' (skewed), with just a few activities being much longer\n:::\n\nThe probalm is we can’t just give a Lognormal distribution the mean and standard deviation, because in a Lognormal distribution, the mean and standard deviation of our data is represented in the underlying normal distribution not the Lognormal distribution (remember, it’s the logarithms of the values that are normally distributed).\n\n:::{.callout-tip}\n**So what do we do?**\n\nWe need to convert our mean and standard deviation values (that we get from our real world data) into Mu and Sigma for a Lognormal distribution.\n\n**This is the key bit you need to understand!**\n:::\n\n## Code for the lognormal distribution\n\nThis code was written by [Tom Monks](https://github.com/TomMonks) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0003-2631-4481).\n\n::: {#6e4f03b7 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport math\n\nclass Lognormal:\n    \"\"\"\n    Encapsulates a lognormal distirbution\n    \"\"\"\n    def __init__(self, mean, stdev, random_seed=None):\n        \"\"\"\n        Params:\n        -------\n        mean = mean of the lognormal distribution\n        stdev = standard dev of the lognormal distribution\n        \"\"\"\n        self.rand = np.random.default_rng(seed=random_seed)\n        mu, sigma = self.normal_moments_from_lognormal(mean, stdev**2)\n        self.mu = mu\n        self.sigma = sigma\n\n    def normal_moments_from_lognormal(self, m, v):\n        '''\n        Returns mu and sigma of normal distribution\n        underlying a lognormal with mean m and variance v\n        source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal\n        -data-with-specified-mean-and-variance.html\n\n        Params:\n        -------\n        m = mean of lognormal distribution\n        v = variance of lognormal distribution\n\n        Returns:\n        -------\n        (float, float)\n        '''\n        phi = math.sqrt(v + m**2)\n        mu = math.log(m**2/phi)\n        sigma = math.sqrt(math.log(phi**2/m**2))\n        return mu, sigma\n\n    def sample(self):\n        \"\"\"\n        Sample from the normal distribution\n        \"\"\"\n        return self.rand.lognormal(self.mu, self.sigma)\n```\n:::\n\n\nWe will add this into our model code.\n\nThen we just need to make sure we have both a mean and standard deviation (SD) for activity times that we want to represent on Lognormal distributions\n\nWhen we need to sample an activity time, we create an instance of the Lognormal class with our mean and SD, and call the sample method.\n\nWe are going to do this in the attend_clinic method of the Model class.\n\n:::{.callout-tip}\nThroughout the code, anything new that's been added will be followed by the comment `##NEW` - so look out for that in the following code chunks.\n:::\n\n::: {#140a5968 .cell execution_count=2}\n``` {.python .cell-code}\ndef attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now > g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            ##NEW - we now use a lognormal distribution for the activity time,\n            # so we create an instance of our Lognormal class with the mean\n            # and standard deviations specified in g class, and then sample\n            # from it (we do this in a single line of code here, much as we\n            # did when sampling from the exponential distribution before).\n            sampled_nurse_act_time = Lognormal(\n                g.mean_n_consult_time, g.sd_n_consult_time).sample()\n\n            yield self.env.timeout(sampled_nurse_act_time)\n```\n:::\n\n\n## Additional distributions\n\nIn fact, there are many different distributions available.\n\nThe sim-tools package makes it easy to make use of them without having to write lots of classes yourself.\n\nThe source code for the package can be investigated in its [Github Repository](https://github.com/TomMonks/sim-tools).\n\nTo install the package, run\n\n::: {#e75c002f .cell execution_count=3}\n``` {.python .cell-code}\npip install sim-tools\n```\n:::\n\n\nYou can then import a class with\n\n::: {#b080886a .cell execution_count=4}\n``` {.python .cell-code}\nfrom sim_tools.distributions import Exponential\n```\n:::\n\n\nreplacing Exponential with any of the supported distribution classes.\n\nAn overview of how to use the classes, and of the different distributions included, is embedded below:\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://tommonks.github.io/sim-tools/01_sampling/01_distributions_examples.html\" title=\"Simtools Distribution Documentation\"></iframe>\n```\n\n",
    "supporting": [
      "choosing_distributions_files"
    ],
    "filters": [],
    "includes": {}
  }
}