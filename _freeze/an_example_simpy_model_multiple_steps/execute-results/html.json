{
  "hash": "f5a456bc09c4d85e093dabf72341a4dc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Adding Multiple Activities\nauthor:\n  - name: Sammi Rosser\n    orcid: 0000-0002-9552-8988\n    url: 'https://github.com/Bergam0t'\n  - name: Dan Chalk\n    orcid: 0000-0002-4165-4364\n    url: 'https://github.com/hsma-chief-elf'\nexecute:\n  eval: true\n---\n\nVery often there will be more than one activity in a model.\n\nWhat if instead of this model\n\n![](images/example_simplest_model.png)\n\nWe wanted something more like this?\n\n![](images/example_simple_model_sequential.png)\n\nIf we want patients to flow from one activity to another, we just write another one after the first one in the pathway generator function.  That (aside from adding in any extra resources and results capture elsewhere) is it.\n\n:::{.callout-warning}\nJust make sure you write the next bit outside of the with statement.  Otherwise you’ll drag across the resource from the previous activity too…\n\nOf course, in some cases, you might want that - perhaps if you’re modelling a bed as a resource, for example, but then want to model using an additional resource like a nurse for some parts of the process.\n:::\n\n## Coding the model\n\n:::{.callout-tip}\nThroughout the code, anything new that's been added will be followed by the comment `##NEW` - so look out for that in the following code chunks.\n:::\n\n### The g class\n\nFirst, lets add some additional parameters to our g class.\n\n::: {#b994b5dd .cell execution_count=1}\n``` {.python .cell-code}\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 5\n```\n:::\n\n\n### The patient class\n\nNext we'll add an additional attribute - think of it as an extra box on their clipboard that they need to fill in - to record how long they are queuing for the receptionist.\n\n::: {#023012c2 .cell execution_count=2}\n``` {.python .cell-code}\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n```\n:::\n\n\n### The model class\n\nNow we move to our **model** class. Let's start by looking at the init method - the list of things that are set up when we create an instance of our model class.\n\nFirst, we have added in a new type of resource - a receptionist, pulling in the number of receptionist to create from our g class.\n\nWe've then added two additional fields to our results dataframe - how long each patient queues for a receptionist, and how long each patient spends with the receptionist.\n\nFinally, we add in an attribute that we will use to store the mean average queuing time for receptionists across the whole model.\n\n::: {#f8b9f1bf .cell execution_count=3}\n``` {.python .cell-code}\ndef __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n```\n:::\n\n\nOur **generator_patient_arrivals** method remains unchanged as nothing has been tweaked about how patients turn up to the system.\n\nOur **attend_clinic** method is where we make the actual change to the process the patient goes through.\n\nNote that we have a new line with an indended section inside it.\n\n::: {#51f35f0b .cell execution_count=4}\n``` {.python .cell-code}\nwith self.receptionist.request() as req:\n```\n:::\n\n\nEverything at one level of indentation within this now relates to the use of the receptionist resource.\n\n::: {#23dd467a .cell execution_count=5}\n``` {.python .cell-code}\n # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n```\n:::\n\n\n### The trial class\n\nThe trial class is unchanged.\n\n## The full code\n\nThe full updated code for the model is given below.\n\n:::{.callout-note collapse=\"true\"}\n### Click here to view the full code\n\n::: {#2e7ad0d3 .cell execution_count=6}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_reception_time = 2 ##NEW\n    mean_n_consult_time = 6\n    number_of_receptionists = 1 ##NEW\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 2\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_recep = 0 ##NEW\n        self.q_time_nurse = 0\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create our resources\n        self.receptionist = simpy.Resource(\n            self.env, capacity=g.number_of_receptionists\n        ) ##NEW\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Recep\"] = [0.0] ##NEW\n        self.results_df[\"Time with Recep\"] = [0.0] ##NEW\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_recep = 0 ##NEW\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        ##NEW - added reception activity\n        start_q_recep = self.env.now\n\n        with self.receptionist.request() as req:\n            yield req\n\n            end_q_recep = self.env.now\n\n            patient.q_time_recep = end_q_recep - start_q_recep\n\n            sampled_recep_act_time = random.expovariate(\n                1.0 / g.mean_reception_time\n            )\n\n            self.results_df.at[patient.id, \"Q Time Recep\"] = (\n                 patient.q_time_recep\n            )\n            self.results_df.at[patient.id, \"Time with Recep\"] = (\n                 sampled_recep_act_time\n            )\n\n            yield self.env.timeout(sampled_recep_act_time)\n\n        # Here's where the patient finishes with the receptionist, and starts\n        # queuing for the nurse\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_recep = self.results_df[\"Q Time Recep\"].mean() ##NEW\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Recep\"] = [0.0] ##NEW\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            ##NEW (added receptionist queuing mean as first item to list)\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_recep,\n                                              my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n## Evaluating the outputs\n\nLet's run the updated code and see the outputs.\n\nWe can see we now get results for the time queueing for and the time spent with the receptionist and the nurse, displayed separately, and that these times are different from each other.\n\n::: {#08cd620c .cell execution_count=7}\n``` {.python .cell-code}\n# Create an instance of the Trial class\nmy_trial = Trial()\n\n# Call the run_trial method of our Trial object\nmy_trial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Number 0\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         0.971999      0.000000         4.290605\n2               0.000000         0.110098      0.000000         3.520545\n3               0.000000         3.295441      0.000000         5.125294\n4               3.276749         2.125569      2.999725         3.685311\n5               0.000000         2.728743      2.119007         7.894289\n6               1.895009         0.715557      9.297739         5.511429\n7               0.000000         4.500982      8.912020         1.446649\n8               0.917021         1.275261      9.083408        14.649955\n9               0.000000         0.703484     18.072800         1.895313\n10              0.000000         1.208143     16.241934         2.479590\n11              0.000000         3.421643     13.927296         2.255097\n12              0.000000         0.125478     14.787427         5.782837\n13              0.000000         0.931172     18.254003         0.597325\n14              0.000000         1.116871     17.239309         2.448820\n15              0.000000         0.697740     15.827708         1.757600\n16              0.000000         0.526777     13.493230         2.220310\n17              0.000000         0.198663      0.000000         1.885045\n18              0.000000         0.862126      0.000000         1.221127\n19              0.000000         0.833302           NaN              NaN\nRun Number 1\n            Q Time Recep  Time with Recep  Q Time Nurse  Time with Nurse\nPatient ID                                                              \n1               0.000000         1.593026      0.000000         9.345104\n2               0.000000         2.723372      0.378510         1.562441\n3               2.163104         2.903513      0.000000         6.137468\n4               0.000000         0.335004      5.031974         5.857652\n5               0.000000         0.718053      0.000000         3.313900\n6               0.047869         0.713944      2.599956         1.901189\n7               0.000000         0.006520      0.000000         4.797418\n8               0.000000         0.570416      2.663493         1.131057\n9               0.000000         1.227553      0.000000        10.190476\n10              0.000000         2.860186      3.477825         4.961014\n11              0.000000         0.729655      6.457554        10.197142\n12              0.000000         0.371229     15.694308         0.101973\n13              0.182905         0.452037     15.344244         8.932523\n14              0.000000         0.862469     22.943361        17.259605\n15              0.000000         0.306016     38.748551        16.783636\n16              0.000000         0.729838           NaN              NaN\n17              0.000000         1.984859           NaN              NaN\n18              0.610873         1.384581           NaN              NaN\n19              0.000000         1.292654           NaN              NaN\n20              0.000000         5.589228           NaN              NaN\n21              0.000000         6.054273           NaN              NaN\n22              4.946547         0.388561           NaN              NaN\n23              0.000000         0.008673           NaN              NaN\n24              0.000000         0.962845           NaN              NaN\n25              0.000000         6.698285           NaN              NaN\nTrial Results\n            Mean Q Time Recep  Mean Q Time Nurse\nRun Number                                      \n0                    0.320462           8.903089\n1                    0.318052           7.555985\n```\n:::\n:::\n\n\n",
    "supporting": [
      "an_example_simpy_model_multiple_steps_files"
    ],
    "filters": [],
    "includes": {}
  }
}