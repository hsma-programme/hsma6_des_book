{
  "hash": "ffc94f34c52d27d35cc11c99ebcae30d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Basic Debugging Tactics\nauthor:\n  - name: Amy Heather\n    orcid: 0000-0002-6596-3479\n    url: 'https://github.com/amyheather'\nformat:\n  html:\n    code-fold: false\nexecute:\n  eval: false\ncode-annotations: hover\n---\n\n:::{.callout-note title=\"Acknowledgements\"}\n\n* The `trace()` function is based on that in [HEP](https://github.com/AliHarp/HEP) by [Alison Harper](https://github.com/AliHarp) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0001-5274-5037) and [Tom Monks](https://github.com/TomMonks) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0003-2631-4481).\n* The `SimLogger` class is adapted from the [Python DES RAP Template](https://github.com/pythonhealthdatascience/rap_template_python_des) by [Amy Heather](https://github.com/amyheather) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0002-6596-3479) and [Tom Monks](https://github.com/TomMonks) [![ORCID ID](images/orcid.png)](https://orcid.org/0000-0003-2631-4481).\n:::\n\nWhen working with your model, it can be hard to know whether it is working correctly. There are a range of different approaches we can take. These include:\n\n1. Using simple `print()` statements.\n2. Using a function (e.g. `trace()`) to control the `print()` statements.\n3. Using the `logging` module.\n4. Tests.\n5. Event logging.\n\n## The model\n\nWhere code examples are provided, this chapter uses the model from the chapter \"[An Example SimPy Model](an_example_simpy_model.qmd)\".\n\n:::{.callout-tip}\nThroughout the code, anything new that's been added will be followed by the comment `##NEW` - so look out for that in the following code chunks.\n:::\n\nIn each of these examples, we will just run the model once.\n\n::: {#457652e2 .cell execution_count=1}\n``` {.python .cell-code}\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run # <1>\n```\n:::\n\n\n1. Just run the model once.\n\n## Using simple `print()` statements\n\nTo get a running record of what is happening in your model, you can add `print()` statements at key points.\n\nFor example, we can add:\n\n* A print statement recording when each patient arrives.\n* A print statement recording when each patient is seen by the nurse (including how long they waited, and how long their consultation then was).\n\n:::{.callout-tip}\nFor another example using `print()` statements, see the \"[Reneging, Balking and Jockeying](reneging_balking_jockeying.qmd)\" chapter where they are used, for example, to record:\n\n::: {#7c1539af .cell execution_count=2}\n``` {.python .cell-code}\nprint (f\"Patient {patient.id} reneged after waiting\",\n       f\"{patient.patience_nurse} minutes\")\n```\n:::\n\n\n:::\n\n### Coding the model\n\nWe will modify the `Model` class to add print statements within the `generator_patient_arrivals()` and `attend_clinic()` functions.\n\n::: {#b33f2d72 .cell execution_count=3}\n``` {.python .cell-code}\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n        ##NEW - Print message stating patient ID and arrival time # <1>\n        print(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Print message with patient wait and consultation length # <1>\n        print(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n```\n:::\n\n\n1. Add print messages with the patient arrival time, wait time, and time with the nurse.\n\n### The full code\n\nThe full updated code for the model is given below.\n\n:::{.callout-note collapse=\"true\"}\n\n## Click here to view the full code\n\n::: {#b10b1460 .cell execution_count=4}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Print message stating patient ID and arrival time\n            print(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Print message with patient wait and consultation length\n            print(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\nRunning the model, we'll see the following output...\n\n::: {#4297a046 .cell execution_count=5}\n``` {.python .cell-code}\ntrial = Trial()\ntrial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 10.724.\nPatient 2 arrives at: 0.150.\nPatient 3 arrives at: 5.309.\nPatient 4 arrives at: 6.371.\nPatient 5 arrives at: 7.962.\nPatient 2 waits for 10.574 and is seen at 10.724016899760096. Consultation length: 0.200.\nPatient 3 waits for 5.615 and is seen at 10.923618999278593. Consultation length: 0.086.\nPatient 4 waits for 4.639 and is seen at 11.010046767046207. Consultation length: 8.038.\nPatient 5 waits for 11.086 and is seen at 19.04810698254277. Consultation length: 2.322.\nPatient 6 arrives at: 23.236.\nPatient 6 waits for 0.000 and is seen at 23.23637375971412. Consultation length: 2.582.\nPatient 7 arrives at: 24.742.\nPatient 7 waits for 1.076 and is seen at 25.818359178321167. Consultation length: 4.804.\nPatient 8 arrives at: 28.219.\nPatient 8 waits for 2.404 and is seen at 30.622399428034093. Consultation length: 0.806.\nPatient 9 arrives at: 31.606.\nPatient 9 waits for 0.000 and is seen at 31.6058048759237. Consultation length: 5.891.\nPatient 10 arrives at: 37.518.\nPatient 10 waits for 0.000 and is seen at 37.518138074459074. Consultation length: 4.926.\nPatient 11 arrives at: 43.757.\nPatient 11 waits for 0.000 and is seen at 43.75672280585052. Consultation length: 3.754.\nPatient 12 arrives at: 47.837.\nPatient 12 waits for 0.000 and is seen at 47.83716109080116. Consultation length: 7.447.\nPatient 13 arrives at: 51.575.\nPatient 13 waits for 3.709 and is seen at 55.283961262528265. Consultation length: 1.232.\nPatient 14 arrives at: 56.303.\nPatient 14 waits for 0.212 and is seen at 56.51591826312143. Consultation length: 10.233.\nPatient 15 arrives at: 57.747.\nPatient 16 arrives at: 60.308.\nPatient 17 arrives at: 61.744.\nPatient 15 waits for 9.002 and is seen at 66.74892482841393. Consultation length: 2.210.\nPatient 18 arrives at: 67.211.\nPatient 19 arrives at: 67.843.\nPatient 16 waits for 8.651 and is seen at 68.95866493071166. Consultation length: 0.340.\nPatient 17 waits for 7.555 and is seen at 69.2986542797349. Consultation length: 5.792.\nPatient 20 arrives at: 72.047.\nPatient 21 arrives at: 74.530.\nPatient 18 waits for 7.880 and is seen at 75.09038363936328. Consultation length: 11.580.\nPatient 22 arrives at: 76.224.\nPatient 23 arrives at: 76.378.\nPatient 24 arrives at: 78.546.\nPatient 25 arrives at: 84.580.\nPatient 19 waits for 18.827 and is seen at 86.66992435703258. Consultation length: 0.061.\nPatient 20 waits for 14.684 and is seen at 86.73073461746797. Consultation length: 3.013.\nPatient 21 waits for 15.213 and is seen at 89.74391099742128. Consultation length: 0.320.\nPatient 22 waits for 13.840 and is seen at 90.06408226252125. Consultation length: 3.324.\nPatient 23 waits for 17.010 and is seen at 93.38789010749436. Consultation length: 0.945.\nPatient 24 waits for 15.787 and is seen at 94.33269125218459. Consultation length: 7.140.\nPatient 25 waits for 16.893 and is seen at 101.47273147144615. Consultation length: 1.942.\nPatient 26 arrives at: 101.587.\nPatient 27 arrives at: 102.331.\nPatient 26 waits for 1.828 and is seen at 103.4147428371654. Consultation length: 2.334.\nPatient 28 arrives at: 104.156.\nPatient 27 waits for 3.418 and is seen at 105.74893838517372. Consultation length: 6.063.\nPatient 29 arrives at: 106.335.\nPatient 30 arrives at: 108.924.\nPatient 31 arrives at: 109.592.\nPatient 32 arrives at: 110.299.\nPatient 33 arrives at: 110.538.\nPatient 28 waits for 7.656 and is seen at 111.81212331183262. Consultation length: 0.322.\nPatient 29 waits for 5.799 and is seen at 112.13404701043532. Consultation length: 6.933.\nPatient 34 arrives at: 117.495.\nPatient 30 waits for 10.143 and is seen at 119.06730549093024. Consultation length: 0.289.\nPatient 31 waits for 9.764 and is seen at 119.35603766629579. Consultation length: 2.345.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000        10.724017\n2              10.574291         0.199602\n3               5.614699         0.086428\n4               4.638661         8.038060\n5              11.086170         2.321768\n6               0.000000         2.581985\n7               1.076460         4.804040\n8               2.403821         0.806189\n9               0.000000         5.891071\n10              0.000000         4.926228\n11              0.000000         3.754320\n12              0.000000         7.446800\n13              3.709055         1.231957\n14              0.212443        10.233007\n15              9.001625         2.209740\n16              8.651064         0.339989\n17              7.554838         5.791729\n18              7.879701        11.579541\n19             18.826528         0.060810\n20             14.684001         3.013176\n21             15.213417         0.320171\n22             13.839593         3.323808\n23             17.009595         0.944801\n24             15.786730         7.140040\n25             16.892926         1.942011\n26              1.827984         2.334196\n27              3.417988         6.063185\n28              7.656284         0.321924\n29              5.799302         6.933258\n30             10.142826         0.288732\n31              9.764481         2.344893\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                     7.20208\n```\n:::\n:::\n\n\n## Using `trace()` to control the `print()` statements\n\nThis output is helpful when debugging a single run of the model, but the behaviour is undesirable when running multiple replications.\n\nWe can write a function which will toggle whether to run the `print()` statements or not.\n\n### Coding the model\n\nIn our parameter class, we add a parameter `trace` which will control whether the `print()` statements are executed or not.\n\n::: {#72b55fd2 .cell execution_count=6}\n``` {.python .cell-code}\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run # <1>\n    trace = True  ##NEW - controls whether the print statements are executed # <2>\n```\n:::\n\n\n1. Just run the model once.\n2. Add `trace` parameter which will determine whether the print statements are executed.\n\nWe then define a new function `trace()` which will only run if `g.trace` is true.\n\n::: {#3c350fd6 .cell execution_count=7}\n``` {.python .cell-code}\n##NEW # <1>\ndef trace(msg):\n    \"\"\" \n    If TRUE will return all patient-level message outputs.\n\n    Arguments:\n      msg (string):\n        Message output.\n    \"\"\"\n    if g.trace:\n        print(msg)\n```\n:::\n\n\n1. Define a new function `trace()` which will print messages if `g.trace` is true.\n\nThen, in our model, we alter our `print()` statements so that the message is input to the `trace()` function.\n\n::: {#1bcaf4ed .cell execution_count=8}\n``` {.python .cell-code}\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n        ##NEW - Print message stating patient ID and arrival time # <1>\n        trace(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Print message with patient wait and consultation length # <1>\n        trace(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n```\n:::\n\n\n1. Change our `print()` statements to `trace()`.\n\n### The full code\n\nThe full updated code for the model is given below.\n\n:::{.callout-note collapse=\"true\"}\n\n## Click here to view the full code\n\n::: {#1df97c08 .cell execution_count=9}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n    trace = True  ##NEW - controls whether the print statements are executed\n\n\n##NEW\ndef trace(msg):\n    \"\"\" \n    If TRUE will return all patient-level message outputs.\n\n    Arguments:\n      msg (string):\n        Message output.\n    \"\"\"\n    if g.trace:\n        print(msg)\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Print message stating patient ID and arrival time\n            trace(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Print message with patient wait and consultation length\n            trace(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\nIf we set `g.trace = False`, we will see none of the patient messages are printed (and only our results from `print_trial_results()` are).\n\n::: {#59f0709e .cell execution_count=10}\n``` {.python .cell-code}\ng.trace = False\ntrial = Trial()\ntrial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.515033\n2               0.000000        16.105676\n3              13.725436         6.471818\n4              16.432416         1.761055\n5              15.016513         8.896223\n6               3.109157         0.881718\n7               0.000000         8.643518\n8               8.225063         9.053969\n9              12.012615         6.340599\n10             14.435000         2.933931\n11             17.155207         0.689076\n12             13.000332         0.799066\n13              8.791537         0.923040\n14              0.000000         4.718291\n15              4.311246         9.033027\n16              9.024959         1.792199\n17              8.051979         2.034575\n18              0.000000         4.907508\n19              0.501197         2.779236\n20              0.000000         4.841451\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                    7.189633\n```\n:::\n:::\n\n\nMeanwhile, if `g.trace = True`...\n\n::: {#dc45b90e .cell execution_count=11}\n``` {.python .cell-code}\ng.trace = True\ntrial = Trial()\ntrial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 0.949.\nPatient 2 arrives at: 2.523.\nPatient 2 waits for 0.000 and is seen at 2.5228663887406113. Consultation length: 0.583.\nPatient 3 arrives at: 4.029.\nPatient 3 waits for 0.000 and is seen at 4.028668137656526. Consultation length: 3.192.\nPatient 4 arrives at: 9.921.\nPatient 4 waits for 0.000 and is seen at 9.921203417940536. Consultation length: 0.018.\nPatient 5 arrives at: 12.577.\nPatient 5 waits for 0.000 and is seen at 12.577134658714382. Consultation length: 2.112.\nPatient 6 arrives at: 13.534.\nPatient 7 arrives at: 14.184.\nPatient 6 waits for 1.156 and is seen at 14.689547869979073. Consultation length: 3.523.\nPatient 7 waits for 4.029 and is seen at 18.212652512617925. Consultation length: 4.645.\nPatient 8 arrives at: 18.886.\nPatient 8 waits for 3.972 and is seen at 22.8581446432479. Consultation length: 7.315.\nPatient 9 arrives at: 32.497.\nPatient 9 waits for 0.000 and is seen at 32.49747626810915. Consultation length: 1.357.\nPatient 10 arrives at: 34.010.\nPatient 10 waits for 0.000 and is seen at 34.0102442456301. Consultation length: 2.387.\nPatient 11 arrives at: 37.645.\nPatient 11 waits for 0.000 and is seen at 37.64471969428669. Consultation length: 0.221.\nPatient 12 arrives at: 41.007.\nPatient 12 waits for 0.000 and is seen at 41.00722601865192. Consultation length: 16.012.\nPatient 13 arrives at: 41.038.\nPatient 13 waits for 15.981 and is seen at 57.01906588571015. Consultation length: 29.464.\nPatient 14 arrives at: 68.510.\nPatient 15 arrives at: 74.225.\nPatient 14 waits for 17.974 and is seen at 86.48342300181554. Consultation length: 5.123.\nPatient 16 arrives at: 87.589.\nPatient 15 waits for 17.382 and is seen at 91.6067331429726. Consultation length: 0.934.\nPatient 16 waits for 4.951 and is seen at 92.54060165275669. Consultation length: 7.241.\nPatient 17 arrives at: 92.939.\nPatient 18 arrives at: 94.248.\nPatient 17 waits for 6.842 and is seen at 99.78143093758239. Consultation length: 6.249.\nPatient 19 arrives at: 100.160.\nPatient 18 waits for 11.782 and is seen at 106.03032597390029. Consultation length: 5.033.\nPatient 20 arrives at: 110.124.\nPatient 19 waits for 10.904 and is seen at 111.06378953900895. Consultation length: 6.669.\nPatient 21 arrives at: 114.464.\nPatient 20 waits for 7.609 and is seen at 117.73288671184125. Consultation length: 2.026.\nPatient 21 waits for 5.295 and is seen at 119.75916138885063. Consultation length: 8.047.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000         0.949483\n2               0.000000         0.583333\n3               0.000000         3.191868\n4               0.000000         0.018307\n5               0.000000         2.112413\n6               1.155695         3.523105\n7               4.028798         4.645492\n8               3.971928         7.315200\n9               0.000000         1.356641\n10              0.000000         2.387203\n11              0.000000         0.221378\n12              0.000000        16.011840\n13             15.981472        29.464357\n14             17.973793         5.123310\n15             17.381797         0.933869\n16              4.951300         7.240829\n17              6.842006         6.248895\n18             11.782468         5.033464\n19             10.903800         6.669097\n20              7.608666         2.026275\n21              5.295051         8.047447\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                    5.136989\n```\n:::\n:::\n\n\n## Using the logging module\n\nThe logging module is a step up from the use of `print()` statements.\n\nIt enables us to choose between printing the messages or saving them to a `.log` file.\n\nIt can also be extended with different types of log message (e.g. `INFO`, `WARNING`, `ERROR`), customised with different colours, and more. Here, we just demonstrate a simple implementation.\n\n### Coding the model\n\n#### Imports\n\nFirst, we need to update our imports.\n\n::: {#d49c71de .cell execution_count=12}\n``` {.python .cell-code}\nimport logging  ##NEW # <1>\nimport sys  ##NEW # <2>\nimport time  ##NEW # <3>\n\nimport simpy\nimport random\nimport pandas as pd\n```\n:::\n\n\n1. Add `logging` which we will use to create logs.\n2. Add `sys` which is required when setting up the handler for logging to the console.\n3. Add `time` which we will use is it is desired to save logs to a file with the current date and time.\n\n#### SimLogger class\n\nNext, we will create a new class called `SimLogger`. This accepts three inputs when setting up:\n\n* `log_to_console` - which determines whether to print log messages.\n* `log_to_file` - which determines whether to save the log to a file.\n* `file_path` - if saving to file, the path to use.\n\nThe class configures handlers for logging (`_configure_logging()`), and then has a `log()` method which will be used to save messages to the log in our model.\n\n::: {#38c70da5 .cell execution_count=13}\n``` {.python .cell-code}\n##NEW\nclass SimLogger:\n    \"\"\"\n    Provides log of events as the simulation runs.\n    \"\"\"\n    def __init__(self, log_to_console=False, log_to_file=False,\n                file_path=(\"../outputs/logs/\" +\n                            f\"{time.strftime('%Y-%m-%d_%H-%M-%S')}.log\")\n      ): # <1>\n        \"\"\"\n        Initialise the Logger class.\n\n        Arguments:\n            log_to_console (boolean):\n                Whether to print log messages to the console.\n            log_to_file (boolean):\n                Whether to save log to a file.\n            file_path (str):\n                Path to save log to file. Note, if you use an existing .log\n                file name, it will append to that log. Defaults to filename\n                based on current date and time, and folder '../outputs/log/'.\n        \"\"\"\n        self.log_to_console = log_to_console\n        self.log_to_file = log_to_file\n        self.file_path = file_path\n        self.logger = None\n\n        # If logging enabled (either printing to console, file or both), then\n        # create logger and configure settings\n        if self.log_to_console or self.log_to_file:\n            self.logger = logging.getLogger(__name__)\n            self._configure_logging()\n\n    def _configure_logging(self): # <2>\n        \"\"\"\n        Configure the logger.\n        \"\"\"\n        # Ensure any existing handlers are removed to avoid duplication\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        # Add handlers for saving messages to file and/or printing to console\n        handlers = []\n        if self.log_to_file:\n            # In write mode, meaning will overwrite existing log of same name\n            # (append mode 'a' would add to the end of the log)\n            handlers.append(logging.FileHandler(self.file_path, mode='w'))\n        if self.log_to_console:\n            handlers.append(logging.StreamHandler(sys.stdout))\n\n        # Add handlers directly to the logger\n        for handler in handlers:\n            self.logger.addHandler(handler)\n\n        # Set logging level and format. If don't set level info, it would\n        # only show log messages which are warning, error or critical.\n        self.logger.setLevel(logging.INFO)\n        formatter = logging.Formatter(\"%(message)s\")\n        for handler in handlers:\n            handler.setFormatter(formatter)\n\n    def log(self, msg): # <3>\n        \"\"\"\n        Log a message if logging is enabled.\n\n        Arguments:\n            msg (str):\n                Message to log.\n        \"\"\"\n        if self.log_to_console or self.log_to_file:\n            self.logger.info(msg)\n```\n:::\n\n\n1. Set up for the `SimLogger` class which accepts three inputs, and will call the `_configure_logging()` method\n2. This method configures the loggers, setting up appropriate handlers depending on whether we are printing logs to the console, saving them to the file, or both.\n3. This is the equivalent to `print()` or `trace()` above.\n\n#### g class\n\nIn our `g` class, we will add an instance of the logging class.\n\n::: {#646756fe .cell execution_count=14}\n``` {.python .cell-code}\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run # <1>\n    ##NEW - instance of the SimLogger class # <2>\n    logger = SimLogger(log_to_console = True,\n                       log_to_file = True,\n                       file_path = \"./outputs/example_log.log\")\n```\n:::\n\n\n1. Just run the model once.\n2. Set up `SimLogger` instance.\n\n#### Model class\n\nFor our messages in `Model`, we now change `print()` or `trace()` instead to `g.logger.log()`.\n\n::: {#5af39cbc .cell execution_count=15}\n``` {.python .cell-code}\ndef generator_patient_arrivals(self):\n    while True:\n        self.patient_counter += 1\n        p = Patient(self.patient_counter)\n\n        ##NEW - Log message stating patient ID and arrival time # <1>\n        g.logger.log(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n        self.env.process(self.attend_clinic(p))\n        sampled_inter = random.expovariate(1.0 / g.patient_inter)\n        yield self.env.timeout(sampled_inter)\n\ndef attend_clinic(self, patient):\n    start_q_nurse = self.env.now\n    with self.nurse.request() as req:\n        yield req\n        end_q_nurse = self.env.now\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n        sampled_nurse_act_time = random.expovariate(1.0 /\n                                                    g.mean_n_consult_time)\n\n        ##NEW - Log message with patient wait and consultation length # <1>\n        g.logger.log(\n          f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n          f\"and is seen at {end_q_nurse}. Consultation length: \" +\n          f\"{sampled_nurse_act_time:.3f}.\")\n\n        self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n            patient.q_time_nurse)\n        self.results_df.at[patient.id, \"Time with Nurse\"] = (\n            sampled_nurse_act_time)\n        yield self.env.timeout(sampled_nurse_act_time)\n```\n:::\n\n\n1. Change `print()`/`trace()` to `log()`.\n\n### The full code\n\nThe full updated code for the model is given below.\n\n:::{.callout-note collapse=\"true\"}\n\n## Click here to view the full code\n\n::: {#467c5659 .cell execution_count=16}\n``` {.python .cell-code}\nimport logging  ##NEW\nimport sys  ##NEW\nimport time  ##NEW\n\nimport simpy\nimport random\nimport pandas as pd\n\n\n##NEW\nclass SimLogger:\n    \"\"\"\n    Provides log of events as the simulation runs.\n    \"\"\"\n    def __init__(self, log_to_console=False, log_to_file=False,\n                file_path=(\"../outputs/logs/\" +\n                            f\"{time.strftime('%Y-%m-%d_%H-%M-%S')}.log\")\n      ):\n        \"\"\"\n        Initialise the Logger class.\n\n        Arguments:\n            log_to_console (boolean):\n                Whether to print log messages to the console.\n            log_to_file (boolean):\n                Whether to save log to a file.\n            file_path (str):\n                Path to save log to file. Note, if you use an existing .log\n                file name, it will append to that log. Defaults to filename\n                based on current date and time, and folder '../outputs/log/'.\n        \"\"\"\n        self.log_to_console = log_to_console\n        self.log_to_file = log_to_file\n        self.file_path = file_path\n        self.logger = None\n\n        # If logging enabled (either printing to console, file or both), then\n        # create logger and configure settings\n        if self.log_to_console or self.log_to_file:\n            self.logger = logging.getLogger(__name__)\n            self._configure_logging()\n\n    def _configure_logging(self):\n        \"\"\"\n        Configure the logger.\n        \"\"\"\n        # Ensure any existing handlers are removed to avoid duplication\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        # Add handlers for saving messages to file and/or printing to console\n        handlers = []\n        if self.log_to_file:\n            # In write mode, meaning will overwrite existing log of same name\n            # (append mode 'a' would add to the end of the log)\n            handlers.append(logging.FileHandler(self.file_path, mode='w'))\n        if self.log_to_console:\n            handlers.append(logging.StreamHandler(sys.stdout))\n\n        # Add handlers directly to the logger\n        for handler in handlers:\n            self.logger.addHandler(handler)\n\n        # Set logging level and format. If don't set level info, it would\n        # only show log messages which are warning, error or critical.\n        self.logger.setLevel(logging.INFO)\n        formatter = logging.Formatter(\"%(message)s\")\n        for handler in handlers:\n            handler.setFormatter(formatter)\n\n    def log(self, msg):\n        \"\"\"\n        Log a message if logging is enabled.\n\n        Arguments:\n            msg (str):\n                Message to log.\n        \"\"\"\n        if self.log_to_console or self.log_to_file:\n            self.logger.info(msg)\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    patient_inter = 5\n    mean_n_consult_time = 6\n    number_of_nurses = 1\n    sim_duration = 120\n    number_of_runs = 1  ##NEW - single run\n    ##NEW - instance of the SimLogger class\n    logger = SimLogger(log_to_console = True,\n                       log_to_file = True,\n                       file_path = \"./outputs/example_log.log\")\n\n\n# Class representing patients coming in to the clinic.  Here, patients have\n# two attributes that they carry with them - their ID, and the amount of time\n# they spent queuing for the nurse.  The ID is passed in when a new patient is\n# created.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create a SimPy resource to represent a nurse, that will live in the\n        # environment created above.  The number of this resource we have is\n        # specified by the capacity, and we grab this value from our g class.\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing time for the nurse\n        # across this run of the model\n        self.mean_q_time_nurse = 0\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            ##NEW - Log message stating patient ID and arrival time\n            g.logger.log(f\"Patient {p.id} arrives at: {self.env.now:.3f}.\")\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.  Here the pathway is extremely simple - a patient\n    # arrives, waits to see a nurse, and then leaves.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            # When we get to this bit of code, control has been passed back to\n            # the generator function, and therefore the request for a nurse has\n            # been met.  We now have the nurse, and have stopped queuing, so we\n            # can record the current time as the time we finished queuing.\n            end_q_nurse = self.env.now\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute for this.\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # Now we'll randomly sample the time this patient with the nurse.\n            # Here, we use an Exponential distribution for simplicity, but you\n            # would typically use a Log Normal distribution for a real model\n            # (we'll come back to that).  As with sampling the inter-arrival\n            # times, we grab the mean from the g class, and pass in 1 / mean\n            # as the lambda value.\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            ##NEW - Log message with patient wait and consultation length\n            g.logger.log(\n              f\"Patient {patient.id} waits for {patient.q_time_nurse:.3f} \" +\n              f\"and is seen at {end_q_nurse}. Consultation length: \" +\n              f\"{sampled_nurse_act_time:.3f}.\")\n\n            # Here we'll store the queuing time for the nurse and the sampled\n            # time to spend with the nurse in the results DataFrame against the\n            # ID for this patient.  In real world models, you may not want to\n            # bother storing the sampled activity times - but as this is a\n            # simple model, we'll do it here.\n            # We use a handy property of pandas called .at, which works a bit\n            # like .loc.  .at allows us to access (and therefore change) a\n            # particular cell in our DataFrame by providing the row and column.\n            # Here, we specify the row as the patient ID (the index), and the\n            # column for the value we want to update for that patient.\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                patient.q_time_nurse)\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # When the time above elapses, the generator function will return\n            # here.  As there's nothing more that we've written, the function\n            # will simply end.  This is a sink.  We could choose to add\n            # something here if we wanted to record something - e.g. a counter\n            # for number of patients that left, recording something about the\n            # patients that left at a particular sink etc.\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times for the nurse across patients in\n        # this run of the model.\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model\n        print (f\"Run Number {self.run_number}\")\n        print (self.results_df)\n\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run (just the mean queuing time for the nurse here)\n    # against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to print out the results from the trial.  In real world models,\n    # you'd likely save them as well as (or instead of) printing them\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n        # Once the trial (ie all runs) has completed, print the final results\n        self.print_trial_results()\n```\n:::\n\n\n:::\n\n### Exploring the outputs\n\nWe will run the model with `log_to_console` and `log_to_file` both enabled.\n\nYou'll see that the logs are printed as before...\n\n::: {#93967432 .cell execution_count=17}\n``` {.python .cell-code}\ntrial = Trial()\ntrial.run_trial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 20.445.\nPatient 2 arrives at: 3.228.\nPatient 3 arrives at: 4.778.\nPatient 4 arrives at: 11.542.\nPatient 5 arrives at: 17.416.\nPatient 6 arrives at: 18.391.\nPatient 2 waits for 17.217 and is seen at 20.444720365535566. Consultation length: 1.084.\nPatient 3 waits for 16.751 and is seen at 21.528518818320162. Consultation length: 14.875.\nPatient 7 arrives at: 27.049.\nPatient 8 arrives at: 28.655.\nPatient 4 waits for 24.862 and is seen at 36.40390758388942. Consultation length: 4.679.\nPatient 5 waits for 23.667 and is seen at 41.082495475966006. Consultation length: 2.006.\nPatient 6 waits for 24.698 and is seen at 43.08886529597139. Consultation length: 7.335.\nPatient 7 waits for 23.376 and is seen at 50.42416096680088. Consultation length: 5.859.\nPatient 9 arrives at: 53.623.\nPatient 10 arrives at: 55.255.\nPatient 8 waits for 27.629 and is seen at 56.283553427328705. Consultation length: 12.748.\nPatient 11 arrives at: 60.851.\nPatient 12 arrives at: 63.044.\nPatient 13 arrives at: 65.438.\nPatient 14 arrives at: 67.370.\nPatient 9 waits for 15.409 and is seen at 69.03203453539484. Consultation length: 2.009.\nPatient 10 waits for 15.786 and is seen at 71.04113540869592. Consultation length: 4.370.\nPatient 15 arrives at: 72.523.\nPatient 16 arrives at: 73.250.\nPatient 11 waits for 14.560 and is seen at 75.41091250233481. Consultation length: 3.733.\nPatient 12 waits for 16.100 and is seen at 79.14375033636888. Consultation length: 3.217.\nPatient 17 arrives at: 79.729.\nPatient 18 arrives at: 82.031.\nPatient 19 arrives at: 82.323.\nPatient 13 waits for 16.923 and is seen at 82.36092079540045. Consultation length: 11.472.\nPatient 20 arrives at: 90.199.\nPatient 14 waits for 26.463 and is seen at 93.83269016595533. Consultation length: 1.226.\nPatient 15 waits for 22.536 and is seen at 95.05869993983505. Consultation length: 9.555.\nPatient 21 arrives at: 98.437.\nPatient 22 arrives at: 99.959.\nPatient 23 arrives at: 102.641.\nPatient 16 waits for 31.363 and is seen at 104.61344903851816. Consultation length: 1.378.\nPatient 17 waits for 26.263 and is seen at 105.99147015629434. Consultation length: 16.713.\nPatient 24 arrives at: 113.694.\nPatient 25 arrives at: 118.770.\nRun Number 0\n            Q Time Nurse  Time with Nurse\nPatient ID                               \n1               0.000000        20.444720\n2              17.217182         1.083798\n3              16.750729        14.875389\n4              24.862249         4.678588\n5              23.666877         2.006370\n6              24.698140         7.335296\n7              23.375503         5.859392\n8              27.629033        12.748481\n9              15.409151         2.009101\n10             15.785961         4.369777\n11             14.560386         3.732838\n12             16.099564         3.217170\n13             16.922809        11.471769\n14             26.462548         1.226010\n15             22.535522         9.554749\n16             31.363139         1.378021\n17             26.262731        16.713489\nTrial Results\n            Mean Q Time Nurse\nRun Number                   \n0                   20.211854\n```\n:::\n:::\n\n\n...but also, a `.log` file has been generated containing the logs:\n\n::: {#c26118ee .cell execution_count=18}\n``` {.python .cell-code}\nwith open(\"outputs/example_log.log\") as f:\n    print(f.read())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPatient 1 arrives at: 0.000.\nPatient 1 waits for 0.000 and is seen at 0. Consultation length: 20.445.\nPatient 2 arrives at: 3.228.\nPatient 3 arrives at: 4.778.\nPatient 4 arrives at: 11.542.\nPatient 5 arrives at: 17.416.\nPatient 6 arrives at: 18.391.\nPatient 2 waits for 17.217 and is seen at 20.444720365535566. Consultation length: 1.084.\nPatient 3 waits for 16.751 and is seen at 21.528518818320162. Consultation length: 14.875.\nPatient 7 arrives at: 27.049.\nPatient 8 arrives at: 28.655.\nPatient 4 waits for 24.862 and is seen at 36.40390758388942. Consultation length: 4.679.\nPatient 5 waits for 23.667 and is seen at 41.082495475966006. Consultation length: 2.006.\nPatient 6 waits for 24.698 and is seen at 43.08886529597139. Consultation length: 7.335.\nPatient 7 waits for 23.376 and is seen at 50.42416096680088. Consultation length: 5.859.\nPatient 9 arrives at: 53.623.\nPatient 10 arrives at: 55.255.\nPatient 8 waits for 27.629 and is seen at 56.283553427328705. Consultation length: 12.748.\nPatient 11 arrives at: 60.851.\nPatient 12 arrives at: 63.044.\nPatient 13 arrives at: 65.438.\nPatient 14 arrives at: 67.370.\nPatient 9 waits for 15.409 and is seen at 69.03203453539484. Consultation length: 2.009.\nPatient 10 waits for 15.786 and is seen at 71.04113540869592. Consultation length: 4.370.\nPatient 15 arrives at: 72.523.\nPatient 16 arrives at: 73.250.\nPatient 11 waits for 14.560 and is seen at 75.41091250233481. Consultation length: 3.733.\nPatient 12 waits for 16.100 and is seen at 79.14375033636888. Consultation length: 3.217.\nPatient 17 arrives at: 79.729.\nPatient 18 arrives at: 82.031.\nPatient 19 arrives at: 82.323.\nPatient 13 waits for 16.923 and is seen at 82.36092079540045. Consultation length: 11.472.\nPatient 20 arrives at: 90.199.\nPatient 14 waits for 26.463 and is seen at 93.83269016595533. Consultation length: 1.226.\nPatient 15 waits for 22.536 and is seen at 95.05869993983505. Consultation length: 9.555.\nPatient 21 arrives at: 98.437.\nPatient 22 arrives at: 99.959.\nPatient 23 arrives at: 102.641.\nPatient 16 waits for 31.363 and is seen at 104.61344903851816. Consultation length: 1.378.\nPatient 17 waits for 26.263 and is seen at 105.99147015629434. Consultation length: 16.713.\nPatient 24 arrives at: 113.694.\nPatient 25 arrives at: 118.770.\n\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\nFor a more detailed logging implementation, see the [Python DES RAP Template](https://github.com/pythonhealthdatascience/rap_template_python_des) - the file [notebooks/logs.ipynb](https://github.com/pythonhealthdatascience/rap_template_python_des/blob/main/notebooks/logs.ipynb) is a good place to start.\n\nThat implementation includes:\n\n* Log of the model state at initialisation and parameters used.\n* A `sanitise_object` function which removes object references when logging things like a `simpy.Resource`.\n* Simulation time at the start of every log message.\n* Different emojis for different patient types and activities (including distinguishing warm-up and non-warm-up patients).\n* A nicely formatted output including colours thanks to the `rich` module.\n\n:::\n\n## Tests\n\nTesting is the process of evaluating a model to ensure it works as expected, gives reliable results, and can handle different conditions.\n\nBy checking for errors and unexpected results, it helps improve the quality of the model, catch errors and prevent future issues.\n\nTesting is explored in more detail in its own chapter: @sec-tests.\n\n## Event logging\n\nBuilding up our own event logs give us a very clear picture of what is happening to every entity throughout our model.\n\nThey are a valuable debugging technique, and by structuring them correctly, we can start to build up a bank of code that can be used to debug very different models with no or minimal changes to our code that processes the event logs. They can also then be used for building animated visuals of the flow of entities through our model.\n\nAs this is a more involved approach, it has been placed in its own chapter [here](event_logging.qmd).\n\n",
    "supporting": [
      "basic_debugging_tactics_files"
    ],
    "filters": [],
    "includes": {}
  }
}