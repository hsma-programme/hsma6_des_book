{
  "hash": "e2606336abe43da1da360e0a59698538",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Modelling Resource Unavailability\nauthor:\n  - name: Sammi Rosser\n    orcid: 0000-0002-9552-8988\n    url: 'https://github.com/Bergam0t'\n  - name: Dan Chalk\n    orcid: 0000-0002-4165-4364\n    url: 'https://github.com/hsma-chief-elf'\nexecute:\n  eval: false\n---\n\nSo far in our models, we’ve assumed that, outside of working on our modelled activities, our modelled resources are always available for the time we’re simulating.  But that won’t always be the case in the real world.\n\nResources may not always be “on shift”, or may be called off to other areas of the system (e.g. different parts of a hospital).  How we deal with this depends on the answer to the following question :\n\nWhen this happens, does another resource of the same type cover?\n\nIf yes, then it doesn’t matter to the model and we don't need to change the model to reflect it.  For example, in a ward there might always be 5 doctors available, even if who those doctors are changes.\n\nIf no, and the level of resource availability changes, then we can model this in SimPy by “obstructing” a resource for a certain amount of time.\n\nLet’s consider our nurse consultation model as an example.  Let’s imagine that every 2 hours, our nurse has a 15 minute break.\n\nLet’s look at how we’d model that.\n\n![](images/modelling_unavailability.png)\n\n## The approach\n\nBasically, we will:\n\n- Set up the frequency and duration of unavailability as parameter values in g class.\n- Make sure that the nurse is set up as a PriorityResource.\n- Create a new entity generator whose sole purpose is to demand the nurse resource with a higher priority than any patient every 2 hours, and will freeze the nurse with them for 15 minutes (this means the nurse will complete the current patient, they won’t walk out midway through!).\n- Start this new generator running in our run method of the Model class.\n\n## Coding the model\n\n:::{.callout-tip}\nThroughout the code, anything new that's been added will be followed by the comment `##NEW` - so look out for that in the following code chunks.\n:::\n\n### g class\n\nIn the g class, we have added values to specify how long nurse is unavailable and at what frequency.\n\nIn this example, every 2 hours, the nurse will be unavailable for 15 minutes.\n\n::: {#014bb679 .cell execution_count=1}\n``` {.python .cell-code}\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    unav_time_nurse = 15 ##NEW\n    unav_freq_nurse = 120 ##NEW\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n```\n:::\n\n\n### Patient class\n\nThe patient class is unchanged.\n\n### Model class\n\n#### The obstruct_nurse method\nWe create a new method within the model class called `obstruct_nurse`.\n\n::: {.callout-tip}\nNote that here we are using a priority value of -1.\n\nNegative priorities are higher (i.e. are seen first) compared to higher priorities; a priority value of -1 will be seen before a priority value of 1, but a priority value of 1 will be seen before a priority value of 2.\n\nThis is a very helpful feature to use to keep your breaktime functions from clashing with high-priority patients.\n:::\n\n::: {#1097b78f .cell execution_count=2}\n``` {.python .cell-code}\n##NEW\n# Generator function to obstruct a nurse resource at specified intervals\n# for specified amounts of time\ndef obstruct_nurse(self):\n    while True:\n        print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n        # The generator first pauses for the frequency period\n        yield self.env.timeout(g.unav_freq_nurse)\n\n        # Once elapsed, the generator requests (demands?) a nurse with\n        # a priority of -1.  This ensure it takes priority over any patients\n        # (whose priority values start at 1).  But it also means that the\n        # nurse won't go on a break until they've finished with the current\n        # patient\n        with self.nurse.request(priority=-1) as req:\n            yield req\n\n            print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                    f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n            # Freeze with the nurse held in place for the unavailability\n            # time (ie duration of the nurse's break).  Here, both the\n            # duration and frequency are fixed, but you could randomly\n            # sample them from a distribution too if preferred.\n            yield self.env.timeout(g.unav_time_nurse)\n```\n:::\n\n\n#### The run method\n\nIn our run method, we now start up the `obstruct_nurse` process in addition to the `generator_patient_arrivals` process.\n\n::: {#ac68d4e2 .cell execution_count=3}\n``` {.python .cell-code}\ndef run(self):\n    # Start up DES generators\n    self.env.process(self.generator_patient_arrivals())\n    ##NEW - we also need to start up the obstructor generator now too\n    self.env.process(self.obstruct_nurse())\n\n    # Run for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Calculate results over the run\n    self.calculate_run_results()\n\n    return self.results_df\n```\n:::\n\n\n### Trial class\n\nThe trial class is unchanged.\n\n## The full code\n\nThe full updated code for the model is given below.\n\n:::{.callout-note collapse=\"true\"}\n### Click here to view the full code\n\n::: {#398b620e .cell execution_count=4}\n``` {.python .cell-code}\nimport simpy\nimport random\nimport pandas as pd\n\n# Class to store global parameter values.\nclass g:\n    # Inter-arrival times\n    patient_inter = 5\n\n    # Activity times\n    mean_n_consult_time = 6\n\n    # Resource numbers\n    number_of_nurses = 1\n\n    ##NEW - added values to specify how long nurse is unavailable and at what\n    # frequency (in this example, every 2 hours, the nurse will be unavailable\n    # for 15 minutes)\n    unav_time_nurse = 15\n    unav_freq_nurse = 120\n\n    # Simulation meta parameters\n    sim_duration = 2880\n    number_of_runs = 1\n    warm_up_period = 1440\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = 0\n        self.priority = random.randint(1,5)\n\n# Class representing our model of the clinic.\nclass Model:\n    # Constructor\n    def __init__(self, run_number):\n        # Set up SimPy environment\n        self.env = simpy.Environment()\n\n        # Set up counters to use as entity IDs\n        self.patient_counter = 0\n\n        # Set up resources\n        self.nurse = simpy.PriorityResource(self.env,\n                                            capacity=g.number_of_nurses)\n\n        # Set run number from value passed in\n        self.run_number = run_number\n\n        # Set up DataFrame to store patient-level results\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Set up attributes that will store mean queuing times across the run\n        self.mean_q_time_nurse = 0\n\n        random.seed(42)\n\n    # Generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        while True:\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            self.env.process(self.attend_clinic(p))\n\n            sampled_inter = random.expovariate(1.0 / g.patient_inter)\n\n            yield self.env.timeout(sampled_inter)\n\n    ##NEW\n    # Generator function to obstruct a nurse resource at specified intervals\n    # for specified amounts of time\n    def obstruct_nurse(self):\n        while True:\n            print (f\"{self.env.now:.2f}: The nurse will go on a break at around time\",\n                   f\"{(self.env.now + g.unav_freq_nurse):.2f}\")\n\n            # The generator first pauses for the frequency period\n            yield self.env.timeout(g.unav_freq_nurse)\n\n            # Once elapsed, the generator requests (demands?) a nurse with\n            # a priority of -1.  This ensure it takes priority over any patients\n            # (whose priority values start at 1).  But it also means that the\n            # nurse won't go on a break until they've finished with the current\n            # patient\n            with self.nurse.request(priority=-1) as req:\n                yield req\n\n                print (f\"{self.env.now:.2f}: The nurse is now on a break and will be back at\",\n                       f\"{(self.env.now + g.unav_time_nurse):.2f}\")\n\n                # Freeze with the nurse held in place for the unavailability\n                # time (ie duration of the nurse's break).  Here, both the\n                # duration and frequency are fixed, but you could randomly\n                # sample them from a distribution too if preferred.\n                yield self.env.timeout(g.unav_time_nurse)\n\n    # Generator function representing pathway for patients attending the\n    # clinic.\n    def attend_clinic(self, patient):\n        # Nurse consultation activity\n        start_q_nurse = self.env.now\n\n        with self.nurse.request(priority=patient.priority) as req:\n            yield req\n\n            end_q_nurse = self.env.now\n\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            if self.env.now > g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = (\n                    patient.q_time_nurse\n                )\n\n            sampled_nurse_act_time = random.expovariate(1.0 /\n                                                        g.mean_n_consult_time)\n\n            yield self.env.timeout(sampled_nurse_act_time)\n\n    # Method to calculate and store results over the run\n    def calculate_run_results(self):\n        self.results_df.drop([1], inplace=True)\n\n        self.mean_q_time_nurse = self.results_df[\"Q Time Nurse\"].mean()\n\n    # Method to run a single run of the simulation\n    def run(self):\n        # Start up DES generators\n        self.env.process(self.generator_patient_arrivals())\n        ##NEW - we also need to start up the obstructor generator now too\n        self.env.process(self.obstruct_nurse())\n\n        # Run for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Calculate results over the run\n        self.calculate_run_results()\n\n        return self.results_df\n\n# Class representing a Trial for our simulation\nclass Trial:\n    # Constructor\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    # Method to calculate and store means across runs in the trial\n    def calculate_means_over_trial(self):\n        self.mean_q_time_nurse_trial = (\n            self.df_trial_results[\"Mean Q Time Nurse\"].mean()\n        )\n\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results and store it against\n        # the run number in the trial results dataframe. We also return the\n        # full patient-level dataframes.\n\n        # First, create an empty list for storing our patient-level dataframes.\n        results_dfs = []\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            patient_level_results = my_model.run()\n\n            # First let's record our mean wait time for this run\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_nurse]\n\n            # Next let's work on our patient-level results dataframes\n            # We start by rounding everything to 2 decimal places\n            patient_level_results = patient_level_results.round(2)\n            # Add a new column recording the run\n            patient_level_results['run'] = run\n            # Now we're just going to add this to our empty list (or, after the first\n            # time we loop through, as an extra dataframe in our list)\n            results_dfs.append(patient_level_results)\n\n        all_results_patient_level = pd.concat(results_dfs)\n\n        # This calculates the attribute self.mean_q_time_nurse_trial\n        self.calculate_means_over_trial()\n\n        # Once the trial (ie all runs) has completed, return the results\n        return self.df_trial_results, all_results_patient_level, self.mean_q_time_nurse_trial\n\n    # Method to print trial results, including averages across runs\n    def print_trial_results(self):\n        print (\"Trial Results\")\n        print (self.df_trial_results)\n\n        print (f\"Mean Q Nurse : {self.mean_q_time_nurse_trial:.1f} minutes\")\n```\n:::\n\n\n:::\n\n## Evaluating the outputs\n\nLet's look at the printed output showing when our nurses were obstructed.\n\nThe first number in each line of output shows the simulation time when the message was generated.\n\n::: {#f8fea40c .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\n0.00: The nurse will go on a break at around time 120.00\n120.15: The nurse is now on a break and will be back at 135.15\n135.15: The nurse will go on a break at around time 255.15\n258.44: The nurse is now on a break and will be back at 273.44\n273.44: The nurse will go on a break at around time 393.44\n404.26: The nurse is now on a break and will be back at 419.26\n419.26: The nurse will go on a break at around time 539.26\n540.82: The nurse is now on a break and will be back at 555.82\n555.82: The nurse will go on a break at around time 675.82\n680.63: The nurse is now on a break and will be back at 695.63\n695.63: The nurse will go on a break at around time 815.63\n827.06: The nurse is now on a break and will be back at 842.06\n842.06: The nurse will go on a break at around time 962.06\n968.91: The nurse is now on a break and will be back at 983.91\n983.91: The nurse will go on a break at around time 1103.91\n1106.20: The nurse is now on a break and will be back at 1121.20\n1121.20: The nurse will go on a break at around time 1241.20\n1242.30: The nurse is now on a break and will be back at 1257.30\n1257.30: The nurse will go on a break at around time 1377.30\n1389.51: The nurse is now on a break and will be back at 1404.51\n1404.51: The nurse will go on a break at around time 1524.51\n1532.18: The nurse is now on a break and will be back at 1547.18\n1547.18: The nurse will go on a break at around time 1667.18\n1672.09: The nurse is now on a break and will be back at 1687.09\n1687.09: The nurse will go on a break at around time 1807.09\n1807.86: The nurse is now on a break and will be back at 1822.86\n1822.86: The nurse will go on a break at around time 1942.86\n1947.64: The nurse is now on a break and will be back at 1962.64\n1962.64: The nurse will go on a break at around time 2082.64\n2084.27: The nurse is now on a break and will be back at 2099.27\n2099.27: The nurse will go on a break at around time 2219.27\n2221.93: The nurse is now on a break and will be back at 2236.93\n2236.93: The nurse will go on a break at around time 2356.93\n2359.05: The nurse is now on a break and will be back at 2374.05\n2374.05: The nurse will go on a break at around time 2494.05\n2494.42: The nurse is now on a break and will be back at 2509.42\n2509.42: The nurse will go on a break at around time 2629.42\n2635.29: The nurse is now on a break and will be back at 2650.29\n2650.29: The nurse will go on a break at around time 2770.29\n2776.28: The nurse is now on a break and will be back at 2791.28\n2791.28: The nurse will go on a break at around time 2911.28\n2911.72: The nurse is now on a break and will be back at 2926.72\n2926.72: The nurse will go on a break at around time 3046.72\n3050.18: The nurse is now on a break and will be back at 3065.18\n3065.18: The nurse will go on a break at around time 3185.18\n3203.13: The nurse is now on a break and will be back at 3218.13\n3218.13: The nurse will go on a break at around time 3338.13\n3350.63: The nurse is now on a break and will be back at 3365.63\n3365.63: The nurse will go on a break at around time 3485.63\n3486.03: The nurse is now on a break and will be back at 3501.03\n3501.03: The nurse will go on a break at around time 3621.03\n3623.49: The nurse is now on a break and will be back at 3638.49\n3638.49: The nurse will go on a break at around time 3758.49\n3768.95: The nurse is now on a break and will be back at 3783.95\n3783.95: The nurse will go on a break at around time 3903.95\n3908.67: The nurse is now on a break and will be back at 3923.67\n3923.67: The nurse will go on a break at around time 4043.67\n4045.96: The nurse is now on a break and will be back at 4060.96\n4060.96: The nurse will go on a break at around time 4180.96\n4184.07: The nurse is now on a break and will be back at 4199.07\n4199.07: The nurse will go on a break at around time 4319.07\n```\n:::\n:::\n\n\nNow let's look at some of the other outputs and compare them with a version without the nurse obstruction.\n\n\n\n\n\nNow let's look at some of the other outputs and compare them with a version without the nurse obstruction.\n\n\n\n::: {#3ce4de83 .cell execution_count=9}\n\n::: {.cell-output .cell-output-stdout}\n```\nThe average wait when there are no nurse breaks is 143.18 minutes\n```\n:::\n:::\n\n\n::: {#f6ef38ac .cell execution_count=10}\n\n::: {.cell-output .cell-output-stdout}\n```\nThe average wait when there are nurse breaks is 299.7 minutes\n```\n:::\n:::\n\n\n",
    "supporting": [
      "modelling_resource_unavailability_files"
    ],
    "filters": [],
    "includes": {}
  }
}